{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release of Docker, so API calls are versioned to ensure that clients don't break.  For Docker Engine 17.06, the API version is 1.30. To lock to this version, you prefix the URL with `/v1.30`. For example, calling `/info` is the same as calling `/v1.30/info`.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  In previous versions of Docker, it was possible to access the API without providing a version. This behaviour is now deprecated will be removed in a future version of Docker.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer Docker daemons.  This documentation is for version 1.30 of the API, which was introduced with Docker 17.06. Use this table to find documentation for previous versions of the API:  Docker version  | API version | Changes ----------------|-------------|--------- 17.05.x | [1.29](https://docs.docker.com/engine/api/v1.29/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-29-api-changes) 17.04.x | [1.28](https://docs.docker.com/engine/api/v1.28/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-28-api-changes) 17.03.1 | [1.27](https://docs.docker.com/engine/api/v1.27/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-27-api-changes) 1.13.1 & 17.03.0 | [1.26](https://docs.docker.com/engine/api/v1.26/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-26-api-changes) 1.13.0 | [1.25](https://docs.docker.com/engine/api/v1.25/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-25-api-changes) 1.12.x | [1.24](https://docs.docker.com/engine/api/v1.24/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-24-api-changes) 1.11.x | [1.23](https://docs.docker.com/engine/api/v1.23/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-23-api-changes) 1.10.x | [1.22](https://docs.docker.com/engine/api/v1.22/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-22-api-changes) 1.9.x | [1.21](https://docs.docker.com/engine/api/v1.21/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-21-api-changes) 1.8.x | [1.20](https://docs.docker.com/engine/api/v1.20/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-20-api-changes) 1.7.x | [1.19](https://docs.docker.com/engine/api/v1.19/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-19-api-changes) 1.6.x | [1.18](https://docs.docker.com/engine/api/v1.18/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-18-api-changes)  # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a Base64 encoded (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 

   OpenAPI Version: 3.0.1
   Docker Engine API API version: 1.30
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : DockerEngine.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.Model where

import DockerEngine.Core
import DockerEngine.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** All
newtype All = All { unAll :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: [InlineObject] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** BodyText
newtype BodyText = BodyText { unBodyText :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Buildargs
newtype Buildargs = Buildargs { unBuildargs :: Int } deriving (P.Eq, P.Show)

-- ** Cachefrom
newtype Cachefrom = Cachefrom { unCachefrom :: Text } deriving (P.Eq, P.Show)

-- ** Changes
newtype Changes = Changes { unChanges :: Text } deriving (P.Eq, P.Show)

-- ** Comment
newtype Comment = Comment { unComment :: Text } deriving (P.Eq, P.Show)

-- ** Condition
newtype Condition = Condition { unCondition :: Text } deriving (P.Eq, P.Show)

-- ** Container
newtype Container = Container { unContainer :: Text } deriving (P.Eq, P.Show)

-- ** Cpuperiod
newtype Cpuperiod = Cpuperiod { unCpuperiod :: Int } deriving (P.Eq, P.Show)

-- ** Cpuquota
newtype Cpuquota = Cpuquota { unCpuquota :: Int } deriving (P.Eq, P.Show)

-- ** Cpusetcpus
newtype Cpusetcpus = Cpusetcpus { unCpusetcpus :: Text } deriving (P.Eq, P.Show)

-- ** Cpushares
newtype Cpushares = Cpushares { unCpushares :: Int } deriving (P.Eq, P.Show)

-- ** DetachKeys
newtype DetachKeys = DetachKeys { unDetachKeys :: Text } deriving (P.Eq, P.Show)

-- ** Details
newtype Details = Details { unDetails :: Bool } deriving (P.Eq, P.Show)

-- ** Digests
newtype Digests = Digests { unDigests :: Bool } deriving (P.Eq, P.Show)

-- ** Dockerfile
newtype Dockerfile = Dockerfile { unDockerfile :: Text } deriving (P.Eq, P.Show)

-- ** Extrahosts
newtype Extrahosts = Extrahosts { unExtrahosts :: Text } deriving (P.Eq, P.Show)

-- ** Filters
newtype Filters = Filters { unFilters :: Text } deriving (P.Eq, P.Show)

-- ** Follow
newtype Follow = Follow { unFollow :: Bool } deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)

-- ** Forcerm
newtype Forcerm = Forcerm { unForcerm :: Bool } deriving (P.Eq, P.Show)

-- ** FromImage
newtype FromImage = FromImage { unFromImage :: Text } deriving (P.Eq, P.Show)

-- ** FromSrc
newtype FromSrc = FromSrc { unFromSrc :: Text } deriving (P.Eq, P.Show)

-- ** H
newtype H = H { unH :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** ImagesTarball
newtype ImagesTarball = ImagesTarball { unImagesTarball :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputImage
newtype InputImage = InputImage { unInputImage :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputStream
newtype InputStream = InputStream { unInputStream :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputStreamFilePath
newtype InputStreamFilePath = InputStreamFilePath { unInputStreamFilePath :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InsertDefaults
newtype InsertDefaults = InsertDefaults { unInsertDefaults :: Bool } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Link
newtype Link = Link { unLink :: Bool } deriving (P.Eq, P.Show)

-- ** Logs
newtype Logs = Logs { unLogs :: Bool } deriving (P.Eq, P.Show)

-- ** Memory
newtype Memory = Memory { unMemory :: Int } deriving (P.Eq, P.Show)

-- ** Memswap
newtype Memswap = Memswap { unMemswap :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Names
newtype Names = Names { unNames :: [Text] } deriving (P.Eq, P.Show)

-- ** Networkmode
newtype Networkmode = Networkmode { unNetworkmode :: Text } deriving (P.Eq, P.Show)

-- ** NoOverwriteDirNonDir
newtype NoOverwriteDirNonDir = NoOverwriteDirNonDir { unNoOverwriteDirNonDir :: Text } deriving (P.Eq, P.Show)

-- ** Nocache
newtype Nocache = Nocache { unNocache :: Bool } deriving (P.Eq, P.Show)

-- ** Noprune
newtype Noprune = Noprune { unNoprune :: Bool } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** Pause
newtype Pause = Pause { unPause :: Bool } deriving (P.Eq, P.Show)

-- ** PsArgs
newtype PsArgs = PsArgs { unPsArgs :: Text } deriving (P.Eq, P.Show)

-- ** Pull
newtype Pull = Pull { unPull :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Bool } deriving (P.Eq, P.Show)

-- ** Quiet
newtype Quiet = Quiet { unQuiet :: Bool } deriving (P.Eq, P.Show)

-- ** RegistryAuthFrom
newtype RegistryAuthFrom = RegistryAuthFrom { unRegistryAuthFrom :: Text } deriving (P.Eq, P.Show)

-- ** Remote
newtype Remote = Remote { unRemote :: Text } deriving (P.Eq, P.Show)

-- ** Repo
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)

-- ** Rm
newtype Rm = Rm { unRm :: Bool } deriving (P.Eq, P.Show)

-- ** Rollback
newtype Rollback = Rollback { unRollback :: Text } deriving (P.Eq, P.Show)

-- ** RotateManagerToken
newtype RotateManagerToken = RotateManagerToken { unRotateManagerToken :: Bool } deriving (P.Eq, P.Show)

-- ** RotateManagerUnlockKey
newtype RotateManagerUnlockKey = RotateManagerUnlockKey { unRotateManagerUnlockKey :: Bool } deriving (P.Eq, P.Show)

-- ** RotateWorkerToken
newtype RotateWorkerToken = RotateWorkerToken { unRotateWorkerToken :: Bool } deriving (P.Eq, P.Show)

-- ** Shmsize
newtype Shmsize = Shmsize { unShmsize :: Int } deriving (P.Eq, P.Show)

-- ** Signal
newtype Signal = Signal { unSignal :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Int } deriving (P.Eq, P.Show)

-- ** SinceText
newtype SinceText = SinceText { unSinceText :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Bool } deriving (P.Eq, P.Show)

-- ** Squash
newtype Squash = Squash { unSquash :: Bool } deriving (P.Eq, P.Show)

-- ** Stderr
newtype Stderr = Stderr { unStderr :: Bool } deriving (P.Eq, P.Show)

-- ** Stdin
newtype Stdin = Stdin { unStdin :: Bool } deriving (P.Eq, P.Show)

-- ** Stdout
newtype Stdout = Stdout { unStdout :: Bool } deriving (P.Eq, P.Show)

-- ** Stream
newtype Stream = Stream { unStream :: Bool } deriving (P.Eq, P.Show)

-- ** T
newtype T = T { unT :: Int } deriving (P.Eq, P.Show)

-- ** TText
newtype TText = TText { unTText :: Text } deriving (P.Eq, P.Show)

-- ** Tag
newtype Tag = Tag { unTag :: Text } deriving (P.Eq, P.Show)

-- ** Tail
newtype Tail = Tail { unTail :: Text } deriving (P.Eq, P.Show)

-- ** TarContext
newtype TarContext = TarContext { unTarContext :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Term
newtype Term = Term { unTerm :: Text } deriving (P.Eq, P.Show)

-- ** Timeout
newtype Timeout = Timeout { unTimeout :: Int } deriving (P.Eq, P.Show)

-- ** Timestamps
newtype Timestamps = Timestamps { unTimestamps :: Bool } deriving (P.Eq, P.Show)

-- ** Until
newtype Until = Until { unUntil :: Text } deriving (P.Eq, P.Show)

-- ** V
newtype V = V { unV :: Bool } deriving (P.Eq, P.Show)

-- ** Verbose
newtype Verbose = Verbose { unVerbose :: Bool } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Integer } deriving (P.Eq, P.Show)

-- ** VersionInt
newtype VersionInt = VersionInt { unVersionInt :: Int } deriving (P.Eq, P.Show)

-- ** W
newtype W = W { unW :: Int } deriving (P.Eq, P.Show)

-- ** XRegistryAuth
newtype XRegistryAuth = XRegistryAuth { unXRegistryAuth :: Text } deriving (P.Eq, P.Show)

-- ** XRegistryConfig
newtype XRegistryConfig = XRegistryConfig { unXRegistryConfig :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AuthConfig
-- | AuthConfig
data AuthConfig = AuthConfig
  { authConfigUsername :: !(Maybe Text) -- ^ "username"
  , authConfigPassword :: !(Maybe Text) -- ^ "password"
  , authConfigEmail :: !(Maybe Text) -- ^ "email"
  , authConfigServeraddress :: !(Maybe Text) -- ^ "serveraddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthConfig
instance A.FromJSON AuthConfig where
  parseJSON = A.withObject "AuthConfig" $ \o ->
    AuthConfig
      <$> (o .:? "username")
      <*> (o .:? "password")
      <*> (o .:? "email")
      <*> (o .:? "serveraddress")

-- | ToJSON AuthConfig
instance A.ToJSON AuthConfig where
  toJSON AuthConfig {..} =
   _omitNulls
      [ "username" .= authConfigUsername
      , "password" .= authConfigPassword
      , "email" .= authConfigEmail
      , "serveraddress" .= authConfigServeraddress
      ]


-- | Construct a value of type 'AuthConfig' (by applying it's required fields, if any)
mkAuthConfig
  :: AuthConfig
mkAuthConfig =
  AuthConfig
  { authConfigUsername = Nothing
  , authConfigPassword = Nothing
  , authConfigEmail = Nothing
  , authConfigServeraddress = Nothing
  }

-- ** BuildInfo
-- | BuildInfo
data BuildInfo = BuildInfo
  { buildInfoId :: !(Maybe Text) -- ^ "id"
  , buildInfoStream :: !(Maybe Text) -- ^ "stream"
  , buildInfoError :: !(Maybe Text) -- ^ "error"
  , buildInfoErrorDetail :: !(Maybe ErrorDetail) -- ^ "errorDetail"
  , buildInfoStatus :: !(Maybe Text) -- ^ "status"
  , buildInfoProgress :: !(Maybe Text) -- ^ "progress"
  , buildInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildInfo
instance A.FromJSON BuildInfo where
  parseJSON = A.withObject "BuildInfo" $ \o ->
    BuildInfo
      <$> (o .:? "id")
      <*> (o .:? "stream")
      <*> (o .:? "error")
      <*> (o .:? "errorDetail")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON BuildInfo
instance A.ToJSON BuildInfo where
  toJSON BuildInfo {..} =
   _omitNulls
      [ "id" .= buildInfoId
      , "stream" .= buildInfoStream
      , "error" .= buildInfoError
      , "errorDetail" .= buildInfoErrorDetail
      , "status" .= buildInfoStatus
      , "progress" .= buildInfoProgress
      , "progressDetail" .= buildInfoProgressDetail
      ]


-- | Construct a value of type 'BuildInfo' (by applying it's required fields, if any)
mkBuildInfo
  :: BuildInfo
mkBuildInfo =
  BuildInfo
  { buildInfoId = Nothing
  , buildInfoStream = Nothing
  , buildInfoError = Nothing
  , buildInfoErrorDetail = Nothing
  , buildInfoStatus = Nothing
  , buildInfoProgress = Nothing
  , buildInfoProgressDetail = Nothing
  }

-- ** ClusterInfo
-- | ClusterInfo
data ClusterInfo = ClusterInfo
  { clusterInfoId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , clusterInfoVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , clusterInfoCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , clusterInfoUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , clusterInfoSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  , clusterInfoTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  , clusterInfoRootRotationInProgress :: !(Maybe Bool) -- ^ "RootRotationInProgress" - Whether there is currently a root CA rotation in progress for the swarm
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClusterInfo
instance A.FromJSON ClusterInfo where
  parseJSON = A.withObject "ClusterInfo" $ \o ->
    ClusterInfo
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "TLSInfo")
      <*> (o .:? "RootRotationInProgress")

-- | ToJSON ClusterInfo
instance A.ToJSON ClusterInfo where
  toJSON ClusterInfo {..} =
   _omitNulls
      [ "ID" .= clusterInfoId
      , "Version" .= clusterInfoVersion
      , "CreatedAt" .= clusterInfoCreatedAt
      , "UpdatedAt" .= clusterInfoUpdatedAt
      , "Spec" .= clusterInfoSpec
      , "TLSInfo" .= clusterInfoTlsInfo
      , "RootRotationInProgress" .= clusterInfoRootRotationInProgress
      ]


-- | Construct a value of type 'ClusterInfo' (by applying it's required fields, if any)
mkClusterInfo
  :: ClusterInfo
mkClusterInfo =
  ClusterInfo
  { clusterInfoId = Nothing
  , clusterInfoVersion = Nothing
  , clusterInfoCreatedAt = Nothing
  , clusterInfoUpdatedAt = Nothing
  , clusterInfoSpec = Nothing
  , clusterInfoTlsInfo = Nothing
  , clusterInfoRootRotationInProgress = Nothing
  }

-- ** Config
-- | Config
data Config = Config
  { configId :: !(Maybe Text) -- ^ "ID"
  , configVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , configCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , configUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , configSpec :: !(Maybe ConfigSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Config
instance A.FromJSON Config where
  parseJSON = A.withObject "Config" $ \o ->
    Config
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Config
instance A.ToJSON Config where
  toJSON Config {..} =
   _omitNulls
      [ "ID" .= configId
      , "Version" .= configVersion
      , "CreatedAt" .= configCreatedAt
      , "UpdatedAt" .= configUpdatedAt
      , "Spec" .= configSpec
      ]


-- | Construct a value of type 'Config' (by applying it's required fields, if any)
mkConfig
  :: Config
mkConfig =
  Config
  { configId = Nothing
  , configVersion = Nothing
  , configCreatedAt = Nothing
  , configUpdatedAt = Nothing
  , configSpec = Nothing
  }

-- ** ConfigSpec
-- | ConfigSpec
data ConfigSpec = ConfigSpec
  { configSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the config.
  , configSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , configSpecData :: !(Maybe [Text]) -- ^ "Data" - Base64-url-safe-encoded config data
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigSpec
instance A.FromJSON ConfigSpec where
  parseJSON = A.withObject "ConfigSpec" $ \o ->
    ConfigSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")

-- | ToJSON ConfigSpec
instance A.ToJSON ConfigSpec where
  toJSON ConfigSpec {..} =
   _omitNulls
      [ "Name" .= configSpecName
      , "Labels" .= configSpecLabels
      , "Data" .= configSpecData
      ]


-- | Construct a value of type 'ConfigSpec' (by applying it's required fields, if any)
mkConfigSpec
  :: ConfigSpec
mkConfigSpec =
  ConfigSpec
  { configSpecName = Nothing
  , configSpecLabels = Nothing
  , configSpecData = Nothing
  }

-- ** ContainerConfig
-- | ContainerConfig
-- Configuration for a container that is portable between hosts
data ContainerConfig = ContainerConfig
  { containerConfigHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , containerConfigDomainname :: !(Maybe Text) -- ^ "Domainname" - The domain name to use for the container.
  , containerConfigUser :: !(Maybe Text) -- ^ "User" - The user that commands are run as inside the container.
  , containerConfigAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Whether to attach to &#x60;stdin&#x60;.
  , containerConfigAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Whether to attach to &#x60;stdout&#x60;.
  , containerConfigAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Whether to attach to &#x60;stderr&#x60;.
  , containerConfigExposedPorts :: !(Maybe (Map.Map String A.Value)) -- ^ "ExposedPorts" - An object mapping ports to an empty object in the form:  &#x60;{\&quot;&lt;port&gt;/&lt;tcp|udp&gt;\&quot;: {}}&#x60; 
  , containerConfigTty :: !(Maybe Bool) -- ^ "Tty" - Attach standard streams to a TTY, including &#x60;stdin&#x60; if it is not closed.
  , containerConfigOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , containerConfigStdinOnce :: !(Maybe Bool) -- ^ "StdinOnce" - Close &#x60;stdin&#x60; after one attached client disconnects
  , containerConfigEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables to set inside the container in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;. A variable without &#x60;&#x3D;&#x60; is removed from the environment, rather than to have an empty value. 
  , containerConfigHealthcheck :: !(Maybe HealthConfig) -- ^ "Healthcheck"
  , containerConfigArgsEscaped :: !(Maybe Bool) -- ^ "ArgsEscaped" - Command is already escaped (Windows only)
  , containerConfigImage :: !(Maybe Text) -- ^ "Image" - The name of the image to use when creating the container
  , containerConfigVolumes :: !(Maybe ContainerConfigVolumes) -- ^ "Volumes"
  , containerConfigWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for commands to run in.
  , containerConfigNetworkDisabled :: !(Maybe Bool) -- ^ "NetworkDisabled" - Disable networking for the container.
  , containerConfigMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address of the container.
  , containerConfigOnBuild :: !(Maybe [Text]) -- ^ "OnBuild" - &#x60;ONBUILD&#x60; metadata that were defined in the image&#39;s &#x60;Dockerfile&#x60;.
  , containerConfigLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerConfigStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop a container as a string or unsigned integer.
  , containerConfigStopTimeout :: !(Maybe Int) -- ^ "StopTimeout" - Timeout to stop a container in seconds.
  , containerConfigShell :: !(Maybe [Text]) -- ^ "Shell" - Shell for when &#x60;RUN&#x60;, &#x60;CMD&#x60;, and &#x60;ENTRYPOINT&#x60; uses a shell.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerConfig
instance A.FromJSON ContainerConfig where
  parseJSON = A.withObject "ContainerConfig" $ \o ->
    ContainerConfig
      <$> (o .:? "Hostname")
      <*> (o .:? "Domainname")
      <*> (o .:? "User")
      <*> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "ExposedPorts")
      <*> (o .:? "Tty")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "StdinOnce")
      <*> (o .:? "Env")
      <*> (o .:? "Healthcheck")
      <*> (o .:? "ArgsEscaped")
      <*> (o .:? "Image")
      <*> (o .:? "Volumes")
      <*> (o .:? "WorkingDir")
      <*> (o .:? "NetworkDisabled")
      <*> (o .:? "MacAddress")
      <*> (o .:? "OnBuild")
      <*> (o .:? "Labels")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopTimeout")
      <*> (o .:? "Shell")

-- | ToJSON ContainerConfig
instance A.ToJSON ContainerConfig where
  toJSON ContainerConfig {..} =
   _omitNulls
      [ "Hostname" .= containerConfigHostname
      , "Domainname" .= containerConfigDomainname
      , "User" .= containerConfigUser
      , "AttachStdin" .= containerConfigAttachStdin
      , "AttachStdout" .= containerConfigAttachStdout
      , "AttachStderr" .= containerConfigAttachStderr
      , "ExposedPorts" .= containerConfigExposedPorts
      , "Tty" .= containerConfigTty
      , "OpenStdin" .= containerConfigOpenStdin
      , "StdinOnce" .= containerConfigStdinOnce
      , "Env" .= containerConfigEnv
      , "Healthcheck" .= containerConfigHealthcheck
      , "ArgsEscaped" .= containerConfigArgsEscaped
      , "Image" .= containerConfigImage
      , "Volumes" .= containerConfigVolumes
      , "WorkingDir" .= containerConfigWorkingDir
      , "NetworkDisabled" .= containerConfigNetworkDisabled
      , "MacAddress" .= containerConfigMacAddress
      , "OnBuild" .= containerConfigOnBuild
      , "Labels" .= containerConfigLabels
      , "StopSignal" .= containerConfigStopSignal
      , "StopTimeout" .= containerConfigStopTimeout
      , "Shell" .= containerConfigShell
      ]


-- | Construct a value of type 'ContainerConfig' (by applying it's required fields, if any)
mkContainerConfig
  :: ContainerConfig
mkContainerConfig =
  ContainerConfig
  { containerConfigHostname = Nothing
  , containerConfigDomainname = Nothing
  , containerConfigUser = Nothing
  , containerConfigAttachStdin = Nothing
  , containerConfigAttachStdout = Nothing
  , containerConfigAttachStderr = Nothing
  , containerConfigExposedPorts = Nothing
  , containerConfigTty = Nothing
  , containerConfigOpenStdin = Nothing
  , containerConfigStdinOnce = Nothing
  , containerConfigEnv = Nothing
  , containerConfigHealthcheck = Nothing
  , containerConfigArgsEscaped = Nothing
  , containerConfigImage = Nothing
  , containerConfigVolumes = Nothing
  , containerConfigWorkingDir = Nothing
  , containerConfigNetworkDisabled = Nothing
  , containerConfigMacAddress = Nothing
  , containerConfigOnBuild = Nothing
  , containerConfigLabels = Nothing
  , containerConfigStopSignal = Nothing
  , containerConfigStopTimeout = Nothing
  , containerConfigShell = Nothing
  }

-- ** ContainerConfigVolumes
-- | ContainerConfigVolumes
-- An object mapping mount point paths inside the container to empty objects.
data ContainerConfigVolumes = ContainerConfigVolumes
  { containerConfigVolumesAdditionalProperties :: !(Maybe A.Value) -- ^ "additionalProperties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerConfigVolumes
instance A.FromJSON ContainerConfigVolumes where
  parseJSON = A.withObject "ContainerConfigVolumes" $ \o ->
    ContainerConfigVolumes
      <$> (o .:? "additionalProperties")

-- | ToJSON ContainerConfigVolumes
instance A.ToJSON ContainerConfigVolumes where
  toJSON ContainerConfigVolumes {..} =
   _omitNulls
      [ "additionalProperties" .= containerConfigVolumesAdditionalProperties
      ]


-- | Construct a value of type 'ContainerConfigVolumes' (by applying it's required fields, if any)
mkContainerConfigVolumes
  :: ContainerConfigVolumes
mkContainerConfigVolumes =
  ContainerConfigVolumes
  { containerConfigVolumesAdditionalProperties = Nothing
  }

-- ** ContainerSummary
-- | ContainerSummary
data ContainerSummary = ContainerSummary
  { containerSummaryId :: !(Maybe Text) -- ^ "Id" - The ID of this container
  , containerSummaryNames :: !(Maybe [Text]) -- ^ "Names" - The names that this container has been given
  , containerSummaryImage :: !(Maybe Text) -- ^ "Image" - The name of the image used when creating this container
  , containerSummaryImageId :: !(Maybe Text) -- ^ "ImageID" - The ID of the image that this container was created from
  , containerSummaryCommand :: !(Maybe Text) -- ^ "Command" - Command to run when starting the container
  , containerSummaryCreated :: !(Maybe Integer) -- ^ "Created" - When the container was created
  , containerSummaryPorts :: !(Maybe [Port]) -- ^ "Ports" - The ports exposed by this container
  , containerSummarySizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container
  , containerSummarySizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container
  , containerSummaryLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerSummaryState :: !(Maybe Text) -- ^ "State" - The state of this container (e.g. &#x60;Exited&#x60;)
  , containerSummaryStatus :: !(Maybe Text) -- ^ "Status" - Additional human-readable status of this container (e.g. &#x60;Exit 0&#x60;)
  , containerSummaryHostConfig :: !(Maybe ContainerSummaryHostConfig) -- ^ "HostConfig"
  , containerSummaryNetworkSettings :: !(Maybe ContainerSummaryNetworkSettings) -- ^ "NetworkSettings"
  , containerSummaryMounts :: !(Maybe [Mount]) -- ^ "Mounts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummary
instance A.FromJSON ContainerSummary where
  parseJSON = A.withObject "ContainerSummary" $ \o ->
    ContainerSummary
      <$> (o .:? "Id")
      <*> (o .:? "Names")
      <*> (o .:? "Image")
      <*> (o .:? "ImageID")
      <*> (o .:? "Command")
      <*> (o .:? "Created")
      <*> (o .:? "Ports")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Labels")
      <*> (o .:? "State")
      <*> (o .:? "Status")
      <*> (o .:? "HostConfig")
      <*> (o .:? "NetworkSettings")
      <*> (o .:? "Mounts")

-- | ToJSON ContainerSummary
instance A.ToJSON ContainerSummary where
  toJSON ContainerSummary {..} =
   _omitNulls
      [ "Id" .= containerSummaryId
      , "Names" .= containerSummaryNames
      , "Image" .= containerSummaryImage
      , "ImageID" .= containerSummaryImageId
      , "Command" .= containerSummaryCommand
      , "Created" .= containerSummaryCreated
      , "Ports" .= containerSummaryPorts
      , "SizeRw" .= containerSummarySizeRw
      , "SizeRootFs" .= containerSummarySizeRootFs
      , "Labels" .= containerSummaryLabels
      , "State" .= containerSummaryState
      , "Status" .= containerSummaryStatus
      , "HostConfig" .= containerSummaryHostConfig
      , "NetworkSettings" .= containerSummaryNetworkSettings
      , "Mounts" .= containerSummaryMounts
      ]


-- | Construct a value of type 'ContainerSummary' (by applying it's required fields, if any)
mkContainerSummary
  :: ContainerSummary
mkContainerSummary =
  ContainerSummary
  { containerSummaryId = Nothing
  , containerSummaryNames = Nothing
  , containerSummaryImage = Nothing
  , containerSummaryImageId = Nothing
  , containerSummaryCommand = Nothing
  , containerSummaryCreated = Nothing
  , containerSummaryPorts = Nothing
  , containerSummarySizeRw = Nothing
  , containerSummarySizeRootFs = Nothing
  , containerSummaryLabels = Nothing
  , containerSummaryState = Nothing
  , containerSummaryStatus = Nothing
  , containerSummaryHostConfig = Nothing
  , containerSummaryNetworkSettings = Nothing
  , containerSummaryMounts = Nothing
  }

-- ** ContainerSummaryHostConfig
-- | ContainerSummaryHostConfig
data ContainerSummaryHostConfig = ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryHostConfig
instance A.FromJSON ContainerSummaryHostConfig where
  parseJSON = A.withObject "ContainerSummaryHostConfig" $ \o ->
    ContainerSummaryHostConfig
      <$> (o .:? "NetworkMode")

-- | ToJSON ContainerSummaryHostConfig
instance A.ToJSON ContainerSummaryHostConfig where
  toJSON ContainerSummaryHostConfig {..} =
   _omitNulls
      [ "NetworkMode" .= containerSummaryHostConfigNetworkMode
      ]


-- | Construct a value of type 'ContainerSummaryHostConfig' (by applying it's required fields, if any)
mkContainerSummaryHostConfig
  :: ContainerSummaryHostConfig
mkContainerSummaryHostConfig =
  ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode = Nothing
  }

-- ** ContainerSummaryNetworkSettings
-- | ContainerSummaryNetworkSettings
-- A summary of the container's network settings
data ContainerSummaryNetworkSettings = ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryNetworkSettings
instance A.FromJSON ContainerSummaryNetworkSettings where
  parseJSON = A.withObject "ContainerSummaryNetworkSettings" $ \o ->
    ContainerSummaryNetworkSettings
      <$> (o .:? "Networks")

-- | ToJSON ContainerSummaryNetworkSettings
instance A.ToJSON ContainerSummaryNetworkSettings where
  toJSON ContainerSummaryNetworkSettings {..} =
   _omitNulls
      [ "Networks" .= containerSummaryNetworkSettingsNetworks
      ]


-- | Construct a value of type 'ContainerSummaryNetworkSettings' (by applying it's required fields, if any)
mkContainerSummaryNetworkSettings
  :: ContainerSummaryNetworkSettings
mkContainerSummaryNetworkSettings =
  ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks = Nothing
  }

-- ** CreateImageInfo
-- | CreateImageInfo
data CreateImageInfo = CreateImageInfo
  { createImageInfoError :: !(Maybe Text) -- ^ "error"
  , createImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , createImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , createImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageInfo
instance A.FromJSON CreateImageInfo where
  parseJSON = A.withObject "CreateImageInfo" $ \o ->
    CreateImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON CreateImageInfo
instance A.ToJSON CreateImageInfo where
  toJSON CreateImageInfo {..} =
   _omitNulls
      [ "error" .= createImageInfoError
      , "status" .= createImageInfoStatus
      , "progress" .= createImageInfoProgress
      , "progressDetail" .= createImageInfoProgressDetail
      ]


-- | Construct a value of type 'CreateImageInfo' (by applying it's required fields, if any)
mkCreateImageInfo
  :: CreateImageInfo
mkCreateImageInfo =
  CreateImageInfo
  { createImageInfoError = Nothing
  , createImageInfoStatus = Nothing
  , createImageInfoProgress = Nothing
  , createImageInfoProgressDetail = Nothing
  }

-- ** DeviceMapping
-- | DeviceMapping
-- A device mapping between the host and container
data DeviceMapping = DeviceMapping
  { deviceMappingPathOnHost :: !(Maybe Text) -- ^ "PathOnHost"
  , deviceMappingPathInContainer :: !(Maybe Text) -- ^ "PathInContainer"
  , deviceMappingCgroupPermissions :: !(Maybe Text) -- ^ "CgroupPermissions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceMapping
instance A.FromJSON DeviceMapping where
  parseJSON = A.withObject "DeviceMapping" $ \o ->
    DeviceMapping
      <$> (o .:? "PathOnHost")
      <*> (o .:? "PathInContainer")
      <*> (o .:? "CgroupPermissions")

-- | ToJSON DeviceMapping
instance A.ToJSON DeviceMapping where
  toJSON DeviceMapping {..} =
   _omitNulls
      [ "PathOnHost" .= deviceMappingPathOnHost
      , "PathInContainer" .= deviceMappingPathInContainer
      , "CgroupPermissions" .= deviceMappingCgroupPermissions
      ]


-- | Construct a value of type 'DeviceMapping' (by applying it's required fields, if any)
mkDeviceMapping
  :: DeviceMapping
mkDeviceMapping =
  DeviceMapping
  { deviceMappingPathOnHost = Nothing
  , deviceMappingPathInContainer = Nothing
  , deviceMappingCgroupPermissions = Nothing
  }

-- ** EndpointPortConfig
-- | EndpointPortConfig
data EndpointPortConfig = EndpointPortConfig
  { endpointPortConfigName :: !(Maybe Text) -- ^ "Name"
  , endpointPortConfigProtocol :: !(Maybe E'Type) -- ^ "Protocol"
  , endpointPortConfigTargetPort :: !(Maybe Int) -- ^ "TargetPort" - The port inside the container.
  , endpointPortConfigPublishedPort :: !(Maybe Int) -- ^ "PublishedPort" - The port on the swarm hosts.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointPortConfig
instance A.FromJSON EndpointPortConfig where
  parseJSON = A.withObject "EndpointPortConfig" $ \o ->
    EndpointPortConfig
      <$> (o .:? "Name")
      <*> (o .:? "Protocol")
      <*> (o .:? "TargetPort")
      <*> (o .:? "PublishedPort")

-- | ToJSON EndpointPortConfig
instance A.ToJSON EndpointPortConfig where
  toJSON EndpointPortConfig {..} =
   _omitNulls
      [ "Name" .= endpointPortConfigName
      , "Protocol" .= endpointPortConfigProtocol
      , "TargetPort" .= endpointPortConfigTargetPort
      , "PublishedPort" .= endpointPortConfigPublishedPort
      ]


-- | Construct a value of type 'EndpointPortConfig' (by applying it's required fields, if any)
mkEndpointPortConfig
  :: EndpointPortConfig
mkEndpointPortConfig =
  EndpointPortConfig
  { endpointPortConfigName = Nothing
  , endpointPortConfigProtocol = Nothing
  , endpointPortConfigTargetPort = Nothing
  , endpointPortConfigPublishedPort = Nothing
  }

-- ** EndpointSettings
-- | EndpointSettings
-- Configuration for a network endpoint.
data EndpointSettings = EndpointSettings
  { endpointSettingsIpamConfig :: !(Maybe EndpointSettingsIPAMConfig) -- ^ "IPAMConfig"
  , endpointSettingsLinks :: !(Maybe [Text]) -- ^ "Links"
  , endpointSettingsAliases :: !(Maybe [Text]) -- ^ "Aliases"
  , endpointSettingsNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , endpointSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , endpointSettingsGateway :: !(Maybe Text) -- ^ "Gateway"
  , endpointSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress"
  , endpointSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen"
  , endpointSettingsIPv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway"
  , endpointSettingsGlobalIPv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address"
  , endpointSettingsGlobalIPv6PrefixLen :: !(Maybe Integer) -- ^ "GlobalIPv6PrefixLen"
  , endpointSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettings
instance A.FromJSON EndpointSettings where
  parseJSON = A.withObject "EndpointSettings" $ \o ->
    EndpointSettings
      <$> (o .:? "IPAMConfig")
      <*> (o .:? "Links")
      <*> (o .:? "Aliases")
      <*> (o .:? "NetworkID")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "MacAddress")

-- | ToJSON EndpointSettings
instance A.ToJSON EndpointSettings where
  toJSON EndpointSettings {..} =
   _omitNulls
      [ "IPAMConfig" .= endpointSettingsIpamConfig
      , "Links" .= endpointSettingsLinks
      , "Aliases" .= endpointSettingsAliases
      , "NetworkID" .= endpointSettingsNetworkId
      , "EndpointID" .= endpointSettingsEndpointId
      , "Gateway" .= endpointSettingsGateway
      , "IPAddress" .= endpointSettingsIpAddress
      , "IPPrefixLen" .= endpointSettingsIpPrefixLen
      , "IPv6Gateway" .= endpointSettingsIPv6Gateway
      , "GlobalIPv6Address" .= endpointSettingsGlobalIPv6Address
      , "GlobalIPv6PrefixLen" .= endpointSettingsGlobalIPv6PrefixLen
      , "MacAddress" .= endpointSettingsMacAddress
      ]


-- | Construct a value of type 'EndpointSettings' (by applying it's required fields, if any)
mkEndpointSettings
  :: EndpointSettings
mkEndpointSettings =
  EndpointSettings
  { endpointSettingsIpamConfig = Nothing
  , endpointSettingsLinks = Nothing
  , endpointSettingsAliases = Nothing
  , endpointSettingsNetworkId = Nothing
  , endpointSettingsEndpointId = Nothing
  , endpointSettingsGateway = Nothing
  , endpointSettingsIpAddress = Nothing
  , endpointSettingsIpPrefixLen = Nothing
  , endpointSettingsIPv6Gateway = Nothing
  , endpointSettingsGlobalIPv6Address = Nothing
  , endpointSettingsGlobalIPv6PrefixLen = Nothing
  , endpointSettingsMacAddress = Nothing
  }

-- ** EndpointSettingsIPAMConfig
-- | EndpointSettingsIPAMConfig
-- IPAM configurations for the endpoint
data EndpointSettingsIPAMConfig = EndpointSettingsIPAMConfig
  { endpointSettingsIPAMConfigIPv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , endpointSettingsIPAMConfigIPv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  , endpointSettingsIPAMConfigLinkLocalIPs :: !(Maybe [Text]) -- ^ "LinkLocalIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettingsIPAMConfig
instance A.FromJSON EndpointSettingsIPAMConfig where
  parseJSON = A.withObject "EndpointSettingsIPAMConfig" $ \o ->
    EndpointSettingsIPAMConfig
      <$> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")
      <*> (o .:? "LinkLocalIPs")

-- | ToJSON EndpointSettingsIPAMConfig
instance A.ToJSON EndpointSettingsIPAMConfig where
  toJSON EndpointSettingsIPAMConfig {..} =
   _omitNulls
      [ "IPv4Address" .= endpointSettingsIPAMConfigIPv4Address
      , "IPv6Address" .= endpointSettingsIPAMConfigIPv6Address
      , "LinkLocalIPs" .= endpointSettingsIPAMConfigLinkLocalIPs
      ]


-- | Construct a value of type 'EndpointSettingsIPAMConfig' (by applying it's required fields, if any)
mkEndpointSettingsIPAMConfig
  :: EndpointSettingsIPAMConfig
mkEndpointSettingsIPAMConfig =
  EndpointSettingsIPAMConfig
  { endpointSettingsIPAMConfigIPv4Address = Nothing
  , endpointSettingsIPAMConfigIPv6Address = Nothing
  , endpointSettingsIPAMConfigLinkLocalIPs = Nothing
  }

-- ** EndpointSpec
-- | EndpointSpec
-- Properties that can be configured to access and load balance a service.
data EndpointSpec = EndpointSpec
  { endpointSpecMode :: !(Maybe E'Mode) -- ^ "Mode" - The mode of resolution to use for internal load balancing between tasks.
  , endpointSpecPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports" - List of exposed ports that this service is accessible on from the outside. Ports can only be provided if &#x60;vip&#x60; resolution mode is used.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSpec
instance A.FromJSON EndpointSpec where
  parseJSON = A.withObject "EndpointSpec" $ \o ->
    EndpointSpec
      <$> (o .:? "Mode")
      <*> (o .:? "Ports")

-- | ToJSON EndpointSpec
instance A.ToJSON EndpointSpec where
  toJSON EndpointSpec {..} =
   _omitNulls
      [ "Mode" .= endpointSpecMode
      , "Ports" .= endpointSpecPorts
      ]


-- | Construct a value of type 'EndpointSpec' (by applying it's required fields, if any)
mkEndpointSpec
  :: EndpointSpec
mkEndpointSpec =
  EndpointSpec
  { endpointSpecMode = Nothing
  , endpointSpecPorts = Nothing
  }

-- ** ErrorDetail
-- | ErrorDetail
data ErrorDetail = ErrorDetail
  { errorDetailCode :: !(Maybe Int) -- ^ "code"
  , errorDetailMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetail
instance A.FromJSON ErrorDetail where
  parseJSON = A.withObject "ErrorDetail" $ \o ->
    ErrorDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ErrorDetail
instance A.ToJSON ErrorDetail where
  toJSON ErrorDetail {..} =
   _omitNulls
      [ "code" .= errorDetailCode
      , "message" .= errorDetailMessage
      ]


-- | Construct a value of type 'ErrorDetail' (by applying it's required fields, if any)
mkErrorDetail
  :: ErrorDetail
mkErrorDetail =
  ErrorDetail
  { errorDetailCode = Nothing
  , errorDetailMessage = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
-- Represents an error.
data ErrorResponse = ErrorResponse
  { errorResponseMessage :: !(Text) -- ^ /Required/ "message" - The error message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "message")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "message" .= errorResponseMessage
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseMessage': The error message.
  -> ErrorResponse
mkErrorResponse errorResponseMessage =
  ErrorResponse
  { errorResponseMessage
  }

-- ** GraphDriverData
-- | GraphDriverData
-- Information about a container's graph driver.
data GraphDriverData = GraphDriverData
  { graphDriverDataName :: !(Text) -- ^ /Required/ "Name"
  , graphDriverDataData :: !((Map.Map String Text)) -- ^ /Required/ "Data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GraphDriverData
instance A.FromJSON GraphDriverData where
  parseJSON = A.withObject "GraphDriverData" $ \o ->
    GraphDriverData
      <$> (o .:  "Name")
      <*> (o .:  "Data")

-- | ToJSON GraphDriverData
instance A.ToJSON GraphDriverData where
  toJSON GraphDriverData {..} =
   _omitNulls
      [ "Name" .= graphDriverDataName
      , "Data" .= graphDriverDataData
      ]


-- | Construct a value of type 'GraphDriverData' (by applying it's required fields, if any)
mkGraphDriverData
  :: Text -- ^ 'graphDriverDataName' 
  -> (Map.Map String Text) -- ^ 'graphDriverDataData' 
  -> GraphDriverData
mkGraphDriverData graphDriverDataName graphDriverDataData =
  GraphDriverData
  { graphDriverDataName
  , graphDriverDataData
  }

-- ** HealthConfig
-- | HealthConfig
-- A test to perform to check that the container is healthy.
data HealthConfig = HealthConfig
  { healthConfigTest :: !(Maybe [Text]) -- ^ "Test" - The test to perform. Possible values are:  - &#x60;[]&#x60; inherit healthcheck from image or parent image - &#x60;[\&quot;NONE\&quot;]&#x60; disable healthcheck - &#x60;[\&quot;CMD\&quot;, args...]&#x60; exec arguments directly - &#x60;[\&quot;CMD-SHELL\&quot;, command]&#x60; run command with system&#39;s default shell 
  , healthConfigInterval :: !(Maybe Int) -- ^ "Interval" - The time to wait between checks in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  , healthConfigTimeout :: !(Maybe Int) -- ^ "Timeout" - The time to wait before considering the check to have hung. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  , healthConfigRetries :: !(Maybe Int) -- ^ "Retries" - The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.
  , healthConfigStartPeriod :: !(Maybe Int) -- ^ "StartPeriod" - Start period for the container to initialize before starting health-retries countdown in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HealthConfig
instance A.FromJSON HealthConfig where
  parseJSON = A.withObject "HealthConfig" $ \o ->
    HealthConfig
      <$> (o .:? "Test")
      <*> (o .:? "Interval")
      <*> (o .:? "Timeout")
      <*> (o .:? "Retries")
      <*> (o .:? "StartPeriod")

-- | ToJSON HealthConfig
instance A.ToJSON HealthConfig where
  toJSON HealthConfig {..} =
   _omitNulls
      [ "Test" .= healthConfigTest
      , "Interval" .= healthConfigInterval
      , "Timeout" .= healthConfigTimeout
      , "Retries" .= healthConfigRetries
      , "StartPeriod" .= healthConfigStartPeriod
      ]


-- | Construct a value of type 'HealthConfig' (by applying it's required fields, if any)
mkHealthConfig
  :: HealthConfig
mkHealthConfig =
  HealthConfig
  { healthConfigTest = Nothing
  , healthConfigInterval = Nothing
  , healthConfigTimeout = Nothing
  , healthConfigRetries = Nothing
  , healthConfigStartPeriod = Nothing
  }

-- ** HostConfig
-- | HostConfig
-- Container configuration that depends on the host we are running on
data HostConfig = HostConfig
  { hostConfigCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , hostConfigMemory :: !(Maybe Int) -- ^ "Memory" - Memory limit in bytes.
  , hostConfigCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , hostConfigBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , hostConfigBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , hostConfigBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , hostConfigCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , hostConfigCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , hostConfigCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , hostConfigDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , hostConfigDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , hostConfigDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , hostConfigKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , hostConfigMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , hostConfigMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , hostConfigMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , hostConfigNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , hostConfigOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , hostConfigPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , hostConfigUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , hostConfigCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , hostConfigIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  , hostConfigBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest&#x60; to bind-mount a host path into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;host-src:container-dest:ro&#x60; to make the bind-mount read-only inside the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest&#x60; to bind-mount a volume managed by a volume driver into the container. &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest:ro&#x60; to mount the volume read-only inside the container.  &#x60;container-dest&#x60; must be an _absolute_ path. 
  , hostConfigContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigLogConfig :: !(Maybe HostConfigAllOfLogConfig) -- ^ "LogConfig"
  , hostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to.
  , hostConfigPortBindings :: !(Maybe (Map.Map String HostConfigAllOfPortBindings)) -- ^ "PortBindings" - A map of exposed container ports and the host port they should map to.
  , hostConfigRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set.
  , hostConfigVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;.
  , hostConfigMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container.
  , hostConfigCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container.
  , hostConfigCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container.
  , hostConfigDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as.
  , hostConfigIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC namespace to use for the container.
  , hostConfigCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;.
  , hostConfigOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences.
  , hostConfigPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates a random host port for all of a container&#39;s exposed ports.
  , hostConfigReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux.
  , hostConfigStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: &#x60;{ \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; }&#x60;. 
  , hostConfigUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
  , hostConfigShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB.
  , hostConfigSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example: &#x60;{\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;}&#x60; 
  , hostConfigRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only)
  , hostConfigIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfig
instance A.FromJSON HostConfig where
  parseJSON = A.withObject "HostConfig" $ \o ->
    HostConfig
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCPUs")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")
      <*> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")

-- | ToJSON HostConfig
instance A.ToJSON HostConfig where
  toJSON HostConfig {..} =
   _omitNulls
      [ "CpuShares" .= hostConfigCpuShares
      , "Memory" .= hostConfigMemory
      , "CgroupParent" .= hostConfigCgroupParent
      , "BlkioWeight" .= hostConfigBlkioWeight
      , "BlkioWeightDevice" .= hostConfigBlkioWeightDevice
      , "BlkioDeviceReadBps" .= hostConfigBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= hostConfigBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= hostConfigBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= hostConfigBlkioDeviceWriteIOps
      , "CpuPeriod" .= hostConfigCpuPeriod
      , "CpuQuota" .= hostConfigCpuQuota
      , "CpuRealtimePeriod" .= hostConfigCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= hostConfigCpuRealtimeRuntime
      , "CpusetCpus" .= hostConfigCpusetCpus
      , "CpusetMems" .= hostConfigCpusetMems
      , "Devices" .= hostConfigDevices
      , "DeviceCgroupRules" .= hostConfigDeviceCgroupRules
      , "DiskQuota" .= hostConfigDiskQuota
      , "KernelMemory" .= hostConfigKernelMemory
      , "MemoryReservation" .= hostConfigMemoryReservation
      , "MemorySwap" .= hostConfigMemorySwap
      , "MemorySwappiness" .= hostConfigMemorySwappiness
      , "NanoCPUs" .= hostConfigNanoCpUs
      , "OomKillDisable" .= hostConfigOomKillDisable
      , "PidsLimit" .= hostConfigPidsLimit
      , "Ulimits" .= hostConfigUlimits
      , "CpuCount" .= hostConfigCpuCount
      , "CpuPercent" .= hostConfigCpuPercent
      , "IOMaximumIOps" .= hostConfigIoMaximumIOps
      , "IOMaximumBandwidth" .= hostConfigIoMaximumBandwidth
      , "Binds" .= hostConfigBinds
      , "ContainerIDFile" .= hostConfigContainerIdFile
      , "LogConfig" .= hostConfigLogConfig
      , "NetworkMode" .= hostConfigNetworkMode
      , "PortBindings" .= hostConfigPortBindings
      , "RestartPolicy" .= hostConfigRestartPolicy
      , "AutoRemove" .= hostConfigAutoRemove
      , "VolumeDriver" .= hostConfigVolumeDriver
      , "VolumesFrom" .= hostConfigVolumesFrom
      , "Mounts" .= hostConfigMounts
      , "CapAdd" .= hostConfigCapAdd
      , "CapDrop" .= hostConfigCapDrop
      , "Dns" .= hostConfigDns
      , "DnsOptions" .= hostConfigDnsOptions
      , "DnsSearch" .= hostConfigDnsSearch
      , "ExtraHosts" .= hostConfigExtraHosts
      , "GroupAdd" .= hostConfigGroupAdd
      , "IpcMode" .= hostConfigIpcMode
      , "Cgroup" .= hostConfigCgroup
      , "Links" .= hostConfigLinks
      , "OomScoreAdj" .= hostConfigOomScoreAdj
      , "PidMode" .= hostConfigPidMode
      , "Privileged" .= hostConfigPrivileged
      , "PublishAllPorts" .= hostConfigPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigReadonlyRootfs
      , "SecurityOpt" .= hostConfigSecurityOpt
      , "StorageOpt" .= hostConfigStorageOpt
      , "Tmpfs" .= hostConfigTmpfs
      , "UTSMode" .= hostConfigUtsMode
      , "UsernsMode" .= hostConfigUsernsMode
      , "ShmSize" .= hostConfigShmSize
      , "Sysctls" .= hostConfigSysctls
      , "Runtime" .= hostConfigRuntime
      , "ConsoleSize" .= hostConfigConsoleSize
      , "Isolation" .= hostConfigIsolation
      ]


-- | Construct a value of type 'HostConfig' (by applying it's required fields, if any)
mkHostConfig
  :: HostConfig
mkHostConfig =
  HostConfig
  { hostConfigCpuShares = Nothing
  , hostConfigMemory = Nothing
  , hostConfigCgroupParent = Nothing
  , hostConfigBlkioWeight = Nothing
  , hostConfigBlkioWeightDevice = Nothing
  , hostConfigBlkioDeviceReadBps = Nothing
  , hostConfigBlkioDeviceWriteBps = Nothing
  , hostConfigBlkioDeviceReadIOps = Nothing
  , hostConfigBlkioDeviceWriteIOps = Nothing
  , hostConfigCpuPeriod = Nothing
  , hostConfigCpuQuota = Nothing
  , hostConfigCpuRealtimePeriod = Nothing
  , hostConfigCpuRealtimeRuntime = Nothing
  , hostConfigCpusetCpus = Nothing
  , hostConfigCpusetMems = Nothing
  , hostConfigDevices = Nothing
  , hostConfigDeviceCgroupRules = Nothing
  , hostConfigDiskQuota = Nothing
  , hostConfigKernelMemory = Nothing
  , hostConfigMemoryReservation = Nothing
  , hostConfigMemorySwap = Nothing
  , hostConfigMemorySwappiness = Nothing
  , hostConfigNanoCpUs = Nothing
  , hostConfigOomKillDisable = Nothing
  , hostConfigPidsLimit = Nothing
  , hostConfigUlimits = Nothing
  , hostConfigCpuCount = Nothing
  , hostConfigCpuPercent = Nothing
  , hostConfigIoMaximumIOps = Nothing
  , hostConfigIoMaximumBandwidth = Nothing
  , hostConfigBinds = Nothing
  , hostConfigContainerIdFile = Nothing
  , hostConfigLogConfig = Nothing
  , hostConfigNetworkMode = Nothing
  , hostConfigPortBindings = Nothing
  , hostConfigRestartPolicy = Nothing
  , hostConfigAutoRemove = Nothing
  , hostConfigVolumeDriver = Nothing
  , hostConfigVolumesFrom = Nothing
  , hostConfigMounts = Nothing
  , hostConfigCapAdd = Nothing
  , hostConfigCapDrop = Nothing
  , hostConfigDns = Nothing
  , hostConfigDnsOptions = Nothing
  , hostConfigDnsSearch = Nothing
  , hostConfigExtraHosts = Nothing
  , hostConfigGroupAdd = Nothing
  , hostConfigIpcMode = Nothing
  , hostConfigCgroup = Nothing
  , hostConfigLinks = Nothing
  , hostConfigOomScoreAdj = Nothing
  , hostConfigPidMode = Nothing
  , hostConfigPrivileged = Nothing
  , hostConfigPublishAllPorts = Nothing
  , hostConfigReadonlyRootfs = Nothing
  , hostConfigSecurityOpt = Nothing
  , hostConfigStorageOpt = Nothing
  , hostConfigTmpfs = Nothing
  , hostConfigUtsMode = Nothing
  , hostConfigUsernsMode = Nothing
  , hostConfigShmSize = Nothing
  , hostConfigSysctls = Nothing
  , hostConfigRuntime = Nothing
  , hostConfigConsoleSize = Nothing
  , hostConfigIsolation = Nothing
  }

-- ** HostConfigAllOf
-- | HostConfigAllOf
data HostConfigAllOf = HostConfigAllOf
  { hostConfigAllOfBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest&#x60; to bind-mount a host path into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;host-src:container-dest:ro&#x60; to make the bind-mount read-only inside the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest&#x60; to bind-mount a volume managed by a volume driver into the container. &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest:ro&#x60; to mount the volume read-only inside the container.  &#x60;container-dest&#x60; must be an _absolute_ path. 
  , hostConfigAllOfContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigAllOfLogConfig :: !(Maybe HostConfigAllOfLogConfig) -- ^ "LogConfig"
  , hostConfigAllOfNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to.
  , hostConfigAllOfPortBindings :: !(Maybe (Map.Map String HostConfigAllOfPortBindings)) -- ^ "PortBindings" - A map of exposed container ports and the host port they should map to.
  , hostConfigAllOfRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAllOfAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set.
  , hostConfigAllOfVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigAllOfVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;.
  , hostConfigAllOfMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container.
  , hostConfigAllOfCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container.
  , hostConfigAllOfCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container.
  , hostConfigAllOfDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigAllOfDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigAllOfDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigAllOfExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigAllOfGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as.
  , hostConfigAllOfIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC namespace to use for the container.
  , hostConfigAllOfCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigAllOfLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;.
  , hostConfigAllOfOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences.
  , hostConfigAllOfPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigAllOfPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigAllOfPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates a random host port for all of a container&#39;s exposed ports.
  , hostConfigAllOfReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigAllOfSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux.
  , hostConfigAllOfStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigAllOfTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: &#x60;{ \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; }&#x60;. 
  , hostConfigAllOfUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigAllOfUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
  , hostConfigAllOfShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB.
  , hostConfigAllOfSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example: &#x60;{\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;}&#x60; 
  , hostConfigAllOfRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigAllOfConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only)
  , hostConfigAllOfIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOf
instance A.FromJSON HostConfigAllOf where
  parseJSON = A.withObject "HostConfigAllOf" $ \o ->
    HostConfigAllOf
      <$> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")

-- | ToJSON HostConfigAllOf
instance A.ToJSON HostConfigAllOf where
  toJSON HostConfigAllOf {..} =
   _omitNulls
      [ "Binds" .= hostConfigAllOfBinds
      , "ContainerIDFile" .= hostConfigAllOfContainerIdFile
      , "LogConfig" .= hostConfigAllOfLogConfig
      , "NetworkMode" .= hostConfigAllOfNetworkMode
      , "PortBindings" .= hostConfigAllOfPortBindings
      , "RestartPolicy" .= hostConfigAllOfRestartPolicy
      , "AutoRemove" .= hostConfigAllOfAutoRemove
      , "VolumeDriver" .= hostConfigAllOfVolumeDriver
      , "VolumesFrom" .= hostConfigAllOfVolumesFrom
      , "Mounts" .= hostConfigAllOfMounts
      , "CapAdd" .= hostConfigAllOfCapAdd
      , "CapDrop" .= hostConfigAllOfCapDrop
      , "Dns" .= hostConfigAllOfDns
      , "DnsOptions" .= hostConfigAllOfDnsOptions
      , "DnsSearch" .= hostConfigAllOfDnsSearch
      , "ExtraHosts" .= hostConfigAllOfExtraHosts
      , "GroupAdd" .= hostConfigAllOfGroupAdd
      , "IpcMode" .= hostConfigAllOfIpcMode
      , "Cgroup" .= hostConfigAllOfCgroup
      , "Links" .= hostConfigAllOfLinks
      , "OomScoreAdj" .= hostConfigAllOfOomScoreAdj
      , "PidMode" .= hostConfigAllOfPidMode
      , "Privileged" .= hostConfigAllOfPrivileged
      , "PublishAllPorts" .= hostConfigAllOfPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigAllOfReadonlyRootfs
      , "SecurityOpt" .= hostConfigAllOfSecurityOpt
      , "StorageOpt" .= hostConfigAllOfStorageOpt
      , "Tmpfs" .= hostConfigAllOfTmpfs
      , "UTSMode" .= hostConfigAllOfUtsMode
      , "UsernsMode" .= hostConfigAllOfUsernsMode
      , "ShmSize" .= hostConfigAllOfShmSize
      , "Sysctls" .= hostConfigAllOfSysctls
      , "Runtime" .= hostConfigAllOfRuntime
      , "ConsoleSize" .= hostConfigAllOfConsoleSize
      , "Isolation" .= hostConfigAllOfIsolation
      ]


-- | Construct a value of type 'HostConfigAllOf' (by applying it's required fields, if any)
mkHostConfigAllOf
  :: HostConfigAllOf
mkHostConfigAllOf =
  HostConfigAllOf
  { hostConfigAllOfBinds = Nothing
  , hostConfigAllOfContainerIdFile = Nothing
  , hostConfigAllOfLogConfig = Nothing
  , hostConfigAllOfNetworkMode = Nothing
  , hostConfigAllOfPortBindings = Nothing
  , hostConfigAllOfRestartPolicy = Nothing
  , hostConfigAllOfAutoRemove = Nothing
  , hostConfigAllOfVolumeDriver = Nothing
  , hostConfigAllOfVolumesFrom = Nothing
  , hostConfigAllOfMounts = Nothing
  , hostConfigAllOfCapAdd = Nothing
  , hostConfigAllOfCapDrop = Nothing
  , hostConfigAllOfDns = Nothing
  , hostConfigAllOfDnsOptions = Nothing
  , hostConfigAllOfDnsSearch = Nothing
  , hostConfigAllOfExtraHosts = Nothing
  , hostConfigAllOfGroupAdd = Nothing
  , hostConfigAllOfIpcMode = Nothing
  , hostConfigAllOfCgroup = Nothing
  , hostConfigAllOfLinks = Nothing
  , hostConfigAllOfOomScoreAdj = Nothing
  , hostConfigAllOfPidMode = Nothing
  , hostConfigAllOfPrivileged = Nothing
  , hostConfigAllOfPublishAllPorts = Nothing
  , hostConfigAllOfReadonlyRootfs = Nothing
  , hostConfigAllOfSecurityOpt = Nothing
  , hostConfigAllOfStorageOpt = Nothing
  , hostConfigAllOfTmpfs = Nothing
  , hostConfigAllOfUtsMode = Nothing
  , hostConfigAllOfUsernsMode = Nothing
  , hostConfigAllOfShmSize = Nothing
  , hostConfigAllOfSysctls = Nothing
  , hostConfigAllOfRuntime = Nothing
  , hostConfigAllOfConsoleSize = Nothing
  , hostConfigAllOfIsolation = Nothing
  }

-- ** HostConfigAllOfLogConfig
-- | HostConfigAllOfLogConfig
-- The logging configuration for this container
data HostConfigAllOfLogConfig = HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType :: !(Maybe E'Type3) -- ^ "Type"
  , hostConfigAllOfLogConfigConfig :: !(Maybe (Map.Map String Text)) -- ^ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOfLogConfig
instance A.FromJSON HostConfigAllOfLogConfig where
  parseJSON = A.withObject "HostConfigAllOfLogConfig" $ \o ->
    HostConfigAllOfLogConfig
      <$> (o .:? "Type")
      <*> (o .:? "Config")

-- | ToJSON HostConfigAllOfLogConfig
instance A.ToJSON HostConfigAllOfLogConfig where
  toJSON HostConfigAllOfLogConfig {..} =
   _omitNulls
      [ "Type" .= hostConfigAllOfLogConfigType
      , "Config" .= hostConfigAllOfLogConfigConfig
      ]


-- | Construct a value of type 'HostConfigAllOfLogConfig' (by applying it's required fields, if any)
mkHostConfigAllOfLogConfig
  :: HostConfigAllOfLogConfig
mkHostConfigAllOfLogConfig =
  HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType = Nothing
  , hostConfigAllOfLogConfigConfig = Nothing
  }

-- ** HostConfigAllOfPortBindings
-- | HostConfigAllOfPortBindings
data HostConfigAllOfPortBindings = HostConfigAllOfPortBindings
  { hostConfigAllOfPortBindingsHostIp :: !(Maybe Text) -- ^ "HostIp" - The host IP address
  , hostConfigAllOfPortBindingsHostPort :: !(Maybe Text) -- ^ "HostPort" - The host port number, as a string
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOfPortBindings
instance A.FromJSON HostConfigAllOfPortBindings where
  parseJSON = A.withObject "HostConfigAllOfPortBindings" $ \o ->
    HostConfigAllOfPortBindings
      <$> (o .:? "HostIp")
      <*> (o .:? "HostPort")

-- | ToJSON HostConfigAllOfPortBindings
instance A.ToJSON HostConfigAllOfPortBindings where
  toJSON HostConfigAllOfPortBindings {..} =
   _omitNulls
      [ "HostIp" .= hostConfigAllOfPortBindingsHostIp
      , "HostPort" .= hostConfigAllOfPortBindingsHostPort
      ]


-- | Construct a value of type 'HostConfigAllOfPortBindings' (by applying it's required fields, if any)
mkHostConfigAllOfPortBindings
  :: HostConfigAllOfPortBindings
mkHostConfigAllOfPortBindings =
  HostConfigAllOfPortBindings
  { hostConfigAllOfPortBindingsHostIp = Nothing
  , hostConfigAllOfPortBindingsHostPort = Nothing
  }

-- ** IPAM
-- | IPAM
data IPAM = IPAM
  { iPAMDriver :: !(Maybe Text) -- ^ "Driver" - Name of the IPAM driver to use.
  , iPAMConfig :: !(Maybe [(Map.Map String Text)]) -- ^ "Config" - List of IPAM configuration options, specified as a map: &#x60;{\&quot;Subnet\&quot;: &lt;CIDR&gt;, \&quot;IPRange\&quot;: &lt;CIDR&gt;, \&quot;Gateway\&quot;: &lt;IP address&gt;, \&quot;AuxAddress\&quot;: &lt;device_name:IP address&gt;}&#x60;
  , iPAMOptions :: !(Maybe [(Map.Map String Text)]) -- ^ "Options" - Driver-specific options, specified as a map.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IPAM
instance A.FromJSON IPAM where
  parseJSON = A.withObject "IPAM" $ \o ->
    IPAM
      <$> (o .:? "Driver")
      <*> (o .:? "Config")
      <*> (o .:? "Options")

-- | ToJSON IPAM
instance A.ToJSON IPAM where
  toJSON IPAM {..} =
   _omitNulls
      [ "Driver" .= iPAMDriver
      , "Config" .= iPAMConfig
      , "Options" .= iPAMOptions
      ]


-- | Construct a value of type 'IPAM' (by applying it's required fields, if any)
mkIPAM
  :: IPAM
mkIPAM =
  IPAM
  { iPAMDriver = Nothing
  , iPAMConfig = Nothing
  , iPAMOptions = Nothing
  }

-- ** IdResponse
-- | IdResponse
-- Response to an API call that returns just an Id
data IdResponse = IdResponse
  { idResponseId :: !(Text) -- ^ /Required/ "Id" - The id of the newly created object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdResponse
instance A.FromJSON IdResponse where
  parseJSON = A.withObject "IdResponse" $ \o ->
    IdResponse
      <$> (o .:  "Id")

-- | ToJSON IdResponse
instance A.ToJSON IdResponse where
  toJSON IdResponse {..} =
   _omitNulls
      [ "Id" .= idResponseId
      ]


-- | Construct a value of type 'IdResponse' (by applying it's required fields, if any)
mkIdResponse
  :: Text -- ^ 'idResponseId': The id of the newly created object.
  -> IdResponse
mkIdResponse idResponseId =
  IdResponse
  { idResponseId
  }

-- ** Image
-- | Image
data Image = Image
  { imageId :: !(Text) -- ^ /Required/ "Id"
  , imageRepoTags :: !(Maybe [Text]) -- ^ "RepoTags"
  , imageRepoDigests :: !(Maybe [Text]) -- ^ "RepoDigests"
  , imageParent :: !(Text) -- ^ /Required/ "Parent"
  , imageComment :: !(Text) -- ^ /Required/ "Comment"
  , imageCreated :: !(Text) -- ^ /Required/ "Created"
  , imageContainer :: !(Text) -- ^ /Required/ "Container"
  , imageContainerConfig :: !(Maybe ContainerConfig) -- ^ "ContainerConfig"
  , imageDockerVersion :: !(Text) -- ^ /Required/ "DockerVersion"
  , imageAuthor :: !(Text) -- ^ /Required/ "Author"
  , imageConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , imageArchitecture :: !(Text) -- ^ /Required/ "Architecture"
  , imageOs :: !(Text) -- ^ /Required/ "Os"
  , imageOsVersion :: !(Maybe Text) -- ^ "OsVersion"
  , imageSize :: !(Integer) -- ^ /Required/ "Size"
  , imageVirtualSize :: !(Integer) -- ^ /Required/ "VirtualSize"
  , imageGraphDriver :: !(GraphDriverData) -- ^ /Required/ "GraphDriver"
  , imageRootFs :: !(ImageRootFS) -- ^ /Required/ "RootFS"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Image
instance A.FromJSON Image where
  parseJSON = A.withObject "Image" $ \o ->
    Image
      <$> (o .:  "Id")
      <*> (o .:? "RepoTags")
      <*> (o .:? "RepoDigests")
      <*> (o .:  "Parent")
      <*> (o .:  "Comment")
      <*> (o .:  "Created")
      <*> (o .:  "Container")
      <*> (o .:? "ContainerConfig")
      <*> (o .:  "DockerVersion")
      <*> (o .:  "Author")
      <*> (o .:? "Config")
      <*> (o .:  "Architecture")
      <*> (o .:  "Os")
      <*> (o .:? "OsVersion")
      <*> (o .:  "Size")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "GraphDriver")
      <*> (o .:  "RootFS")

-- | ToJSON Image
instance A.ToJSON Image where
  toJSON Image {..} =
   _omitNulls
      [ "Id" .= imageId
      , "RepoTags" .= imageRepoTags
      , "RepoDigests" .= imageRepoDigests
      , "Parent" .= imageParent
      , "Comment" .= imageComment
      , "Created" .= imageCreated
      , "Container" .= imageContainer
      , "ContainerConfig" .= imageContainerConfig
      , "DockerVersion" .= imageDockerVersion
      , "Author" .= imageAuthor
      , "Config" .= imageConfig
      , "Architecture" .= imageArchitecture
      , "Os" .= imageOs
      , "OsVersion" .= imageOsVersion
      , "Size" .= imageSize
      , "VirtualSize" .= imageVirtualSize
      , "GraphDriver" .= imageGraphDriver
      , "RootFS" .= imageRootFs
      ]


-- | Construct a value of type 'Image' (by applying it's required fields, if any)
mkImage
  :: Text -- ^ 'imageId' 
  -> Text -- ^ 'imageParent' 
  -> Text -- ^ 'imageComment' 
  -> Text -- ^ 'imageCreated' 
  -> Text -- ^ 'imageContainer' 
  -> Text -- ^ 'imageDockerVersion' 
  -> Text -- ^ 'imageAuthor' 
  -> Text -- ^ 'imageArchitecture' 
  -> Text -- ^ 'imageOs' 
  -> Integer -- ^ 'imageSize' 
  -> Integer -- ^ 'imageVirtualSize' 
  -> GraphDriverData -- ^ 'imageGraphDriver' 
  -> ImageRootFS -- ^ 'imageRootFs' 
  -> Image
mkImage imageId imageParent imageComment imageCreated imageContainer imageDockerVersion imageAuthor imageArchitecture imageOs imageSize imageVirtualSize imageGraphDriver imageRootFs =
  Image
  { imageId
  , imageRepoTags = Nothing
  , imageRepoDigests = Nothing
  , imageParent
  , imageComment
  , imageCreated
  , imageContainer
  , imageContainerConfig = Nothing
  , imageDockerVersion
  , imageAuthor
  , imageConfig = Nothing
  , imageArchitecture
  , imageOs
  , imageOsVersion = Nothing
  , imageSize
  , imageVirtualSize
  , imageGraphDriver
  , imageRootFs
  }

-- ** ImageDeleteResponseItem
-- | ImageDeleteResponseItem
data ImageDeleteResponseItem = ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged :: !(Maybe Text) -- ^ "Untagged" - The image ID of an image that was untagged
  , imageDeleteResponseItemDeleted :: !(Maybe Text) -- ^ "Deleted" - The image ID of an image that was deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageDeleteResponseItem
instance A.FromJSON ImageDeleteResponseItem where
  parseJSON = A.withObject "ImageDeleteResponseItem" $ \o ->
    ImageDeleteResponseItem
      <$> (o .:? "Untagged")
      <*> (o .:? "Deleted")

-- | ToJSON ImageDeleteResponseItem
instance A.ToJSON ImageDeleteResponseItem where
  toJSON ImageDeleteResponseItem {..} =
   _omitNulls
      [ "Untagged" .= imageDeleteResponseItemUntagged
      , "Deleted" .= imageDeleteResponseItemDeleted
      ]


-- | Construct a value of type 'ImageDeleteResponseItem' (by applying it's required fields, if any)
mkImageDeleteResponseItem
  :: ImageDeleteResponseItem
mkImageDeleteResponseItem =
  ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged = Nothing
  , imageDeleteResponseItemDeleted = Nothing
  }

-- ** ImageRootFS
-- | ImageRootFS
data ImageRootFS = ImageRootFS
  { imageRootFSType :: !(Text) -- ^ /Required/ "Type"
  , imageRootFSLayers :: !(Maybe [Text]) -- ^ "Layers"
  , imageRootFSBaseLayer :: !(Maybe Text) -- ^ "BaseLayer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageRootFS
instance A.FromJSON ImageRootFS where
  parseJSON = A.withObject "ImageRootFS" $ \o ->
    ImageRootFS
      <$> (o .:  "Type")
      <*> (o .:? "Layers")
      <*> (o .:? "BaseLayer")

-- | ToJSON ImageRootFS
instance A.ToJSON ImageRootFS where
  toJSON ImageRootFS {..} =
   _omitNulls
      [ "Type" .= imageRootFSType
      , "Layers" .= imageRootFSLayers
      , "BaseLayer" .= imageRootFSBaseLayer
      ]


-- | Construct a value of type 'ImageRootFS' (by applying it's required fields, if any)
mkImageRootFS
  :: Text -- ^ 'imageRootFSType' 
  -> ImageRootFS
mkImageRootFS imageRootFSType =
  ImageRootFS
  { imageRootFSType
  , imageRootFSLayers = Nothing
  , imageRootFSBaseLayer = Nothing
  }

-- ** ImageSummary
-- | ImageSummary
data ImageSummary = ImageSummary
  { imageSummaryId :: !(Text) -- ^ /Required/ "Id"
  , imageSummaryParentId :: !(Text) -- ^ /Required/ "ParentId"
  , imageSummaryRepoTags :: !([Text]) -- ^ /Required/ "RepoTags"
  , imageSummaryRepoDigests :: !([Text]) -- ^ /Required/ "RepoDigests"
  , imageSummaryCreated :: !(Int) -- ^ /Required/ "Created"
  , imageSummarySize :: !(Int) -- ^ /Required/ "Size"
  , imageSummarySharedSize :: !(Int) -- ^ /Required/ "SharedSize"
  , imageSummaryVirtualSize :: !(Int) -- ^ /Required/ "VirtualSize"
  , imageSummaryLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels"
  , imageSummaryContainers :: !(Int) -- ^ /Required/ "Containers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSummary
instance A.FromJSON ImageSummary where
  parseJSON = A.withObject "ImageSummary" $ \o ->
    ImageSummary
      <$> (o .:  "Id")
      <*> (o .:  "ParentId")
      <*> (o .:  "RepoTags")
      <*> (o .:  "RepoDigests")
      <*> (o .:  "Created")
      <*> (o .:  "Size")
      <*> (o .:  "SharedSize")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "Labels")
      <*> (o .:  "Containers")

-- | ToJSON ImageSummary
instance A.ToJSON ImageSummary where
  toJSON ImageSummary {..} =
   _omitNulls
      [ "Id" .= imageSummaryId
      , "ParentId" .= imageSummaryParentId
      , "RepoTags" .= imageSummaryRepoTags
      , "RepoDigests" .= imageSummaryRepoDigests
      , "Created" .= imageSummaryCreated
      , "Size" .= imageSummarySize
      , "SharedSize" .= imageSummarySharedSize
      , "VirtualSize" .= imageSummaryVirtualSize
      , "Labels" .= imageSummaryLabels
      , "Containers" .= imageSummaryContainers
      ]


-- | Construct a value of type 'ImageSummary' (by applying it's required fields, if any)
mkImageSummary
  :: Text -- ^ 'imageSummaryId' 
  -> Text -- ^ 'imageSummaryParentId' 
  -> [Text] -- ^ 'imageSummaryRepoTags' 
  -> [Text] -- ^ 'imageSummaryRepoDigests' 
  -> Int -- ^ 'imageSummaryCreated' 
  -> Int -- ^ 'imageSummarySize' 
  -> Int -- ^ 'imageSummarySharedSize' 
  -> Int -- ^ 'imageSummaryVirtualSize' 
  -> (Map.Map String Text) -- ^ 'imageSummaryLabels' 
  -> Int -- ^ 'imageSummaryContainers' 
  -> ImageSummary
mkImageSummary imageSummaryId imageSummaryParentId imageSummaryRepoTags imageSummaryRepoDigests imageSummaryCreated imageSummarySize imageSummarySharedSize imageSummaryVirtualSize imageSummaryLabels imageSummaryContainers =
  ImageSummary
  { imageSummaryId
  , imageSummaryParentId
  , imageSummaryRepoTags
  , imageSummaryRepoDigests
  , imageSummaryCreated
  , imageSummarySize
  , imageSummarySharedSize
  , imageSummaryVirtualSize
  , imageSummaryLabels
  , imageSummaryContainers
  }

-- ** InlineObject
-- | InlineObject
-- Describes a permission accepted by the user upon installing the plugin.
data InlineObject = InlineObject
  { inlineObjectName :: !(Maybe Text) -- ^ "Name"
  , inlineObjectDescription :: !(Maybe Text) -- ^ "Description"
  , inlineObjectValue :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "Name" .= inlineObjectName
      , "Description" .= inlineObjectDescription
      , "Value" .= inlineObjectValue
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: InlineObject
mkInlineObject =
  InlineObject
  { inlineObjectName = Nothing
  , inlineObjectDescription = Nothing
  , inlineObjectValue = Nothing
  }

-- ** InlineObject1
-- | InlineObject1
data InlineObject1 = InlineObject1
  { inlineObject1Detach :: !(Maybe Bool) -- ^ "Detach" - Detach from the command.
  , inlineObject1Tty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:? "Detach")
      <*> (o .:? "Tty")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "Detach" .= inlineObject1Detach
      , "Tty" .= inlineObject1Tty
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: InlineObject1
mkInlineObject1 =
  InlineObject1
  { inlineObject1Detach = Nothing
  , inlineObject1Tty = Nothing
  }

-- ** InlineObject2
-- | InlineObject2
data InlineObject2 = InlineObject2
  { inlineObject2Name :: !(Maybe Text) -- ^ "Name" - The new volume&#39;s name. If not specified, Docker generates a name.
  , inlineObject2Driver :: !(Maybe Text) -- ^ "Driver" - Name of the volume driver to use.
  , inlineObject2DriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
  , inlineObject2Labels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:? "Name")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverOpts")
      <*> (o .:? "Labels")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
   _omitNulls
      [ "Name" .= inlineObject2Name
      , "Driver" .= inlineObject2Driver
      , "DriverOpts" .= inlineObject2DriverOpts
      , "Labels" .= inlineObject2Labels
      ]


-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2
  :: InlineObject2
mkInlineObject2 =
  InlineObject2
  { inlineObject2Name = Nothing
  , inlineObject2Driver = Nothing
  , inlineObject2DriverOpts = Nothing
  , inlineObject2Labels = Nothing
  }

-- ** InlineObject3
-- | InlineObject3
data InlineObject3 = InlineObject3
  { inlineObject3Name :: !(Text) -- ^ /Required/ "Name" - The network&#39;s name.
  , inlineObject3CheckDuplicate :: !(Maybe Bool) -- ^ "CheckDuplicate" - Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions.
  , inlineObject3Driver :: !(Maybe Text) -- ^ "Driver" - Name of the network driver plugin to use.
  , inlineObject3Internal :: !(Maybe Bool) -- ^ "Internal" - Restrict external access to the network.
  , inlineObject3Attachable :: !(Maybe Bool) -- ^ "Attachable" - Globally scoped network is manually attachable by regular containers from workers in swarm mode.
  , inlineObject3Ingress :: !(Maybe Bool) -- ^ "Ingress" - Ingress network is the network which provides the routing-mesh in swarm mode.
  , inlineObject3Ipam :: !(Maybe IPAM) -- ^ "IPAM"
  , inlineObject3EnableIPv6 :: !(Maybe Bool) -- ^ "EnableIPv6" - Enable IPv6 on the network.
  , inlineObject3Options :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Network specific options to be used by the drivers.
  , inlineObject3Labels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:  "Name")
      <*> (o .:? "CheckDuplicate")
      <*> (o .:? "Driver")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "IPAM")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
   _omitNulls
      [ "Name" .= inlineObject3Name
      , "CheckDuplicate" .= inlineObject3CheckDuplicate
      , "Driver" .= inlineObject3Driver
      , "Internal" .= inlineObject3Internal
      , "Attachable" .= inlineObject3Attachable
      , "Ingress" .= inlineObject3Ingress
      , "IPAM" .= inlineObject3Ipam
      , "EnableIPv6" .= inlineObject3EnableIPv6
      , "Options" .= inlineObject3Options
      , "Labels" .= inlineObject3Labels
      ]


-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3
  :: Text -- ^ 'inlineObject3Name': The network's name.
  -> InlineObject3
mkInlineObject3 inlineObject3Name =
  InlineObject3
  { inlineObject3Name
  , inlineObject3CheckDuplicate = Nothing
  , inlineObject3Driver = Nothing
  , inlineObject3Internal = Nothing
  , inlineObject3Attachable = Nothing
  , inlineObject3Ingress = Nothing
  , inlineObject3Ipam = Nothing
  , inlineObject3EnableIPv6 = Nothing
  , inlineObject3Options = Nothing
  , inlineObject3Labels = Nothing
  }

-- ** InlineObject4
-- | InlineObject4
data InlineObject4 = InlineObject4
  { inlineObject4Container :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to connect to the network.
  , inlineObject4EndpointConfig :: !(Maybe EndpointSettings) -- ^ "EndpointConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:? "Container")
      <*> (o .:? "EndpointConfig")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
   _omitNulls
      [ "Container" .= inlineObject4Container
      , "EndpointConfig" .= inlineObject4EndpointConfig
      ]


-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4
  :: InlineObject4
mkInlineObject4 =
  InlineObject4
  { inlineObject4Container = Nothing
  , inlineObject4EndpointConfig = Nothing
  }

-- ** InlineObject5
-- | InlineObject5
data InlineObject5 = InlineObject5
  { inlineObject5Container :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to disconnect from the network.
  , inlineObject5Force :: !(Maybe Bool) -- ^ "Force" - Force the container to disconnect from the network.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject5
instance A.FromJSON InlineObject5 where
  parseJSON = A.withObject "InlineObject5" $ \o ->
    InlineObject5
      <$> (o .:? "Container")
      <*> (o .:? "Force")

-- | ToJSON InlineObject5
instance A.ToJSON InlineObject5 where
  toJSON InlineObject5 {..} =
   _omitNulls
      [ "Container" .= inlineObject5Container
      , "Force" .= inlineObject5Force
      ]


-- | Construct a value of type 'InlineObject5' (by applying it's required fields, if any)
mkInlineObject5
  :: InlineObject5
mkInlineObject5 =
  InlineObject5
  { inlineObject5Container = Nothing
  , inlineObject5Force = Nothing
  }

-- ** InlineObject6
-- | InlineObject6
data InlineObject6 = InlineObject6
  { inlineObject6ListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the default swarm listening port is used.
  , inlineObject6AdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , inlineObject6DataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same address as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , inlineObject6ForceNewCluster :: !(Maybe Bool) -- ^ "ForceNewCluster" - Force creation of a new swarm.
  , inlineObject6Spec :: !(Maybe SwarmSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject6
instance A.FromJSON InlineObject6 where
  parseJSON = A.withObject "InlineObject6" $ \o ->
    InlineObject6
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "ForceNewCluster")
      <*> (o .:? "Spec")

-- | ToJSON InlineObject6
instance A.ToJSON InlineObject6 where
  toJSON InlineObject6 {..} =
   _omitNulls
      [ "ListenAddr" .= inlineObject6ListenAddr
      , "AdvertiseAddr" .= inlineObject6AdvertiseAddr
      , "DataPathAddr" .= inlineObject6DataPathAddr
      , "ForceNewCluster" .= inlineObject6ForceNewCluster
      , "Spec" .= inlineObject6Spec
      ]


-- | Construct a value of type 'InlineObject6' (by applying it's required fields, if any)
mkInlineObject6
  :: InlineObject6
mkInlineObject6 =
  InlineObject6
  { inlineObject6ListenAddr = Nothing
  , inlineObject6AdvertiseAddr = Nothing
  , inlineObject6DataPathAddr = Nothing
  , inlineObject6ForceNewCluster = Nothing
  , inlineObject6Spec = Nothing
  }

-- ** InlineObject7
-- | InlineObject7
data InlineObject7 = InlineObject7
  { inlineObject7ListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
  , inlineObject7AdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , inlineObject7DataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same address as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , inlineObject7RemoteAddrs :: !(Maybe Text) -- ^ "RemoteAddrs" - Addresses of manager nodes already participating in the swarm.
  , inlineObject7JoinToken :: !(Maybe Text) -- ^ "JoinToken" - Secret token for joining this swarm.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject7
instance A.FromJSON InlineObject7 where
  parseJSON = A.withObject "InlineObject7" $ \o ->
    InlineObject7
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "RemoteAddrs")
      <*> (o .:? "JoinToken")

-- | ToJSON InlineObject7
instance A.ToJSON InlineObject7 where
  toJSON InlineObject7 {..} =
   _omitNulls
      [ "ListenAddr" .= inlineObject7ListenAddr
      , "AdvertiseAddr" .= inlineObject7AdvertiseAddr
      , "DataPathAddr" .= inlineObject7DataPathAddr
      , "RemoteAddrs" .= inlineObject7RemoteAddrs
      , "JoinToken" .= inlineObject7JoinToken
      ]


-- | Construct a value of type 'InlineObject7' (by applying it's required fields, if any)
mkInlineObject7
  :: InlineObject7
mkInlineObject7 =
  InlineObject7
  { inlineObject7ListenAddr = Nothing
  , inlineObject7AdvertiseAddr = Nothing
  , inlineObject7DataPathAddr = Nothing
  , inlineObject7RemoteAddrs = Nothing
  , inlineObject7JoinToken = Nothing
  }

-- ** InlineObject8
-- | InlineObject8
data InlineObject8 = InlineObject8
  { inlineObject8UnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject8
instance A.FromJSON InlineObject8 where
  parseJSON = A.withObject "InlineObject8" $ \o ->
    InlineObject8
      <$> (o .:? "UnlockKey")

-- | ToJSON InlineObject8
instance A.ToJSON InlineObject8 where
  toJSON InlineObject8 {..} =
   _omitNulls
      [ "UnlockKey" .= inlineObject8UnlockKey
      ]


-- | Construct a value of type 'InlineObject8' (by applying it's required fields, if any)
mkInlineObject8
  :: InlineObject8
mkInlineObject8 =
  InlineObject8
  { inlineObject8UnlockKey = Nothing
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Titles :: !(Maybe [Text]) -- ^ "Titles" - The ps column titles
  , inlineResponse200Processes :: !(Maybe [[Text]]) -- ^ "Processes" - Each process running in the container, where each is process is an array of values corresponding to the titles
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "Titles")
      <*> (o .:? "Processes")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "Titles" .= inlineResponse200Titles
      , "Processes" .= inlineResponse200Processes
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200Titles = Nothing
  , inlineResponse200Processes = Nothing
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Path :: !(Text) -- ^ /Required/ "Path" - Path to file that has changed
  , inlineResponse2001Kind :: !(Int) -- ^ /Required/ "Kind" - Kind of change
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:  "Path")
      <*> (o .:  "Kind")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "Path" .= inlineResponse2001Path
      , "Kind" .= inlineResponse2001Kind
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: Text -- ^ 'inlineResponse2001Path': Path to file that has changed
  -> Int -- ^ 'inlineResponse2001Kind': Kind of change
  -> InlineResponse2001
mkInlineResponse2001 inlineResponse2001Path inlineResponse2001Kind =
  InlineResponse2001
  { inlineResponse2001Path
  , inlineResponse2001Kind
  }

-- ** InlineResponse20010
-- | InlineResponse20010
data InlineResponse20010 = InlineResponse20010
  { inlineResponse20010Version :: !(Maybe Text) -- ^ "Version"
  , inlineResponse20010ApiVersion :: !(Maybe Text) -- ^ "ApiVersion"
  , inlineResponse20010MinApiVersion :: !(Maybe Text) -- ^ "MinAPIVersion"
  , inlineResponse20010GitCommit :: !(Maybe Text) -- ^ "GitCommit"
  , inlineResponse20010GoVersion :: !(Maybe Text) -- ^ "GoVersion"
  , inlineResponse20010Os :: !(Maybe Text) -- ^ "Os"
  , inlineResponse20010Arch :: !(Maybe Text) -- ^ "Arch"
  , inlineResponse20010KernelVersion :: !(Maybe Text) -- ^ "KernelVersion"
  , inlineResponse20010Experimental :: !(Maybe Bool) -- ^ "Experimental"
  , inlineResponse20010BuildTime :: !(Maybe Text) -- ^ "BuildTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010
instance A.FromJSON InlineResponse20010 where
  parseJSON = A.withObject "InlineResponse20010" $ \o ->
    InlineResponse20010
      <$> (o .:? "Version")
      <*> (o .:? "ApiVersion")
      <*> (o .:? "MinAPIVersion")
      <*> (o .:? "GitCommit")
      <*> (o .:? "GoVersion")
      <*> (o .:? "Os")
      <*> (o .:? "Arch")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Experimental")
      <*> (o .:? "BuildTime")

-- | ToJSON InlineResponse20010
instance A.ToJSON InlineResponse20010 where
  toJSON InlineResponse20010 {..} =
   _omitNulls
      [ "Version" .= inlineResponse20010Version
      , "ApiVersion" .= inlineResponse20010ApiVersion
      , "MinAPIVersion" .= inlineResponse20010MinApiVersion
      , "GitCommit" .= inlineResponse20010GitCommit
      , "GoVersion" .= inlineResponse20010GoVersion
      , "Os" .= inlineResponse20010Os
      , "Arch" .= inlineResponse20010Arch
      , "KernelVersion" .= inlineResponse20010KernelVersion
      , "Experimental" .= inlineResponse20010Experimental
      , "BuildTime" .= inlineResponse20010BuildTime
      ]


-- | Construct a value of type 'InlineResponse20010' (by applying it's required fields, if any)
mkInlineResponse20010
  :: InlineResponse20010
mkInlineResponse20010 =
  InlineResponse20010
  { inlineResponse20010Version = Nothing
  , inlineResponse20010ApiVersion = Nothing
  , inlineResponse20010MinApiVersion = Nothing
  , inlineResponse20010GitCommit = Nothing
  , inlineResponse20010GoVersion = Nothing
  , inlineResponse20010Os = Nothing
  , inlineResponse20010Arch = Nothing
  , inlineResponse20010KernelVersion = Nothing
  , inlineResponse20010Experimental = Nothing
  , inlineResponse20010BuildTime = Nothing
  }

-- ** InlineResponse20011
-- | InlineResponse20011
data InlineResponse20011 = InlineResponse20011
  { inlineResponse20011Type :: !(Maybe Text) -- ^ "Type" - The type of object emitting the event
  , inlineResponse20011Action :: !(Maybe Text) -- ^ "Action" - The type of event
  , inlineResponse20011Actor :: !(Maybe InlineResponse20011Actor) -- ^ "Actor"
  , inlineResponse20011Time :: !(Maybe Int) -- ^ "time" - Timestamp of event
  , inlineResponse20011TimeNano :: !(Maybe Integer) -- ^ "timeNano" - Timestamp of event, with nanosecond accuracy
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011
instance A.FromJSON InlineResponse20011 where
  parseJSON = A.withObject "InlineResponse20011" $ \o ->
    InlineResponse20011
      <$> (o .:? "Type")
      <*> (o .:? "Action")
      <*> (o .:? "Actor")
      <*> (o .:? "time")
      <*> (o .:? "timeNano")

-- | ToJSON InlineResponse20011
instance A.ToJSON InlineResponse20011 where
  toJSON InlineResponse20011 {..} =
   _omitNulls
      [ "Type" .= inlineResponse20011Type
      , "Action" .= inlineResponse20011Action
      , "Actor" .= inlineResponse20011Actor
      , "time" .= inlineResponse20011Time
      , "timeNano" .= inlineResponse20011TimeNano
      ]


-- | Construct a value of type 'InlineResponse20011' (by applying it's required fields, if any)
mkInlineResponse20011
  :: InlineResponse20011
mkInlineResponse20011 =
  InlineResponse20011
  { inlineResponse20011Type = Nothing
  , inlineResponse20011Action = Nothing
  , inlineResponse20011Actor = Nothing
  , inlineResponse20011Time = Nothing
  , inlineResponse20011TimeNano = Nothing
  }

-- ** InlineResponse20011Actor
-- | InlineResponse20011Actor
data InlineResponse20011Actor = InlineResponse20011Actor
  { inlineResponse20011ActorId :: !(Maybe Text) -- ^ "ID" - The ID of the object emitting the event
  , inlineResponse20011ActorAttributes :: !(Maybe (Map.Map String Text)) -- ^ "Attributes" - Various key/value attributes of the object, depending on its type
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011Actor
instance A.FromJSON InlineResponse20011Actor where
  parseJSON = A.withObject "InlineResponse20011Actor" $ \o ->
    InlineResponse20011Actor
      <$> (o .:? "ID")
      <*> (o .:? "Attributes")

-- | ToJSON InlineResponse20011Actor
instance A.ToJSON InlineResponse20011Actor where
  toJSON InlineResponse20011Actor {..} =
   _omitNulls
      [ "ID" .= inlineResponse20011ActorId
      , "Attributes" .= inlineResponse20011ActorAttributes
      ]


-- | Construct a value of type 'InlineResponse20011Actor' (by applying it's required fields, if any)
mkInlineResponse20011Actor
  :: InlineResponse20011Actor
mkInlineResponse20011Actor =
  InlineResponse20011Actor
  { inlineResponse20011ActorId = Nothing
  , inlineResponse20011ActorAttributes = Nothing
  }

-- ** InlineResponse20012
-- | InlineResponse20012
data InlineResponse20012 = InlineResponse20012
  { inlineResponse20012LayersSize :: !(Maybe Integer) -- ^ "LayersSize"
  , inlineResponse20012Images :: !(Maybe [ImageSummary]) -- ^ "Images"
  , inlineResponse20012Containers :: !(Maybe [ContainerSummary]) -- ^ "Containers"
  , inlineResponse20012Volumes :: !(Maybe [Volume]) -- ^ "Volumes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012
instance A.FromJSON InlineResponse20012 where
  parseJSON = A.withObject "InlineResponse20012" $ \o ->
    InlineResponse20012
      <$> (o .:? "LayersSize")
      <*> (o .:? "Images")
      <*> (o .:? "Containers")
      <*> (o .:? "Volumes")

-- | ToJSON InlineResponse20012
instance A.ToJSON InlineResponse20012 where
  toJSON InlineResponse20012 {..} =
   _omitNulls
      [ "LayersSize" .= inlineResponse20012LayersSize
      , "Images" .= inlineResponse20012Images
      , "Containers" .= inlineResponse20012Containers
      , "Volumes" .= inlineResponse20012Volumes
      ]


-- | Construct a value of type 'InlineResponse20012' (by applying it's required fields, if any)
mkInlineResponse20012
  :: InlineResponse20012
mkInlineResponse20012 =
  InlineResponse20012
  { inlineResponse20012LayersSize = Nothing
  , inlineResponse20012Images = Nothing
  , inlineResponse20012Containers = Nothing
  , inlineResponse20012Volumes = Nothing
  }

-- ** InlineResponse20013
-- | InlineResponse20013
data InlineResponse20013 = InlineResponse20013
  { inlineResponse20013Id :: !(Maybe Text) -- ^ "ID"
  , inlineResponse20013Running :: !(Maybe Bool) -- ^ "Running"
  , inlineResponse20013ExitCode :: !(Maybe Int) -- ^ "ExitCode"
  , inlineResponse20013ProcessConfig :: !(Maybe ProcessConfig) -- ^ "ProcessConfig"
  , inlineResponse20013OpenStdin :: !(Maybe Bool) -- ^ "OpenStdin"
  , inlineResponse20013OpenStderr :: !(Maybe Bool) -- ^ "OpenStderr"
  , inlineResponse20013OpenStdout :: !(Maybe Bool) -- ^ "OpenStdout"
  , inlineResponse20013ContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , inlineResponse20013Pid :: !(Maybe Int) -- ^ "Pid" - The system process ID for the exec process.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013
instance A.FromJSON InlineResponse20013 where
  parseJSON = A.withObject "InlineResponse20013" $ \o ->
    InlineResponse20013
      <$> (o .:? "ID")
      <*> (o .:? "Running")
      <*> (o .:? "ExitCode")
      <*> (o .:? "ProcessConfig")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "OpenStderr")
      <*> (o .:? "OpenStdout")
      <*> (o .:? "ContainerID")
      <*> (o .:? "Pid")

-- | ToJSON InlineResponse20013
instance A.ToJSON InlineResponse20013 where
  toJSON InlineResponse20013 {..} =
   _omitNulls
      [ "ID" .= inlineResponse20013Id
      , "Running" .= inlineResponse20013Running
      , "ExitCode" .= inlineResponse20013ExitCode
      , "ProcessConfig" .= inlineResponse20013ProcessConfig
      , "OpenStdin" .= inlineResponse20013OpenStdin
      , "OpenStderr" .= inlineResponse20013OpenStderr
      , "OpenStdout" .= inlineResponse20013OpenStdout
      , "ContainerID" .= inlineResponse20013ContainerId
      , "Pid" .= inlineResponse20013Pid
      ]


-- | Construct a value of type 'InlineResponse20013' (by applying it's required fields, if any)
mkInlineResponse20013
  :: InlineResponse20013
mkInlineResponse20013 =
  InlineResponse20013
  { inlineResponse20013Id = Nothing
  , inlineResponse20013Running = Nothing
  , inlineResponse20013ExitCode = Nothing
  , inlineResponse20013ProcessConfig = Nothing
  , inlineResponse20013OpenStdin = Nothing
  , inlineResponse20013OpenStderr = Nothing
  , inlineResponse20013OpenStdout = Nothing
  , inlineResponse20013ContainerId = Nothing
  , inlineResponse20013Pid = Nothing
  }

-- ** InlineResponse20014
-- | InlineResponse20014
data InlineResponse20014 = InlineResponse20014
  { inlineResponse20014Volumes :: !([Volume]) -- ^ /Required/ "Volumes" - List of volumes
  , inlineResponse20014Warnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings that occurred when fetching the list of volumes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014
instance A.FromJSON InlineResponse20014 where
  parseJSON = A.withObject "InlineResponse20014" $ \o ->
    InlineResponse20014
      <$> (o .:  "Volumes")
      <*> (o .:  "Warnings")

-- | ToJSON InlineResponse20014
instance A.ToJSON InlineResponse20014 where
  toJSON InlineResponse20014 {..} =
   _omitNulls
      [ "Volumes" .= inlineResponse20014Volumes
      , "Warnings" .= inlineResponse20014Warnings
      ]


-- | Construct a value of type 'InlineResponse20014' (by applying it's required fields, if any)
mkInlineResponse20014
  :: [Volume] -- ^ 'inlineResponse20014Volumes': List of volumes
  -> [Text] -- ^ 'inlineResponse20014Warnings': Warnings that occurred when fetching the list of volumes
  -> InlineResponse20014
mkInlineResponse20014 inlineResponse20014Volumes inlineResponse20014Warnings =
  InlineResponse20014
  { inlineResponse20014Volumes
  , inlineResponse20014Warnings
  }

-- ** InlineResponse20015
-- | InlineResponse20015
data InlineResponse20015 = InlineResponse20015
  { inlineResponse20015VolumesDeleted :: !(Maybe [Text]) -- ^ "VolumesDeleted" - Volumes that were deleted
  , inlineResponse20015SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015
instance A.FromJSON InlineResponse20015 where
  parseJSON = A.withObject "InlineResponse20015" $ \o ->
    InlineResponse20015
      <$> (o .:? "VolumesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse20015
instance A.ToJSON InlineResponse20015 where
  toJSON InlineResponse20015 {..} =
   _omitNulls
      [ "VolumesDeleted" .= inlineResponse20015VolumesDeleted
      , "SpaceReclaimed" .= inlineResponse20015SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse20015' (by applying it's required fields, if any)
mkInlineResponse20015
  :: InlineResponse20015
mkInlineResponse20015 =
  InlineResponse20015
  { inlineResponse20015VolumesDeleted = Nothing
  , inlineResponse20015SpaceReclaimed = Nothing
  }

-- ** InlineResponse20016
-- | InlineResponse20016
data InlineResponse20016 = InlineResponse20016
  { inlineResponse20016NetworksDeleted :: !(Maybe [Text]) -- ^ "NetworksDeleted" - Networks that were deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20016
instance A.FromJSON InlineResponse20016 where
  parseJSON = A.withObject "InlineResponse20016" $ \o ->
    InlineResponse20016
      <$> (o .:? "NetworksDeleted")

-- | ToJSON InlineResponse20016
instance A.ToJSON InlineResponse20016 where
  toJSON InlineResponse20016 {..} =
   _omitNulls
      [ "NetworksDeleted" .= inlineResponse20016NetworksDeleted
      ]


-- | Construct a value of type 'InlineResponse20016' (by applying it's required fields, if any)
mkInlineResponse20016
  :: InlineResponse20016
mkInlineResponse20016 =
  InlineResponse20016
  { inlineResponse20016NetworksDeleted = Nothing
  }

-- ** InlineResponse20017
-- | InlineResponse20017
-- Describes a permission the user has to accept upon installing the plugin.
data InlineResponse20017 = InlineResponse20017
  { inlineResponse20017Name :: !(Maybe Text) -- ^ "Name"
  , inlineResponse20017Description :: !(Maybe Text) -- ^ "Description"
  , inlineResponse20017Value :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20017
instance A.FromJSON InlineResponse20017 where
  parseJSON = A.withObject "InlineResponse20017" $ \o ->
    InlineResponse20017
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON InlineResponse20017
instance A.ToJSON InlineResponse20017 where
  toJSON InlineResponse20017 {..} =
   _omitNulls
      [ "Name" .= inlineResponse20017Name
      , "Description" .= inlineResponse20017Description
      , "Value" .= inlineResponse20017Value
      ]


-- | Construct a value of type 'InlineResponse20017' (by applying it's required fields, if any)
mkInlineResponse20017
  :: InlineResponse20017
mkInlineResponse20017 =
  InlineResponse20017
  { inlineResponse20017Name = Nothing
  , inlineResponse20017Description = Nothing
  , inlineResponse20017Value = Nothing
  }

-- ** InlineResponse20018
-- | InlineResponse20018
data InlineResponse20018 = InlineResponse20018
  { inlineResponse20018ClusterInfo :: !(Maybe ClusterInfo) -- ^ "ClusterInfo"
  , inlineResponse20018JoinTokens :: !(Maybe InlineResponse20018JoinTokens) -- ^ "JoinTokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018
instance A.FromJSON InlineResponse20018 where
  parseJSON = A.withObject "InlineResponse20018" $ \o ->
    InlineResponse20018
      <$> (o .:? "ClusterInfo")
      <*> (o .:? "JoinTokens")

-- | ToJSON InlineResponse20018
instance A.ToJSON InlineResponse20018 where
  toJSON InlineResponse20018 {..} =
   _omitNulls
      [ "ClusterInfo" .= inlineResponse20018ClusterInfo
      , "JoinTokens" .= inlineResponse20018JoinTokens
      ]


-- | Construct a value of type 'InlineResponse20018' (by applying it's required fields, if any)
mkInlineResponse20018
  :: InlineResponse20018
mkInlineResponse20018 =
  InlineResponse20018
  { inlineResponse20018ClusterInfo = Nothing
  , inlineResponse20018JoinTokens = Nothing
  }

-- ** InlineResponse20018JoinTokens
-- | InlineResponse20018JoinTokens
-- The tokens workers and managers need to join the swarm.
data InlineResponse20018JoinTokens = InlineResponse20018JoinTokens
  { inlineResponse20018JoinTokensWorker :: !(Maybe Text) -- ^ "Worker" - The token workers can use to join the swarm.
  , inlineResponse20018JoinTokensManager :: !(Maybe Text) -- ^ "Manager" - The token managers can use to join the swarm.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018JoinTokens
instance A.FromJSON InlineResponse20018JoinTokens where
  parseJSON = A.withObject "InlineResponse20018JoinTokens" $ \o ->
    InlineResponse20018JoinTokens
      <$> (o .:? "Worker")
      <*> (o .:? "Manager")

-- | ToJSON InlineResponse20018JoinTokens
instance A.ToJSON InlineResponse20018JoinTokens where
  toJSON InlineResponse20018JoinTokens {..} =
   _omitNulls
      [ "Worker" .= inlineResponse20018JoinTokensWorker
      , "Manager" .= inlineResponse20018JoinTokensManager
      ]


-- | Construct a value of type 'InlineResponse20018JoinTokens' (by applying it's required fields, if any)
mkInlineResponse20018JoinTokens
  :: InlineResponse20018JoinTokens
mkInlineResponse20018JoinTokens =
  InlineResponse20018JoinTokens
  { inlineResponse20018JoinTokensWorker = Nothing
  , inlineResponse20018JoinTokensManager = Nothing
  }

-- ** InlineResponse20019
-- | InlineResponse20019
data InlineResponse20019 = InlineResponse20019
  { inlineResponse20019UnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019
instance A.FromJSON InlineResponse20019 where
  parseJSON = A.withObject "InlineResponse20019" $ \o ->
    InlineResponse20019
      <$> (o .:? "UnlockKey")

-- | ToJSON InlineResponse20019
instance A.ToJSON InlineResponse20019 where
  toJSON InlineResponse20019 {..} =
   _omitNulls
      [ "UnlockKey" .= inlineResponse20019UnlockKey
      ]


-- | Construct a value of type 'InlineResponse20019' (by applying it's required fields, if any)
mkInlineResponse20019
  :: InlineResponse20019
mkInlineResponse20019 =
  InlineResponse20019
  { inlineResponse20019UnlockKey = Nothing
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Warnings :: !(Maybe [Text]) -- ^ "Warnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "Warnings")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "Warnings" .= inlineResponse2002Warnings
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
  { inlineResponse2002Warnings = Nothing
  }

-- ** InlineResponse20020
-- | InlineResponse20020
data InlineResponse20020 = InlineResponse20020
  { inlineResponse20020Descriptor :: !(InlineResponse20020Descriptor) -- ^ /Required/ "Descriptor"
  , inlineResponse20020Platforms :: !([InlineResponse20020Platforms]) -- ^ /Required/ "Platforms" - An array containing all platforms supported by the image
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020
instance A.FromJSON InlineResponse20020 where
  parseJSON = A.withObject "InlineResponse20020" $ \o ->
    InlineResponse20020
      <$> (o .:  "Descriptor")
      <*> (o .:  "Platforms")

-- | ToJSON InlineResponse20020
instance A.ToJSON InlineResponse20020 where
  toJSON InlineResponse20020 {..} =
   _omitNulls
      [ "Descriptor" .= inlineResponse20020Descriptor
      , "Platforms" .= inlineResponse20020Platforms
      ]


-- | Construct a value of type 'InlineResponse20020' (by applying it's required fields, if any)
mkInlineResponse20020
  :: InlineResponse20020Descriptor -- ^ 'inlineResponse20020Descriptor' 
  -> [InlineResponse20020Platforms] -- ^ 'inlineResponse20020Platforms': An array containing all platforms supported by the image
  -> InlineResponse20020
mkInlineResponse20020 inlineResponse20020Descriptor inlineResponse20020Platforms =
  InlineResponse20020
  { inlineResponse20020Descriptor
  , inlineResponse20020Platforms
  }

-- ** InlineResponse20020Descriptor
-- | InlineResponse20020Descriptor
-- A descriptor struct containing digest, media type, and size
data InlineResponse20020Descriptor = InlineResponse20020Descriptor
  { inlineResponse20020DescriptorMediaType :: !(Maybe Text) -- ^ "MediaType"
  , inlineResponse20020DescriptorSize :: !(Maybe Integer) -- ^ "Size"
  , inlineResponse20020DescriptorDigest :: !(Maybe Text) -- ^ "Digest"
  , inlineResponse20020DescriptorUrLs :: !(Maybe [Text]) -- ^ "URLs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020Descriptor
instance A.FromJSON InlineResponse20020Descriptor where
  parseJSON = A.withObject "InlineResponse20020Descriptor" $ \o ->
    InlineResponse20020Descriptor
      <$> (o .:? "MediaType")
      <*> (o .:? "Size")
      <*> (o .:? "Digest")
      <*> (o .:? "URLs")

-- | ToJSON InlineResponse20020Descriptor
instance A.ToJSON InlineResponse20020Descriptor where
  toJSON InlineResponse20020Descriptor {..} =
   _omitNulls
      [ "MediaType" .= inlineResponse20020DescriptorMediaType
      , "Size" .= inlineResponse20020DescriptorSize
      , "Digest" .= inlineResponse20020DescriptorDigest
      , "URLs" .= inlineResponse20020DescriptorUrLs
      ]


-- | Construct a value of type 'InlineResponse20020Descriptor' (by applying it's required fields, if any)
mkInlineResponse20020Descriptor
  :: InlineResponse20020Descriptor
mkInlineResponse20020Descriptor =
  InlineResponse20020Descriptor
  { inlineResponse20020DescriptorMediaType = Nothing
  , inlineResponse20020DescriptorSize = Nothing
  , inlineResponse20020DescriptorDigest = Nothing
  , inlineResponse20020DescriptorUrLs = Nothing
  }

-- ** InlineResponse20020Platforms
-- | InlineResponse20020Platforms
data InlineResponse20020Platforms = InlineResponse20020Platforms
  { inlineResponse20020PlatformsArchitecture :: !(Maybe Text) -- ^ "Architecture"
  , inlineResponse20020PlatformsOs :: !(Maybe Text) -- ^ "OS"
  , inlineResponse20020PlatformsOsVersion :: !(Maybe Text) -- ^ "OSVersion"
  , inlineResponse20020PlatformsOsFeatures :: !(Maybe [Text]) -- ^ "OSFeatures"
  , inlineResponse20020PlatformsVariant :: !(Maybe Text) -- ^ "Variant"
  , inlineResponse20020PlatformsFeatures :: !(Maybe [Text]) -- ^ "Features"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020Platforms
instance A.FromJSON InlineResponse20020Platforms where
  parseJSON = A.withObject "InlineResponse20020Platforms" $ \o ->
    InlineResponse20020Platforms
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")
      <*> (o .:? "OSVersion")
      <*> (o .:? "OSFeatures")
      <*> (o .:? "Variant")
      <*> (o .:? "Features")

-- | ToJSON InlineResponse20020Platforms
instance A.ToJSON InlineResponse20020Platforms where
  toJSON InlineResponse20020Platforms {..} =
   _omitNulls
      [ "Architecture" .= inlineResponse20020PlatformsArchitecture
      , "OS" .= inlineResponse20020PlatformsOs
      , "OSVersion" .= inlineResponse20020PlatformsOsVersion
      , "OSFeatures" .= inlineResponse20020PlatformsOsFeatures
      , "Variant" .= inlineResponse20020PlatformsVariant
      , "Features" .= inlineResponse20020PlatformsFeatures
      ]


-- | Construct a value of type 'InlineResponse20020Platforms' (by applying it's required fields, if any)
mkInlineResponse20020Platforms
  :: InlineResponse20020Platforms
mkInlineResponse20020Platforms =
  InlineResponse20020Platforms
  { inlineResponse20020PlatformsArchitecture = Nothing
  , inlineResponse20020PlatformsOs = Nothing
  , inlineResponse20020PlatformsOsVersion = Nothing
  , inlineResponse20020PlatformsOsFeatures = Nothing
  , inlineResponse20020PlatformsVariant = Nothing
  , inlineResponse20020PlatformsFeatures = Nothing
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003StatusCode :: !(Int) -- ^ /Required/ "StatusCode" - Exit code of the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:  "StatusCode")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "StatusCode" .= inlineResponse2003StatusCode
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: Int -- ^ 'inlineResponse2003StatusCode': Exit code of the container
  -> InlineResponse2003
mkInlineResponse2003 inlineResponse2003StatusCode =
  InlineResponse2003
  { inlineResponse2003StatusCode
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004ContainersDeleted :: !(Maybe [Text]) -- ^ "ContainersDeleted" - Container IDs that were deleted
  , inlineResponse2004SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:? "ContainersDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "ContainersDeleted" .= inlineResponse2004ContainersDeleted
      , "SpaceReclaimed" .= inlineResponse2004SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: InlineResponse2004
mkInlineResponse2004 =
  InlineResponse2004
  { inlineResponse2004ContainersDeleted = Nothing
  , inlineResponse2004SpaceReclaimed = Nothing
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005Id :: !(Text) -- ^ /Required/ "Id"
  , inlineResponse2005Created :: !(Integer) -- ^ /Required/ "Created"
  , inlineResponse2005CreatedBy :: !(Text) -- ^ /Required/ "CreatedBy"
  , inlineResponse2005Tags :: !([Text]) -- ^ /Required/ "Tags"
  , inlineResponse2005Size :: !(Integer) -- ^ /Required/ "Size"
  , inlineResponse2005Comment :: !(Text) -- ^ /Required/ "Comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:  "Id")
      <*> (o .:  "Created")
      <*> (o .:  "CreatedBy")
      <*> (o .:  "Tags")
      <*> (o .:  "Size")
      <*> (o .:  "Comment")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "Id" .= inlineResponse2005Id
      , "Created" .= inlineResponse2005Created
      , "CreatedBy" .= inlineResponse2005CreatedBy
      , "Tags" .= inlineResponse2005Tags
      , "Size" .= inlineResponse2005Size
      , "Comment" .= inlineResponse2005Comment
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: Text -- ^ 'inlineResponse2005Id' 
  -> Integer -- ^ 'inlineResponse2005Created' 
  -> Text -- ^ 'inlineResponse2005CreatedBy' 
  -> [Text] -- ^ 'inlineResponse2005Tags' 
  -> Integer -- ^ 'inlineResponse2005Size' 
  -> Text -- ^ 'inlineResponse2005Comment' 
  -> InlineResponse2005
mkInlineResponse2005 inlineResponse2005Id inlineResponse2005Created inlineResponse2005CreatedBy inlineResponse2005Tags inlineResponse2005Size inlineResponse2005Comment =
  InlineResponse2005
  { inlineResponse2005Id
  , inlineResponse2005Created
  , inlineResponse2005CreatedBy
  , inlineResponse2005Tags
  , inlineResponse2005Size
  , inlineResponse2005Comment
  }

-- ** InlineResponse2006
-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Description :: !(Maybe Text) -- ^ "description"
  , inlineResponse2006IsOfficial :: !(Maybe Bool) -- ^ "is_official"
  , inlineResponse2006IsAutomated :: !(Maybe Bool) -- ^ "is_automated"
  , inlineResponse2006Name :: !(Maybe Text) -- ^ "name"
  , inlineResponse2006StarCount :: !(Maybe Int) -- ^ "star_count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:? "description")
      <*> (o .:? "is_official")
      <*> (o .:? "is_automated")
      <*> (o .:? "name")
      <*> (o .:? "star_count")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "description" .= inlineResponse2006Description
      , "is_official" .= inlineResponse2006IsOfficial
      , "is_automated" .= inlineResponse2006IsAutomated
      , "name" .= inlineResponse2006Name
      , "star_count" .= inlineResponse2006StarCount
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: InlineResponse2006
mkInlineResponse2006 =
  InlineResponse2006
  { inlineResponse2006Description = Nothing
  , inlineResponse2006IsOfficial = Nothing
  , inlineResponse2006IsAutomated = Nothing
  , inlineResponse2006Name = Nothing
  , inlineResponse2006StarCount = Nothing
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007ImagesDeleted :: !(Maybe [ImageDeleteResponseItem]) -- ^ "ImagesDeleted" - Images that were deleted
  , inlineResponse2007SpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:? "ImagesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "ImagesDeleted" .= inlineResponse2007ImagesDeleted
      , "SpaceReclaimed" .= inlineResponse2007SpaceReclaimed
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: InlineResponse2007
mkInlineResponse2007 =
  InlineResponse2007
  { inlineResponse2007ImagesDeleted = Nothing
  , inlineResponse2007SpaceReclaimed = Nothing
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008Status :: !(Text) -- ^ /Required/ "Status" - The status of the authentication
  , inlineResponse2008IdentityToken :: !(Maybe Text) -- ^ "IdentityToken" - An opaque token used to authenticate a user after a successful login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:  "Status")
      <*> (o .:? "IdentityToken")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "Status" .= inlineResponse2008Status
      , "IdentityToken" .= inlineResponse2008IdentityToken
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: Text -- ^ 'inlineResponse2008Status': The status of the authentication
  -> InlineResponse2008
mkInlineResponse2008 inlineResponse2008Status =
  InlineResponse2008
  { inlineResponse2008Status
  , inlineResponse2008IdentityToken = Nothing
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Architecture :: !(Maybe Text) -- ^ "Architecture"
  , inlineResponse2009Containers :: !(Maybe Int) -- ^ "Containers"
  , inlineResponse2009ContainersRunning :: !(Maybe Int) -- ^ "ContainersRunning"
  , inlineResponse2009ContainersStopped :: !(Maybe Int) -- ^ "ContainersStopped"
  , inlineResponse2009ContainersPaused :: !(Maybe Int) -- ^ "ContainersPaused"
  , inlineResponse2009CpuCfsPeriod :: !(Maybe Bool) -- ^ "CpuCfsPeriod"
  , inlineResponse2009CpuCfsQuota :: !(Maybe Bool) -- ^ "CpuCfsQuota"
  , inlineResponse2009Debug :: !(Maybe Bool) -- ^ "Debug"
  , inlineResponse2009DiscoveryBackend :: !(Maybe Text) -- ^ "DiscoveryBackend"
  , inlineResponse2009DockerRootDir :: !(Maybe Text) -- ^ "DockerRootDir"
  , inlineResponse2009Driver :: !(Maybe Text) -- ^ "Driver"
  , inlineResponse2009DriverStatus :: !(Maybe [[Text]]) -- ^ "DriverStatus"
  , inlineResponse2009SystemStatus :: !(Maybe [[Text]]) -- ^ "SystemStatus"
  , inlineResponse2009Plugins :: !(Maybe InlineResponse2009Plugins) -- ^ "Plugins"
  , inlineResponse2009ExperimentalBuild :: !(Maybe Bool) -- ^ "ExperimentalBuild"
  , inlineResponse2009HttpProxy :: !(Maybe Text) -- ^ "HttpProxy"
  , inlineResponse2009HttpsProxy :: !(Maybe Text) -- ^ "HttpsProxy"
  , inlineResponse2009Id :: !(Maybe Text) -- ^ "ID"
  , inlineResponse2009IPv4Forwarding :: !(Maybe Bool) -- ^ "IPv4Forwarding"
  , inlineResponse2009Images :: !(Maybe Int) -- ^ "Images"
  , inlineResponse2009IndexServerAddress :: !(Maybe Text) -- ^ "IndexServerAddress"
  , inlineResponse2009InitPath :: !(Maybe Text) -- ^ "InitPath"
  , inlineResponse2009InitSha1 :: !(Maybe Text) -- ^ "InitSha1"
  , inlineResponse2009KernelVersion :: !(Maybe Text) -- ^ "KernelVersion"
  , inlineResponse2009Labels :: !(Maybe [Text]) -- ^ "Labels"
  , inlineResponse2009MemTotal :: !(Maybe Int) -- ^ "MemTotal"
  , inlineResponse2009MemoryLimit :: !(Maybe Bool) -- ^ "MemoryLimit"
  , inlineResponse2009Ncpu :: !(Maybe Int) -- ^ "NCPU"
  , inlineResponse2009NEventsListener :: !(Maybe Int) -- ^ "NEventsListener"
  , inlineResponse2009NFd :: !(Maybe Int) -- ^ "NFd"
  , inlineResponse2009NGoroutines :: !(Maybe Int) -- ^ "NGoroutines"
  , inlineResponse2009Name :: !(Maybe Text) -- ^ "Name"
  , inlineResponse2009NoProxy :: !(Maybe Text) -- ^ "NoProxy"
  , inlineResponse2009OomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable"
  , inlineResponse2009OsType :: !(Maybe Text) -- ^ "OSType"
  , inlineResponse2009OomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj"
  , inlineResponse2009OperatingSystem :: !(Maybe Text) -- ^ "OperatingSystem"
  , inlineResponse2009RegistryConfig :: !(Maybe InlineResponse2009RegistryConfig) -- ^ "RegistryConfig"
  , inlineResponse2009SwapLimit :: !(Maybe Bool) -- ^ "SwapLimit"
  , inlineResponse2009SystemTime :: !(Maybe Text) -- ^ "SystemTime"
  , inlineResponse2009ServerVersion :: !(Maybe Text) -- ^ "ServerVersion"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:? "Architecture")
      <*> (o .:? "Containers")
      <*> (o .:? "ContainersRunning")
      <*> (o .:? "ContainersStopped")
      <*> (o .:? "ContainersPaused")
      <*> (o .:? "CpuCfsPeriod")
      <*> (o .:? "CpuCfsQuota")
      <*> (o .:? "Debug")
      <*> (o .:? "DiscoveryBackend")
      <*> (o .:? "DockerRootDir")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverStatus")
      <*> (o .:? "SystemStatus")
      <*> (o .:? "Plugins")
      <*> (o .:? "ExperimentalBuild")
      <*> (o .:? "HttpProxy")
      <*> (o .:? "HttpsProxy")
      <*> (o .:? "ID")
      <*> (o .:? "IPv4Forwarding")
      <*> (o .:? "Images")
      <*> (o .:? "IndexServerAddress")
      <*> (o .:? "InitPath")
      <*> (o .:? "InitSha1")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "MemTotal")
      <*> (o .:? "MemoryLimit")
      <*> (o .:? "NCPU")
      <*> (o .:? "NEventsListener")
      <*> (o .:? "NFd")
      <*> (o .:? "NGoroutines")
      <*> (o .:? "Name")
      <*> (o .:? "NoProxy")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "OSType")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "OperatingSystem")
      <*> (o .:? "RegistryConfig")
      <*> (o .:? "SwapLimit")
      <*> (o .:? "SystemTime")
      <*> (o .:? "ServerVersion")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "Architecture" .= inlineResponse2009Architecture
      , "Containers" .= inlineResponse2009Containers
      , "ContainersRunning" .= inlineResponse2009ContainersRunning
      , "ContainersStopped" .= inlineResponse2009ContainersStopped
      , "ContainersPaused" .= inlineResponse2009ContainersPaused
      , "CpuCfsPeriod" .= inlineResponse2009CpuCfsPeriod
      , "CpuCfsQuota" .= inlineResponse2009CpuCfsQuota
      , "Debug" .= inlineResponse2009Debug
      , "DiscoveryBackend" .= inlineResponse2009DiscoveryBackend
      , "DockerRootDir" .= inlineResponse2009DockerRootDir
      , "Driver" .= inlineResponse2009Driver
      , "DriverStatus" .= inlineResponse2009DriverStatus
      , "SystemStatus" .= inlineResponse2009SystemStatus
      , "Plugins" .= inlineResponse2009Plugins
      , "ExperimentalBuild" .= inlineResponse2009ExperimentalBuild
      , "HttpProxy" .= inlineResponse2009HttpProxy
      , "HttpsProxy" .= inlineResponse2009HttpsProxy
      , "ID" .= inlineResponse2009Id
      , "IPv4Forwarding" .= inlineResponse2009IPv4Forwarding
      , "Images" .= inlineResponse2009Images
      , "IndexServerAddress" .= inlineResponse2009IndexServerAddress
      , "InitPath" .= inlineResponse2009InitPath
      , "InitSha1" .= inlineResponse2009InitSha1
      , "KernelVersion" .= inlineResponse2009KernelVersion
      , "Labels" .= inlineResponse2009Labels
      , "MemTotal" .= inlineResponse2009MemTotal
      , "MemoryLimit" .= inlineResponse2009MemoryLimit
      , "NCPU" .= inlineResponse2009Ncpu
      , "NEventsListener" .= inlineResponse2009NEventsListener
      , "NFd" .= inlineResponse2009NFd
      , "NGoroutines" .= inlineResponse2009NGoroutines
      , "Name" .= inlineResponse2009Name
      , "NoProxy" .= inlineResponse2009NoProxy
      , "OomKillDisable" .= inlineResponse2009OomKillDisable
      , "OSType" .= inlineResponse2009OsType
      , "OomScoreAdj" .= inlineResponse2009OomScoreAdj
      , "OperatingSystem" .= inlineResponse2009OperatingSystem
      , "RegistryConfig" .= inlineResponse2009RegistryConfig
      , "SwapLimit" .= inlineResponse2009SwapLimit
      , "SystemTime" .= inlineResponse2009SystemTime
      , "ServerVersion" .= inlineResponse2009ServerVersion
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: InlineResponse2009
mkInlineResponse2009 =
  InlineResponse2009
  { inlineResponse2009Architecture = Nothing
  , inlineResponse2009Containers = Nothing
  , inlineResponse2009ContainersRunning = Nothing
  , inlineResponse2009ContainersStopped = Nothing
  , inlineResponse2009ContainersPaused = Nothing
  , inlineResponse2009CpuCfsPeriod = Nothing
  , inlineResponse2009CpuCfsQuota = Nothing
  , inlineResponse2009Debug = Nothing
  , inlineResponse2009DiscoveryBackend = Nothing
  , inlineResponse2009DockerRootDir = Nothing
  , inlineResponse2009Driver = Nothing
  , inlineResponse2009DriverStatus = Nothing
  , inlineResponse2009SystemStatus = Nothing
  , inlineResponse2009Plugins = Nothing
  , inlineResponse2009ExperimentalBuild = Nothing
  , inlineResponse2009HttpProxy = Nothing
  , inlineResponse2009HttpsProxy = Nothing
  , inlineResponse2009Id = Nothing
  , inlineResponse2009IPv4Forwarding = Nothing
  , inlineResponse2009Images = Nothing
  , inlineResponse2009IndexServerAddress = Nothing
  , inlineResponse2009InitPath = Nothing
  , inlineResponse2009InitSha1 = Nothing
  , inlineResponse2009KernelVersion = Nothing
  , inlineResponse2009Labels = Nothing
  , inlineResponse2009MemTotal = Nothing
  , inlineResponse2009MemoryLimit = Nothing
  , inlineResponse2009Ncpu = Nothing
  , inlineResponse2009NEventsListener = Nothing
  , inlineResponse2009NFd = Nothing
  , inlineResponse2009NGoroutines = Nothing
  , inlineResponse2009Name = Nothing
  , inlineResponse2009NoProxy = Nothing
  , inlineResponse2009OomKillDisable = Nothing
  , inlineResponse2009OsType = Nothing
  , inlineResponse2009OomScoreAdj = Nothing
  , inlineResponse2009OperatingSystem = Nothing
  , inlineResponse2009RegistryConfig = Nothing
  , inlineResponse2009SwapLimit = Nothing
  , inlineResponse2009SystemTime = Nothing
  , inlineResponse2009ServerVersion = Nothing
  }

-- ** InlineResponse2009Plugins
-- | InlineResponse2009Plugins
data InlineResponse2009Plugins = InlineResponse2009Plugins
  { inlineResponse2009PluginsVolume :: !(Maybe [Text]) -- ^ "Volume"
  , inlineResponse2009PluginsNetwork :: !(Maybe [Text]) -- ^ "Network"
  , inlineResponse2009PluginsLog :: !(Maybe [Text]) -- ^ "Log"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009Plugins
instance A.FromJSON InlineResponse2009Plugins where
  parseJSON = A.withObject "InlineResponse2009Plugins" $ \o ->
    InlineResponse2009Plugins
      <$> (o .:? "Volume")
      <*> (o .:? "Network")
      <*> (o .:? "Log")

-- | ToJSON InlineResponse2009Plugins
instance A.ToJSON InlineResponse2009Plugins where
  toJSON InlineResponse2009Plugins {..} =
   _omitNulls
      [ "Volume" .= inlineResponse2009PluginsVolume
      , "Network" .= inlineResponse2009PluginsNetwork
      , "Log" .= inlineResponse2009PluginsLog
      ]


-- | Construct a value of type 'InlineResponse2009Plugins' (by applying it's required fields, if any)
mkInlineResponse2009Plugins
  :: InlineResponse2009Plugins
mkInlineResponse2009Plugins =
  InlineResponse2009Plugins
  { inlineResponse2009PluginsVolume = Nothing
  , inlineResponse2009PluginsNetwork = Nothing
  , inlineResponse2009PluginsLog = Nothing
  }

-- ** InlineResponse2009RegistryConfig
-- | InlineResponse2009RegistryConfig
data InlineResponse2009RegistryConfig = InlineResponse2009RegistryConfig
  { inlineResponse2009RegistryConfigIndexConfigs :: !(Maybe (Map.Map String InlineResponse2009RegistryConfigIndexConfigs)) -- ^ "IndexConfigs"
  , inlineResponse2009RegistryConfigInsecureRegistryCidRs :: !(Maybe [Text]) -- ^ "InsecureRegistryCIDRs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009RegistryConfig
instance A.FromJSON InlineResponse2009RegistryConfig where
  parseJSON = A.withObject "InlineResponse2009RegistryConfig" $ \o ->
    InlineResponse2009RegistryConfig
      <$> (o .:? "IndexConfigs")
      <*> (o .:? "InsecureRegistryCIDRs")

-- | ToJSON InlineResponse2009RegistryConfig
instance A.ToJSON InlineResponse2009RegistryConfig where
  toJSON InlineResponse2009RegistryConfig {..} =
   _omitNulls
      [ "IndexConfigs" .= inlineResponse2009RegistryConfigIndexConfigs
      , "InsecureRegistryCIDRs" .= inlineResponse2009RegistryConfigInsecureRegistryCidRs
      ]


-- | Construct a value of type 'InlineResponse2009RegistryConfig' (by applying it's required fields, if any)
mkInlineResponse2009RegistryConfig
  :: InlineResponse2009RegistryConfig
mkInlineResponse2009RegistryConfig =
  InlineResponse2009RegistryConfig
  { inlineResponse2009RegistryConfigIndexConfigs = Nothing
  , inlineResponse2009RegistryConfigInsecureRegistryCidRs = Nothing
  }

-- ** InlineResponse2009RegistryConfigIndexConfigs
-- | InlineResponse2009RegistryConfigIndexConfigs
data InlineResponse2009RegistryConfigIndexConfigs = InlineResponse2009RegistryConfigIndexConfigs
  { inlineResponse2009RegistryConfigIndexConfigsMirrors :: !(Maybe [Text]) -- ^ "Mirrors"
  , inlineResponse2009RegistryConfigIndexConfigsName :: !(Maybe Text) -- ^ "Name"
  , inlineResponse2009RegistryConfigIndexConfigsOfficial :: !(Maybe Bool) -- ^ "Official"
  , inlineResponse2009RegistryConfigIndexConfigsSecure :: !(Maybe Bool) -- ^ "Secure"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009RegistryConfigIndexConfigs
instance A.FromJSON InlineResponse2009RegistryConfigIndexConfigs where
  parseJSON = A.withObject "InlineResponse2009RegistryConfigIndexConfigs" $ \o ->
    InlineResponse2009RegistryConfigIndexConfigs
      <$> (o .:? "Mirrors")
      <*> (o .:? "Name")
      <*> (o .:? "Official")
      <*> (o .:? "Secure")

-- | ToJSON InlineResponse2009RegistryConfigIndexConfigs
instance A.ToJSON InlineResponse2009RegistryConfigIndexConfigs where
  toJSON InlineResponse2009RegistryConfigIndexConfigs {..} =
   _omitNulls
      [ "Mirrors" .= inlineResponse2009RegistryConfigIndexConfigsMirrors
      , "Name" .= inlineResponse2009RegistryConfigIndexConfigsName
      , "Official" .= inlineResponse2009RegistryConfigIndexConfigsOfficial
      , "Secure" .= inlineResponse2009RegistryConfigIndexConfigsSecure
      ]


-- | Construct a value of type 'InlineResponse2009RegistryConfigIndexConfigs' (by applying it's required fields, if any)
mkInlineResponse2009RegistryConfigIndexConfigs
  :: InlineResponse2009RegistryConfigIndexConfigs
mkInlineResponse2009RegistryConfigIndexConfigs =
  InlineResponse2009RegistryConfigIndexConfigs
  { inlineResponse2009RegistryConfigIndexConfigsMirrors = Nothing
  , inlineResponse2009RegistryConfigIndexConfigsName = Nothing
  , inlineResponse2009RegistryConfigIndexConfigsOfficial = Nothing
  , inlineResponse2009RegistryConfigIndexConfigsSecure = Nothing
  }

-- ** InlineResponse201
-- | InlineResponse201
data InlineResponse201 = InlineResponse201
  { inlineResponse201Id :: !(Text) -- ^ /Required/ "Id" - The ID of the created container
  , inlineResponse201Warnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings encountered when creating the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse201
instance A.FromJSON InlineResponse201 where
  parseJSON = A.withObject "InlineResponse201" $ \o ->
    InlineResponse201
      <$> (o .:  "Id")
      <*> (o .:  "Warnings")

-- | ToJSON InlineResponse201
instance A.ToJSON InlineResponse201 where
  toJSON InlineResponse201 {..} =
   _omitNulls
      [ "Id" .= inlineResponse201Id
      , "Warnings" .= inlineResponse201Warnings
      ]


-- | Construct a value of type 'InlineResponse201' (by applying it's required fields, if any)
mkInlineResponse201
  :: Text -- ^ 'inlineResponse201Id': The ID of the created container
  -> [Text] -- ^ 'inlineResponse201Warnings': Warnings encountered when creating the container
  -> InlineResponse201
mkInlineResponse201 inlineResponse201Id inlineResponse201Warnings =
  InlineResponse201
  { inlineResponse201Id
  , inlineResponse201Warnings
  }

-- ** InlineResponse2011
-- | InlineResponse2011
data InlineResponse2011 = InlineResponse2011
  { inlineResponse2011Id :: !(Maybe Text) -- ^ "Id" - The ID of the created network.
  , inlineResponse2011Warning :: !(Maybe Text) -- ^ "Warning"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2011
instance A.FromJSON InlineResponse2011 where
  parseJSON = A.withObject "InlineResponse2011" $ \o ->
    InlineResponse2011
      <$> (o .:? "Id")
      <*> (o .:? "Warning")

-- | ToJSON InlineResponse2011
instance A.ToJSON InlineResponse2011 where
  toJSON InlineResponse2011 {..} =
   _omitNulls
      [ "Id" .= inlineResponse2011Id
      , "Warning" .= inlineResponse2011Warning
      ]


-- | Construct a value of type 'InlineResponse2011' (by applying it's required fields, if any)
mkInlineResponse2011
  :: InlineResponse2011
mkInlineResponse2011 =
  InlineResponse2011
  { inlineResponse2011Id = Nothing
  , inlineResponse2011Warning = Nothing
  }

-- ** InlineResponse2012
-- | InlineResponse2012
data InlineResponse2012 = InlineResponse2012
  { inlineResponse2012Id :: !(Maybe Text) -- ^ "ID" - The ID of the created service.
  , inlineResponse2012Warning :: !(Maybe Text) -- ^ "Warning" - Optional warning message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2012
instance A.FromJSON InlineResponse2012 where
  parseJSON = A.withObject "InlineResponse2012" $ \o ->
    InlineResponse2012
      <$> (o .:? "ID")
      <*> (o .:? "Warning")

-- | ToJSON InlineResponse2012
instance A.ToJSON InlineResponse2012 where
  toJSON InlineResponse2012 {..} =
   _omitNulls
      [ "ID" .= inlineResponse2012Id
      , "Warning" .= inlineResponse2012Warning
      ]


-- | Construct a value of type 'InlineResponse2012' (by applying it's required fields, if any)
mkInlineResponse2012
  :: InlineResponse2012
mkInlineResponse2012 =
  InlineResponse2012
  { inlineResponse2012Id = Nothing
  , inlineResponse2012Warning = Nothing
  }

-- ** InlineResponse2013
-- | InlineResponse2013
data InlineResponse2013 = InlineResponse2013
  { inlineResponse2013Id :: !(Maybe Text) -- ^ "ID" - The ID of the created secret.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2013
instance A.FromJSON InlineResponse2013 where
  parseJSON = A.withObject "InlineResponse2013" $ \o ->
    InlineResponse2013
      <$> (o .:? "ID")

-- | ToJSON InlineResponse2013
instance A.ToJSON InlineResponse2013 where
  toJSON InlineResponse2013 {..} =
   _omitNulls
      [ "ID" .= inlineResponse2013Id
      ]


-- | Construct a value of type 'InlineResponse2013' (by applying it's required fields, if any)
mkInlineResponse2013
  :: InlineResponse2013
mkInlineResponse2013 =
  InlineResponse2013
  { inlineResponse2013Id = Nothing
  }

-- ** InlineResponse2014
-- | InlineResponse2014
data InlineResponse2014 = InlineResponse2014
  { inlineResponse2014Id :: !(Maybe Text) -- ^ "ID" - The ID of the created config.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2014
instance A.FromJSON InlineResponse2014 where
  parseJSON = A.withObject "InlineResponse2014" $ \o ->
    InlineResponse2014
      <$> (o .:? "ID")

-- | ToJSON InlineResponse2014
instance A.ToJSON InlineResponse2014 where
  toJSON InlineResponse2014 {..} =
   _omitNulls
      [ "ID" .= inlineResponse2014Id
      ]


-- | Construct a value of type 'InlineResponse2014' (by applying it's required fields, if any)
mkInlineResponse2014
  :: InlineResponse2014
mkInlineResponse2014 =
  InlineResponse2014
  { inlineResponse2014Id = Nothing
  }

-- ** InlineResponse400
-- | InlineResponse400
data InlineResponse400 = InlineResponse400
  { inlineResponse400ErrorResponse :: !(Maybe ErrorResponse) -- ^ "ErrorResponse"
  , inlineResponse400Message :: !(Maybe Text) -- ^ "message" - The error message. Either \&quot;must specify path parameter\&quot; (path cannot be empty) or \&quot;not a directory\&quot; (path was asserted to be a directory but exists as a file).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse400
instance A.FromJSON InlineResponse400 where
  parseJSON = A.withObject "InlineResponse400" $ \o ->
    InlineResponse400
      <$> (o .:? "ErrorResponse")
      <*> (o .:? "message")

-- | ToJSON InlineResponse400
instance A.ToJSON InlineResponse400 where
  toJSON InlineResponse400 {..} =
   _omitNulls
      [ "ErrorResponse" .= inlineResponse400ErrorResponse
      , "message" .= inlineResponse400Message
      ]


-- | Construct a value of type 'InlineResponse400' (by applying it's required fields, if any)
mkInlineResponse400
  :: InlineResponse400
mkInlineResponse400 =
  InlineResponse400
  { inlineResponse400ErrorResponse = Nothing
  , inlineResponse400Message = Nothing
  }

-- ** InspectResponse
-- | InspectResponse
data InspectResponse = InspectResponse
  { inspectResponseId :: !(Maybe Text) -- ^ "Id" - The ID of the container
  , inspectResponseCreated :: !(Maybe Text) -- ^ "Created" - The time the container was created
  , inspectResponsePath :: !(Maybe Text) -- ^ "Path" - The path to the command being run
  , inspectResponseArgs :: !(Maybe [Text]) -- ^ "Args" - The arguments to the command being run
  , inspectResponseState :: !(Maybe InspectResponseState) -- ^ "State"
  , inspectResponseImage :: !(Maybe Text) -- ^ "Image" - The container&#39;s image
  , inspectResponseResolvConfPath :: !(Maybe Text) -- ^ "ResolvConfPath"
  , inspectResponseHostnamePath :: !(Maybe Text) -- ^ "HostnamePath"
  , inspectResponseHostsPath :: !(Maybe Text) -- ^ "HostsPath"
  , inspectResponseLogPath :: !(Maybe Text) -- ^ "LogPath"
  , inspectResponseNode :: !(Maybe A.Value) -- ^ "Node" - TODO
  , inspectResponseName :: !(Maybe Text) -- ^ "Name"
  , inspectResponseRestartCount :: !(Maybe Int) -- ^ "RestartCount"
  , inspectResponseDriver :: !(Maybe Text) -- ^ "Driver"
  , inspectResponseMountLabel :: !(Maybe Text) -- ^ "MountLabel"
  , inspectResponseProcessLabel :: !(Maybe Text) -- ^ "ProcessLabel"
  , inspectResponseAppArmorProfile :: !(Maybe Text) -- ^ "AppArmorProfile"
  , inspectResponseExecIDs :: !(Maybe Text) -- ^ "ExecIDs"
  , inspectResponseHostConfig :: !(Maybe HostConfig) -- ^ "HostConfig"
  , inspectResponseGraphDriver :: !(Maybe GraphDriverData) -- ^ "GraphDriver"
  , inspectResponseSizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container.
  , inspectResponseSizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container.
  , inspectResponseMounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  , inspectResponseConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , inspectResponseNetworkSettings :: !(Maybe NetworkConfig) -- ^ "NetworkSettings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InspectResponse
instance A.FromJSON InspectResponse where
  parseJSON = A.withObject "InspectResponse" $ \o ->
    InspectResponse
      <$> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Path")
      <*> (o .:? "Args")
      <*> (o .:? "State")
      <*> (o .:? "Image")
      <*> (o .:? "ResolvConfPath")
      <*> (o .:? "HostnamePath")
      <*> (o .:? "HostsPath")
      <*> (o .:? "LogPath")
      <*> (o .:? "Node")
      <*> (o .:? "Name")
      <*> (o .:? "RestartCount")
      <*> (o .:? "Driver")
      <*> (o .:? "MountLabel")
      <*> (o .:? "ProcessLabel")
      <*> (o .:? "AppArmorProfile")
      <*> (o .:? "ExecIDs")
      <*> (o .:? "HostConfig")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Mounts")
      <*> (o .:? "Config")
      <*> (o .:? "NetworkSettings")

-- | ToJSON InspectResponse
instance A.ToJSON InspectResponse where
  toJSON InspectResponse {..} =
   _omitNulls
      [ "Id" .= inspectResponseId
      , "Created" .= inspectResponseCreated
      , "Path" .= inspectResponsePath
      , "Args" .= inspectResponseArgs
      , "State" .= inspectResponseState
      , "Image" .= inspectResponseImage
      , "ResolvConfPath" .= inspectResponseResolvConfPath
      , "HostnamePath" .= inspectResponseHostnamePath
      , "HostsPath" .= inspectResponseHostsPath
      , "LogPath" .= inspectResponseLogPath
      , "Node" .= inspectResponseNode
      , "Name" .= inspectResponseName
      , "RestartCount" .= inspectResponseRestartCount
      , "Driver" .= inspectResponseDriver
      , "MountLabel" .= inspectResponseMountLabel
      , "ProcessLabel" .= inspectResponseProcessLabel
      , "AppArmorProfile" .= inspectResponseAppArmorProfile
      , "ExecIDs" .= inspectResponseExecIDs
      , "HostConfig" .= inspectResponseHostConfig
      , "GraphDriver" .= inspectResponseGraphDriver
      , "SizeRw" .= inspectResponseSizeRw
      , "SizeRootFs" .= inspectResponseSizeRootFs
      , "Mounts" .= inspectResponseMounts
      , "Config" .= inspectResponseConfig
      , "NetworkSettings" .= inspectResponseNetworkSettings
      ]


-- | Construct a value of type 'InspectResponse' (by applying it's required fields, if any)
mkInspectResponse
  :: InspectResponse
mkInspectResponse =
  InspectResponse
  { inspectResponseId = Nothing
  , inspectResponseCreated = Nothing
  , inspectResponsePath = Nothing
  , inspectResponseArgs = Nothing
  , inspectResponseState = Nothing
  , inspectResponseImage = Nothing
  , inspectResponseResolvConfPath = Nothing
  , inspectResponseHostnamePath = Nothing
  , inspectResponseHostsPath = Nothing
  , inspectResponseLogPath = Nothing
  , inspectResponseNode = Nothing
  , inspectResponseName = Nothing
  , inspectResponseRestartCount = Nothing
  , inspectResponseDriver = Nothing
  , inspectResponseMountLabel = Nothing
  , inspectResponseProcessLabel = Nothing
  , inspectResponseAppArmorProfile = Nothing
  , inspectResponseExecIDs = Nothing
  , inspectResponseHostConfig = Nothing
  , inspectResponseGraphDriver = Nothing
  , inspectResponseSizeRw = Nothing
  , inspectResponseSizeRootFs = Nothing
  , inspectResponseMounts = Nothing
  , inspectResponseConfig = Nothing
  , inspectResponseNetworkSettings = Nothing
  }

-- ** InspectResponseState
-- | InspectResponseState
-- The state of the container.
data InspectResponseState = InspectResponseState
  { inspectResponseStateStatus :: !(Maybe E'Status) -- ^ "Status" - The status of the container. For example, &#x60;\&quot;running\&quot;&#x60; or &#x60;\&quot;exited\&quot;&#x60;. 
  , inspectResponseStateRunning :: !(Maybe Bool) -- ^ "Running" - Whether this container is running.  Note that a running container can be _paused_. The &#x60;Running&#x60; and &#x60;Paused&#x60; booleans are not mutually exclusive:  When pausing a container (on Linux), the cgroups freezer is used to suspend all processes in the container. Freezing the process requires the process to be running. As a result, paused containers are both &#x60;Running&#x60; _and_ &#x60;Paused&#x60;.  Use the &#x60;Status&#x60; field instead to determine if a container&#39;s state is \&quot;running\&quot;. 
  , inspectResponseStatePaused :: !(Maybe Bool) -- ^ "Paused" - Whether this container is paused.
  , inspectResponseStateRestarting :: !(Maybe Bool) -- ^ "Restarting" - Whether this container is restarting.
  , inspectResponseStateOomKilled :: !(Maybe Bool) -- ^ "OOMKilled" - Whether this container has been killed because it ran out of memory.
  , inspectResponseStateDead :: !(Maybe Bool) -- ^ "Dead"
  , inspectResponseStatePid :: !(Maybe Int) -- ^ "Pid" - The process ID of this container
  , inspectResponseStateExitCode :: !(Maybe Int) -- ^ "ExitCode" - The last exit code of this container
  , inspectResponseStateError :: !(Maybe Text) -- ^ "Error"
  , inspectResponseStateStartedAt :: !(Maybe Text) -- ^ "StartedAt" - The time when this container was last started.
  , inspectResponseStateFinishedAt :: !(Maybe Text) -- ^ "FinishedAt" - The time when this container last exited.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InspectResponseState
instance A.FromJSON InspectResponseState where
  parseJSON = A.withObject "InspectResponseState" $ \o ->
    InspectResponseState
      <$> (o .:? "Status")
      <*> (o .:? "Running")
      <*> (o .:? "Paused")
      <*> (o .:? "Restarting")
      <*> (o .:? "OOMKilled")
      <*> (o .:? "Dead")
      <*> (o .:? "Pid")
      <*> (o .:? "ExitCode")
      <*> (o .:? "Error")
      <*> (o .:? "StartedAt")
      <*> (o .:? "FinishedAt")

-- | ToJSON InspectResponseState
instance A.ToJSON InspectResponseState where
  toJSON InspectResponseState {..} =
   _omitNulls
      [ "Status" .= inspectResponseStateStatus
      , "Running" .= inspectResponseStateRunning
      , "Paused" .= inspectResponseStatePaused
      , "Restarting" .= inspectResponseStateRestarting
      , "OOMKilled" .= inspectResponseStateOomKilled
      , "Dead" .= inspectResponseStateDead
      , "Pid" .= inspectResponseStatePid
      , "ExitCode" .= inspectResponseStateExitCode
      , "Error" .= inspectResponseStateError
      , "StartedAt" .= inspectResponseStateStartedAt
      , "FinishedAt" .= inspectResponseStateFinishedAt
      ]


-- | Construct a value of type 'InspectResponseState' (by applying it's required fields, if any)
mkInspectResponseState
  :: InspectResponseState
mkInspectResponseState =
  InspectResponseState
  { inspectResponseStateStatus = Nothing
  , inspectResponseStateRunning = Nothing
  , inspectResponseStatePaused = Nothing
  , inspectResponseStateRestarting = Nothing
  , inspectResponseStateOomKilled = Nothing
  , inspectResponseStateDead = Nothing
  , inspectResponseStatePid = Nothing
  , inspectResponseStateExitCode = Nothing
  , inspectResponseStateError = Nothing
  , inspectResponseStateStartedAt = Nothing
  , inspectResponseStateFinishedAt = Nothing
  }

-- ** Mount
-- | Mount
data Mount = Mount
  { mountTarget :: !(Maybe Text) -- ^ "Target" - Container path.
  , mountSource :: !(Maybe Text) -- ^ "Source" - Mount source (e.g. a volume name, a host path).
  , mountType :: !(Maybe E'Type2) -- ^ "Type" - The mount type. Available types:  - &#x60;bind&#x60; Mounts a file or directory from the host into the container. Must exist prior to creating the container. - &#x60;volume&#x60; Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - &#x60;tmpfs&#x60; Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
  , mountReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Whether the mount should be read-only.
  , mountConsistency :: !(Maybe Text) -- ^ "Consistency" - The consistency requirement for the mount: &#x60;default&#x60;, &#x60;consistent&#x60;, &#x60;cached&#x60;, or &#x60;delegated&#x60;.
  , mountBindOptions :: !(Maybe MountBindOptions) -- ^ "BindOptions"
  , mountVolumeOptions :: !(Maybe MountVolumeOptions) -- ^ "VolumeOptions"
  , mountTmpfsOptions :: !(Maybe MountTmpfsOptions) -- ^ "TmpfsOptions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mount
instance A.FromJSON Mount where
  parseJSON = A.withObject "Mount" $ \o ->
    Mount
      <$> (o .:? "Target")
      <*> (o .:? "Source")
      <*> (o .:? "Type")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Consistency")
      <*> (o .:? "BindOptions")
      <*> (o .:? "VolumeOptions")
      <*> (o .:? "TmpfsOptions")

-- | ToJSON Mount
instance A.ToJSON Mount where
  toJSON Mount {..} =
   _omitNulls
      [ "Target" .= mountTarget
      , "Source" .= mountSource
      , "Type" .= mountType
      , "ReadOnly" .= mountReadOnly
      , "Consistency" .= mountConsistency
      , "BindOptions" .= mountBindOptions
      , "VolumeOptions" .= mountVolumeOptions
      , "TmpfsOptions" .= mountTmpfsOptions
      ]


-- | Construct a value of type 'Mount' (by applying it's required fields, if any)
mkMount
  :: Mount
mkMount =
  Mount
  { mountTarget = Nothing
  , mountSource = Nothing
  , mountType = Nothing
  , mountReadOnly = Nothing
  , mountConsistency = Nothing
  , mountBindOptions = Nothing
  , mountVolumeOptions = Nothing
  , mountTmpfsOptions = Nothing
  }

-- ** MountBindOptions
-- | MountBindOptions
-- Optional configuration for the `bind` type.
data MountBindOptions = MountBindOptions
  { mountBindOptionsPropagation :: !(Maybe A.Value) -- ^ "Propagation" - A propagation mode with the value &#x60;[r]private&#x60;, &#x60;[r]shared&#x60;, or &#x60;[r]slave&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountBindOptions
instance A.FromJSON MountBindOptions where
  parseJSON = A.withObject "MountBindOptions" $ \o ->
    MountBindOptions
      <$> (o .:? "Propagation")

-- | ToJSON MountBindOptions
instance A.ToJSON MountBindOptions where
  toJSON MountBindOptions {..} =
   _omitNulls
      [ "Propagation" .= mountBindOptionsPropagation
      ]


-- | Construct a value of type 'MountBindOptions' (by applying it's required fields, if any)
mkMountBindOptions
  :: MountBindOptions
mkMountBindOptions =
  MountBindOptions
  { mountBindOptionsPropagation = Nothing
  }

-- ** MountPoint
-- | MountPoint
-- A mount point inside a container
data MountPoint = MountPoint
  { mountPointType :: !(Maybe Text) -- ^ "Type"
  , mountPointName :: !(Maybe Text) -- ^ "Name"
  , mountPointSource :: !(Maybe Text) -- ^ "Source"
  , mountPointDestination :: !(Maybe Text) -- ^ "Destination"
  , mountPointDriver :: !(Maybe Text) -- ^ "Driver"
  , mountPointMode :: !(Maybe Text) -- ^ "Mode"
  , mountPointRw :: !(Maybe Bool) -- ^ "RW"
  , mountPointPropagation :: !(Maybe Text) -- ^ "Propagation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountPoint
instance A.FromJSON MountPoint where
  parseJSON = A.withObject "MountPoint" $ \o ->
    MountPoint
      <$> (o .:? "Type")
      <*> (o .:? "Name")
      <*> (o .:? "Source")
      <*> (o .:? "Destination")
      <*> (o .:? "Driver")
      <*> (o .:? "Mode")
      <*> (o .:? "RW")
      <*> (o .:? "Propagation")

-- | ToJSON MountPoint
instance A.ToJSON MountPoint where
  toJSON MountPoint {..} =
   _omitNulls
      [ "Type" .= mountPointType
      , "Name" .= mountPointName
      , "Source" .= mountPointSource
      , "Destination" .= mountPointDestination
      , "Driver" .= mountPointDriver
      , "Mode" .= mountPointMode
      , "RW" .= mountPointRw
      , "Propagation" .= mountPointPropagation
      ]


-- | Construct a value of type 'MountPoint' (by applying it's required fields, if any)
mkMountPoint
  :: MountPoint
mkMountPoint =
  MountPoint
  { mountPointType = Nothing
  , mountPointName = Nothing
  , mountPointSource = Nothing
  , mountPointDestination = Nothing
  , mountPointDriver = Nothing
  , mountPointMode = Nothing
  , mountPointRw = Nothing
  , mountPointPropagation = Nothing
  }

-- ** MountTmpfsOptions
-- | MountTmpfsOptions
-- Optional configuration for the `tmpfs` type.
data MountTmpfsOptions = MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes :: !(Maybe Integer) -- ^ "SizeBytes" - The size for the tmpfs mount in bytes.
  , mountTmpfsOptionsMode :: !(Maybe Int) -- ^ "Mode" - The permission mode for the tmpfs mount in an integer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountTmpfsOptions
instance A.FromJSON MountTmpfsOptions where
  parseJSON = A.withObject "MountTmpfsOptions" $ \o ->
    MountTmpfsOptions
      <$> (o .:? "SizeBytes")
      <*> (o .:? "Mode")

-- | ToJSON MountTmpfsOptions
instance A.ToJSON MountTmpfsOptions where
  toJSON MountTmpfsOptions {..} =
   _omitNulls
      [ "SizeBytes" .= mountTmpfsOptionsSizeBytes
      , "Mode" .= mountTmpfsOptionsMode
      ]


-- | Construct a value of type 'MountTmpfsOptions' (by applying it's required fields, if any)
mkMountTmpfsOptions
  :: MountTmpfsOptions
mkMountTmpfsOptions =
  MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes = Nothing
  , mountTmpfsOptionsMode = Nothing
  }

-- ** MountVolumeOptions
-- | MountVolumeOptions
-- Optional configuration for the `volume` type.
data MountVolumeOptions = MountVolumeOptions
  { mountVolumeOptionsNoCopy :: !(Maybe Bool) -- ^ "NoCopy" - Populate volume with data from the target.
  , mountVolumeOptionsLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , mountVolumeOptionsDriverConfig :: !(Maybe MountVolumeOptionsDriverConfig) -- ^ "DriverConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptions
instance A.FromJSON MountVolumeOptions where
  parseJSON = A.withObject "MountVolumeOptions" $ \o ->
    MountVolumeOptions
      <$> (o .:? "NoCopy")
      <*> (o .:? "Labels")
      <*> (o .:? "DriverConfig")

-- | ToJSON MountVolumeOptions
instance A.ToJSON MountVolumeOptions where
  toJSON MountVolumeOptions {..} =
   _omitNulls
      [ "NoCopy" .= mountVolumeOptionsNoCopy
      , "Labels" .= mountVolumeOptionsLabels
      , "DriverConfig" .= mountVolumeOptionsDriverConfig
      ]


-- | Construct a value of type 'MountVolumeOptions' (by applying it's required fields, if any)
mkMountVolumeOptions
  :: MountVolumeOptions
mkMountVolumeOptions =
  MountVolumeOptions
  { mountVolumeOptionsNoCopy = Nothing
  , mountVolumeOptionsLabels = Nothing
  , mountVolumeOptionsDriverConfig = Nothing
  }

-- ** MountVolumeOptionsDriverConfig
-- | MountVolumeOptionsDriverConfig
-- Map of driver specific options
data MountVolumeOptionsDriverConfig = MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName :: !(Maybe Text) -- ^ "Name" - Name of the driver to use to create the volume.
  , mountVolumeOptionsDriverConfigOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - key/value map of driver specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptionsDriverConfig
instance A.FromJSON MountVolumeOptionsDriverConfig where
  parseJSON = A.withObject "MountVolumeOptionsDriverConfig" $ \o ->
    MountVolumeOptionsDriverConfig
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON MountVolumeOptionsDriverConfig
instance A.ToJSON MountVolumeOptionsDriverConfig where
  toJSON MountVolumeOptionsDriverConfig {..} =
   _omitNulls
      [ "Name" .= mountVolumeOptionsDriverConfigName
      , "Options" .= mountVolumeOptionsDriverConfigOptions
      ]


-- | Construct a value of type 'MountVolumeOptionsDriverConfig' (by applying it's required fields, if any)
mkMountVolumeOptionsDriverConfig
  :: MountVolumeOptionsDriverConfig
mkMountVolumeOptionsDriverConfig =
  MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName = Nothing
  , mountVolumeOptionsDriverConfigOptions = Nothing
  }

-- ** Network
-- | Network
data Network = Network
  { networkName :: !(Maybe Text) -- ^ "Name"
  , networkId :: !(Maybe Text) -- ^ "Id"
  , networkCreated :: !(Maybe Text) -- ^ "Created"
  , networkScope :: !(Maybe Text) -- ^ "Scope"
  , networkDriver :: !(Maybe Text) -- ^ "Driver"
  , networkEnableIPv6 :: !(Maybe Bool) -- ^ "EnableIPv6"
  , networkIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkInternal :: !(Maybe Bool) -- ^ "Internal"
  , networkAttachable :: !(Maybe Bool) -- ^ "Attachable"
  , networkIngress :: !(Maybe Bool) -- ^ "Ingress"
  , networkContainers :: !(Maybe (Map.Map String NetworkContainer)) -- ^ "Containers"
  , networkOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  , networkLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Network
instance A.FromJSON Network where
  parseJSON = A.withObject "Network" $ \o ->
    Network
      <$> (o .:? "Name")
      <*> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Scope")
      <*> (o .:? "Driver")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "IPAM")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "Containers")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON Network
instance A.ToJSON Network where
  toJSON Network {..} =
   _omitNulls
      [ "Name" .= networkName
      , "Id" .= networkId
      , "Created" .= networkCreated
      , "Scope" .= networkScope
      , "Driver" .= networkDriver
      , "EnableIPv6" .= networkEnableIPv6
      , "IPAM" .= networkIpam
      , "Internal" .= networkInternal
      , "Attachable" .= networkAttachable
      , "Ingress" .= networkIngress
      , "Containers" .= networkContainers
      , "Options" .= networkOptions
      , "Labels" .= networkLabels
      ]


-- | Construct a value of type 'Network' (by applying it's required fields, if any)
mkNetwork
  :: Network
mkNetwork =
  Network
  { networkName = Nothing
  , networkId = Nothing
  , networkCreated = Nothing
  , networkScope = Nothing
  , networkDriver = Nothing
  , networkEnableIPv6 = Nothing
  , networkIpam = Nothing
  , networkInternal = Nothing
  , networkAttachable = Nothing
  , networkIngress = Nothing
  , networkContainers = Nothing
  , networkOptions = Nothing
  , networkLabels = Nothing
  }

-- ** NetworkConfig
-- | NetworkConfig
-- TODO: check is correct
data NetworkConfig = NetworkConfig
  { networkConfigBridge :: !(Maybe Text) -- ^ "Bridge"
  , networkConfigGateway :: !(Maybe Text) -- ^ "Gateway"
  , networkConfigAddress :: !(Maybe Text) -- ^ "Address"
  , networkConfigIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen"
  , networkConfigMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  , networkConfigPortMapping :: !(Maybe Text) -- ^ "PortMapping"
  , networkConfigPorts :: !(Maybe [Port]) -- ^ "Ports"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkConfig
instance A.FromJSON NetworkConfig where
  parseJSON = A.withObject "NetworkConfig" $ \o ->
    NetworkConfig
      <$> (o .:? "Bridge")
      <*> (o .:? "Gateway")
      <*> (o .:? "Address")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "MacAddress")
      <*> (o .:? "PortMapping")
      <*> (o .:? "Ports")

-- | ToJSON NetworkConfig
instance A.ToJSON NetworkConfig where
  toJSON NetworkConfig {..} =
   _omitNulls
      [ "Bridge" .= networkConfigBridge
      , "Gateway" .= networkConfigGateway
      , "Address" .= networkConfigAddress
      , "IPPrefixLen" .= networkConfigIpPrefixLen
      , "MacAddress" .= networkConfigMacAddress
      , "PortMapping" .= networkConfigPortMapping
      , "Ports" .= networkConfigPorts
      ]


-- | Construct a value of type 'NetworkConfig' (by applying it's required fields, if any)
mkNetworkConfig
  :: NetworkConfig
mkNetworkConfig =
  NetworkConfig
  { networkConfigBridge = Nothing
  , networkConfigGateway = Nothing
  , networkConfigAddress = Nothing
  , networkConfigIpPrefixLen = Nothing
  , networkConfigMacAddress = Nothing
  , networkConfigPortMapping = Nothing
  , networkConfigPorts = Nothing
  }

-- ** NetworkContainer
-- | NetworkContainer
data NetworkContainer = NetworkContainer
  { networkContainerName :: !(Maybe Text) -- ^ "Name"
  , networkContainerEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , networkContainerMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  , networkContainerIPv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , networkContainerIPv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkContainer
instance A.FromJSON NetworkContainer where
  parseJSON = A.withObject "NetworkContainer" $ \o ->
    NetworkContainer
      <$> (o .:? "Name")
      <*> (o .:? "EndpointID")
      <*> (o .:? "MacAddress")
      <*> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")

-- | ToJSON NetworkContainer
instance A.ToJSON NetworkContainer where
  toJSON NetworkContainer {..} =
   _omitNulls
      [ "Name" .= networkContainerName
      , "EndpointID" .= networkContainerEndpointId
      , "MacAddress" .= networkContainerMacAddress
      , "IPv4Address" .= networkContainerIPv4Address
      , "IPv6Address" .= networkContainerIPv6Address
      ]


-- | Construct a value of type 'NetworkContainer' (by applying it's required fields, if any)
mkNetworkContainer
  :: NetworkContainer
mkNetworkContainer =
  NetworkContainer
  { networkContainerName = Nothing
  , networkContainerEndpointId = Nothing
  , networkContainerMacAddress = Nothing
  , networkContainerIPv4Address = Nothing
  , networkContainerIPv6Address = Nothing
  }

-- ** Node
-- | Node
data Node = Node
  { nodeId :: !(Maybe Text) -- ^ "ID"
  , nodeVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , nodeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , nodeUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , nodeSpec :: !(Maybe NodeSpec) -- ^ "Spec"
  , nodeDescription :: !(Maybe NodeDescription) -- ^ "Description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Node
instance A.FromJSON Node where
  parseJSON = A.withObject "Node" $ \o ->
    Node
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Description")

-- | ToJSON Node
instance A.ToJSON Node where
  toJSON Node {..} =
   _omitNulls
      [ "ID" .= nodeId
      , "Version" .= nodeVersion
      , "CreatedAt" .= nodeCreatedAt
      , "UpdatedAt" .= nodeUpdatedAt
      , "Spec" .= nodeSpec
      , "Description" .= nodeDescription
      ]


-- | Construct a value of type 'Node' (by applying it's required fields, if any)
mkNode
  :: Node
mkNode =
  Node
  { nodeId = Nothing
  , nodeVersion = Nothing
  , nodeCreatedAt = Nothing
  , nodeUpdatedAt = Nothing
  , nodeSpec = Nothing
  , nodeDescription = Nothing
  }

-- ** NodeDescription
-- | NodeDescription
data NodeDescription = NodeDescription
  { nodeDescriptionHostname :: !(Maybe Text) -- ^ "Hostname"
  , nodeDescriptionPlatform :: !(Maybe NodeDescriptionPlatform) -- ^ "Platform"
  , nodeDescriptionResources :: !(Maybe NodeDescriptionResources) -- ^ "Resources"
  , nodeDescriptionEngine :: !(Maybe NodeDescriptionEngine) -- ^ "Engine"
  , nodeDescriptionTlsInfo :: !(Maybe SwarmSpec) -- ^ "TLSInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescription
instance A.FromJSON NodeDescription where
  parseJSON = A.withObject "NodeDescription" $ \o ->
    NodeDescription
      <$> (o .:? "Hostname")
      <*> (o .:? "Platform")
      <*> (o .:? "Resources")
      <*> (o .:? "Engine")
      <*> (o .:? "TLSInfo")

-- | ToJSON NodeDescription
instance A.ToJSON NodeDescription where
  toJSON NodeDescription {..} =
   _omitNulls
      [ "Hostname" .= nodeDescriptionHostname
      , "Platform" .= nodeDescriptionPlatform
      , "Resources" .= nodeDescriptionResources
      , "Engine" .= nodeDescriptionEngine
      , "TLSInfo" .= nodeDescriptionTlsInfo
      ]


-- | Construct a value of type 'NodeDescription' (by applying it's required fields, if any)
mkNodeDescription
  :: NodeDescription
mkNodeDescription =
  NodeDescription
  { nodeDescriptionHostname = Nothing
  , nodeDescriptionPlatform = Nothing
  , nodeDescriptionResources = Nothing
  , nodeDescriptionEngine = Nothing
  , nodeDescriptionTlsInfo = Nothing
  }

-- ** NodeDescriptionEngine
-- | NodeDescriptionEngine
data NodeDescriptionEngine = NodeDescriptionEngine
  { nodeDescriptionEngineEngineVersion :: !(Maybe Text) -- ^ "EngineVersion"
  , nodeDescriptionEngineLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  , nodeDescriptionEnginePlugins :: !(Maybe [NodeDescriptionEnginePlugins]) -- ^ "Plugins"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionEngine
instance A.FromJSON NodeDescriptionEngine where
  parseJSON = A.withObject "NodeDescriptionEngine" $ \o ->
    NodeDescriptionEngine
      <$> (o .:? "EngineVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "Plugins")

-- | ToJSON NodeDescriptionEngine
instance A.ToJSON NodeDescriptionEngine where
  toJSON NodeDescriptionEngine {..} =
   _omitNulls
      [ "EngineVersion" .= nodeDescriptionEngineEngineVersion
      , "Labels" .= nodeDescriptionEngineLabels
      , "Plugins" .= nodeDescriptionEnginePlugins
      ]


-- | Construct a value of type 'NodeDescriptionEngine' (by applying it's required fields, if any)
mkNodeDescriptionEngine
  :: NodeDescriptionEngine
mkNodeDescriptionEngine =
  NodeDescriptionEngine
  { nodeDescriptionEngineEngineVersion = Nothing
  , nodeDescriptionEngineLabels = Nothing
  , nodeDescriptionEnginePlugins = Nothing
  }

-- ** NodeDescriptionEnginePlugins
-- | NodeDescriptionEnginePlugins
data NodeDescriptionEnginePlugins = NodeDescriptionEnginePlugins
  { nodeDescriptionEnginePluginsType :: !(Maybe Text) -- ^ "Type"
  , nodeDescriptionEnginePluginsName :: !(Maybe Text) -- ^ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionEnginePlugins
instance A.FromJSON NodeDescriptionEnginePlugins where
  parseJSON = A.withObject "NodeDescriptionEnginePlugins" $ \o ->
    NodeDescriptionEnginePlugins
      <$> (o .:? "Type")
      <*> (o .:? "Name")

-- | ToJSON NodeDescriptionEnginePlugins
instance A.ToJSON NodeDescriptionEnginePlugins where
  toJSON NodeDescriptionEnginePlugins {..} =
   _omitNulls
      [ "Type" .= nodeDescriptionEnginePluginsType
      , "Name" .= nodeDescriptionEnginePluginsName
      ]


-- | Construct a value of type 'NodeDescriptionEnginePlugins' (by applying it's required fields, if any)
mkNodeDescriptionEnginePlugins
  :: NodeDescriptionEnginePlugins
mkNodeDescriptionEnginePlugins =
  NodeDescriptionEnginePlugins
  { nodeDescriptionEnginePluginsType = Nothing
  , nodeDescriptionEnginePluginsName = Nothing
  }

-- ** NodeDescriptionPlatform
-- | NodeDescriptionPlatform
data NodeDescriptionPlatform = NodeDescriptionPlatform
  { nodeDescriptionPlatformArchitecture :: !(Maybe Text) -- ^ "Architecture"
  , nodeDescriptionPlatformOs :: !(Maybe Text) -- ^ "OS"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionPlatform
instance A.FromJSON NodeDescriptionPlatform where
  parseJSON = A.withObject "NodeDescriptionPlatform" $ \o ->
    NodeDescriptionPlatform
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")

-- | ToJSON NodeDescriptionPlatform
instance A.ToJSON NodeDescriptionPlatform where
  toJSON NodeDescriptionPlatform {..} =
   _omitNulls
      [ "Architecture" .= nodeDescriptionPlatformArchitecture
      , "OS" .= nodeDescriptionPlatformOs
      ]


-- | Construct a value of type 'NodeDescriptionPlatform' (by applying it's required fields, if any)
mkNodeDescriptionPlatform
  :: NodeDescriptionPlatform
mkNodeDescriptionPlatform =
  NodeDescriptionPlatform
  { nodeDescriptionPlatformArchitecture = Nothing
  , nodeDescriptionPlatformOs = Nothing
  }

-- ** NodeDescriptionResources
-- | NodeDescriptionResources
data NodeDescriptionResources = NodeDescriptionResources
  { nodeDescriptionResourcesNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs"
  , nodeDescriptionResourcesMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescriptionResources
instance A.FromJSON NodeDescriptionResources where
  parseJSON = A.withObject "NodeDescriptionResources" $ \o ->
    NodeDescriptionResources
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON NodeDescriptionResources
instance A.ToJSON NodeDescriptionResources where
  toJSON NodeDescriptionResources {..} =
   _omitNulls
      [ "NanoCPUs" .= nodeDescriptionResourcesNanoCpUs
      , "MemoryBytes" .= nodeDescriptionResourcesMemoryBytes
      ]


-- | Construct a value of type 'NodeDescriptionResources' (by applying it's required fields, if any)
mkNodeDescriptionResources
  :: NodeDescriptionResources
mkNodeDescriptionResources =
  NodeDescriptionResources
  { nodeDescriptionResourcesNanoCpUs = Nothing
  , nodeDescriptionResourcesMemoryBytes = Nothing
  }

-- ** NodeSpec
-- | NodeSpec
data NodeSpec = NodeSpec
  { nodeSpecName :: !(Maybe Text) -- ^ "Name" - Name for the node.
  , nodeSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , nodeSpecRole :: !(Maybe E'Role) -- ^ "Role" - Role of the node.
  , nodeSpecAvailability :: !(Maybe E'Availability) -- ^ "Availability" - Availability of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeSpec
instance A.FromJSON NodeSpec where
  parseJSON = A.withObject "NodeSpec" $ \o ->
    NodeSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Role")
      <*> (o .:? "Availability")

-- | ToJSON NodeSpec
instance A.ToJSON NodeSpec where
  toJSON NodeSpec {..} =
   _omitNulls
      [ "Name" .= nodeSpecName
      , "Labels" .= nodeSpecLabels
      , "Role" .= nodeSpecRole
      , "Availability" .= nodeSpecAvailability
      ]


-- | Construct a value of type 'NodeSpec' (by applying it's required fields, if any)
mkNodeSpec
  :: NodeSpec
mkNodeSpec =
  NodeSpec
  { nodeSpecName = Nothing
  , nodeSpecLabels = Nothing
  , nodeSpecRole = Nothing
  , nodeSpecAvailability = Nothing
  }

-- ** ObjectVersion
-- | ObjectVersion
-- The version number of the object such as node, service, etc. This is needed to avoid conflicting writes. The client must send the version number along with the modified specification when updating these objects. This approach ensures safe concurrency and determinism in that the change on the object may not be applied if the version number has changed from the last read. In other words, if two update requests specify the same base version, only one of the requests can succeed. As a result, two separate update requests that happen at the same time will not unintentially overwrite each other. 
data ObjectVersion = ObjectVersion
  { objectVersionIndex :: !(Maybe Integer) -- ^ "Index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ObjectVersion
instance A.FromJSON ObjectVersion where
  parseJSON = A.withObject "ObjectVersion" $ \o ->
    ObjectVersion
      <$> (o .:? "Index")

-- | ToJSON ObjectVersion
instance A.ToJSON ObjectVersion where
  toJSON ObjectVersion {..} =
   _omitNulls
      [ "Index" .= objectVersionIndex
      ]


-- | Construct a value of type 'ObjectVersion' (by applying it's required fields, if any)
mkObjectVersion
  :: ObjectVersion
mkObjectVersion =
  ObjectVersion
  { objectVersionIndex = Nothing
  }

-- ** Plugin
-- | Plugin
-- A plugin for the Engine API
data Plugin = Plugin
  { pluginId :: !(Maybe Text) -- ^ "Id"
  , pluginName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnabled :: !(Bool) -- ^ /Required/ "Enabled" - True if the plugin is running. False if the plugin is not running, only installed.
  , pluginSettings :: !(PluginSettings) -- ^ /Required/ "Settings"
  , pluginPluginReference :: !(Maybe Text) -- ^ "PluginReference" - plugin remote reference used to push/pull the plugin
  , pluginConfig :: !(PluginConfig) -- ^ /Required/ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Plugin
instance A.FromJSON Plugin where
  parseJSON = A.withObject "Plugin" $ \o ->
    Plugin
      <$> (o .:? "Id")
      <*> (o .:  "Name")
      <*> (o .:  "Enabled")
      <*> (o .:  "Settings")
      <*> (o .:? "PluginReference")
      <*> (o .:  "Config")

-- | ToJSON Plugin
instance A.ToJSON Plugin where
  toJSON Plugin {..} =
   _omitNulls
      [ "Id" .= pluginId
      , "Name" .= pluginName
      , "Enabled" .= pluginEnabled
      , "Settings" .= pluginSettings
      , "PluginReference" .= pluginPluginReference
      , "Config" .= pluginConfig
      ]


-- | Construct a value of type 'Plugin' (by applying it's required fields, if any)
mkPlugin
  :: Text -- ^ 'pluginName' 
  -> Bool -- ^ 'pluginEnabled': True if the plugin is running. False if the plugin is not running, only installed.
  -> PluginSettings -- ^ 'pluginSettings' 
  -> PluginConfig -- ^ 'pluginConfig' 
  -> Plugin
mkPlugin pluginName pluginEnabled pluginSettings pluginConfig =
  Plugin
  { pluginId = Nothing
  , pluginName
  , pluginEnabled
  , pluginSettings
  , pluginPluginReference = Nothing
  , pluginConfig
  }

-- ** PluginConfig
-- | PluginConfig
-- The config of a plugin.
data PluginConfig = PluginConfig
  { pluginConfigDockerVersion :: !(Maybe Text) -- ^ "DockerVersion" - Docker Version used to create the plugin
  , pluginConfigDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigDocumentation :: !(Text) -- ^ /Required/ "Documentation"
  , pluginConfigInterface :: !(PluginConfigInterface) -- ^ /Required/ "Interface"
  , pluginConfigEntrypoint :: !([Text]) -- ^ /Required/ "Entrypoint"
  , pluginConfigWorkDir :: !(Text) -- ^ /Required/ "WorkDir"
  , pluginConfigUser :: !(Maybe PluginConfigUser) -- ^ "User"
  , pluginConfigNetwork :: !(PluginConfigNetwork) -- ^ /Required/ "Network"
  , pluginConfigLinux :: !(PluginConfigLinux) -- ^ /Required/ "Linux"
  , pluginConfigPropagatedMount :: !(Text) -- ^ /Required/ "PropagatedMount"
  , pluginConfigIpcHost :: !(Bool) -- ^ /Required/ "IpcHost"
  , pluginConfigPidHost :: !(Bool) -- ^ /Required/ "PidHost"
  , pluginConfigMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginConfigEnv :: !([PluginEnv]) -- ^ /Required/ "Env"
  , pluginConfigArgs :: !(PluginConfigArgs) -- ^ /Required/ "Args"
  , pluginConfigRootfs :: !(Maybe PluginConfigRootfs) -- ^ "rootfs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfig
instance A.FromJSON PluginConfig where
  parseJSON = A.withObject "PluginConfig" $ \o ->
    PluginConfig
      <$> (o .:? "DockerVersion")
      <*> (o .:  "Description")
      <*> (o .:  "Documentation")
      <*> (o .:  "Interface")
      <*> (o .:  "Entrypoint")
      <*> (o .:  "WorkDir")
      <*> (o .:? "User")
      <*> (o .:  "Network")
      <*> (o .:  "Linux")
      <*> (o .:  "PropagatedMount")
      <*> (o .:  "IpcHost")
      <*> (o .:  "PidHost")
      <*> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:? "rootfs")

-- | ToJSON PluginConfig
instance A.ToJSON PluginConfig where
  toJSON PluginConfig {..} =
   _omitNulls
      [ "DockerVersion" .= pluginConfigDockerVersion
      , "Description" .= pluginConfigDescription
      , "Documentation" .= pluginConfigDocumentation
      , "Interface" .= pluginConfigInterface
      , "Entrypoint" .= pluginConfigEntrypoint
      , "WorkDir" .= pluginConfigWorkDir
      , "User" .= pluginConfigUser
      , "Network" .= pluginConfigNetwork
      , "Linux" .= pluginConfigLinux
      , "PropagatedMount" .= pluginConfigPropagatedMount
      , "IpcHost" .= pluginConfigIpcHost
      , "PidHost" .= pluginConfigPidHost
      , "Mounts" .= pluginConfigMounts
      , "Env" .= pluginConfigEnv
      , "Args" .= pluginConfigArgs
      , "rootfs" .= pluginConfigRootfs
      ]


-- | Construct a value of type 'PluginConfig' (by applying it's required fields, if any)
mkPluginConfig
  :: Text -- ^ 'pluginConfigDescription' 
  -> Text -- ^ 'pluginConfigDocumentation' 
  -> PluginConfigInterface -- ^ 'pluginConfigInterface' 
  -> [Text] -- ^ 'pluginConfigEntrypoint' 
  -> Text -- ^ 'pluginConfigWorkDir' 
  -> PluginConfigNetwork -- ^ 'pluginConfigNetwork' 
  -> PluginConfigLinux -- ^ 'pluginConfigLinux' 
  -> Text -- ^ 'pluginConfigPropagatedMount' 
  -> Bool -- ^ 'pluginConfigIpcHost' 
  -> Bool -- ^ 'pluginConfigPidHost' 
  -> [PluginMount] -- ^ 'pluginConfigMounts' 
  -> [PluginEnv] -- ^ 'pluginConfigEnv' 
  -> PluginConfigArgs -- ^ 'pluginConfigArgs' 
  -> PluginConfig
mkPluginConfig pluginConfigDescription pluginConfigDocumentation pluginConfigInterface pluginConfigEntrypoint pluginConfigWorkDir pluginConfigNetwork pluginConfigLinux pluginConfigPropagatedMount pluginConfigIpcHost pluginConfigPidHost pluginConfigMounts pluginConfigEnv pluginConfigArgs =
  PluginConfig
  { pluginConfigDockerVersion = Nothing
  , pluginConfigDescription
  , pluginConfigDocumentation
  , pluginConfigInterface
  , pluginConfigEntrypoint
  , pluginConfigWorkDir
  , pluginConfigUser = Nothing
  , pluginConfigNetwork
  , pluginConfigLinux
  , pluginConfigPropagatedMount
  , pluginConfigIpcHost
  , pluginConfigPidHost
  , pluginConfigMounts
  , pluginConfigEnv
  , pluginConfigArgs
  , pluginConfigRootfs = Nothing
  }

-- ** PluginConfigArgs
-- | PluginConfigArgs
data PluginConfigArgs = PluginConfigArgs
  { pluginConfigArgsName :: !(Text) -- ^ /Required/ "Name"
  , pluginConfigArgsDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigArgsSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginConfigArgsValue :: !([Text]) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigArgs
instance A.FromJSON PluginConfigArgs where
  parseJSON = A.withObject "PluginConfigArgs" $ \o ->
    PluginConfigArgs
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginConfigArgs
instance A.ToJSON PluginConfigArgs where
  toJSON PluginConfigArgs {..} =
   _omitNulls
      [ "Name" .= pluginConfigArgsName
      , "Description" .= pluginConfigArgsDescription
      , "Settable" .= pluginConfigArgsSettable
      , "Value" .= pluginConfigArgsValue
      ]


-- | Construct a value of type 'PluginConfigArgs' (by applying it's required fields, if any)
mkPluginConfigArgs
  :: Text -- ^ 'pluginConfigArgsName' 
  -> Text -- ^ 'pluginConfigArgsDescription' 
  -> [Text] -- ^ 'pluginConfigArgsSettable' 
  -> [Text] -- ^ 'pluginConfigArgsValue' 
  -> PluginConfigArgs
mkPluginConfigArgs pluginConfigArgsName pluginConfigArgsDescription pluginConfigArgsSettable pluginConfigArgsValue =
  PluginConfigArgs
  { pluginConfigArgsName
  , pluginConfigArgsDescription
  , pluginConfigArgsSettable
  , pluginConfigArgsValue
  }

-- ** PluginConfigInterface
-- | PluginConfigInterface
-- The interface between Docker and the plugin
data PluginConfigInterface = PluginConfigInterface
  { pluginConfigInterfaceTypes :: !([PluginInterfaceType]) -- ^ /Required/ "Types"
  , pluginConfigInterfaceSocket :: !(Text) -- ^ /Required/ "Socket"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigInterface
instance A.FromJSON PluginConfigInterface where
  parseJSON = A.withObject "PluginConfigInterface" $ \o ->
    PluginConfigInterface
      <$> (o .:  "Types")
      <*> (o .:  "Socket")

-- | ToJSON PluginConfigInterface
instance A.ToJSON PluginConfigInterface where
  toJSON PluginConfigInterface {..} =
   _omitNulls
      [ "Types" .= pluginConfigInterfaceTypes
      , "Socket" .= pluginConfigInterfaceSocket
      ]


-- | Construct a value of type 'PluginConfigInterface' (by applying it's required fields, if any)
mkPluginConfigInterface
  :: [PluginInterfaceType] -- ^ 'pluginConfigInterfaceTypes' 
  -> Text -- ^ 'pluginConfigInterfaceSocket' 
  -> PluginConfigInterface
mkPluginConfigInterface pluginConfigInterfaceTypes pluginConfigInterfaceSocket =
  PluginConfigInterface
  { pluginConfigInterfaceTypes
  , pluginConfigInterfaceSocket
  }

-- ** PluginConfigLinux
-- | PluginConfigLinux
data PluginConfigLinux = PluginConfigLinux
  { pluginConfigLinuxCapabilities :: !([Text]) -- ^ /Required/ "Capabilities"
  , pluginConfigLinuxAllowAllDevices :: !(Bool) -- ^ /Required/ "AllowAllDevices"
  , pluginConfigLinuxDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigLinux
instance A.FromJSON PluginConfigLinux where
  parseJSON = A.withObject "PluginConfigLinux" $ \o ->
    PluginConfigLinux
      <$> (o .:  "Capabilities")
      <*> (o .:  "AllowAllDevices")
      <*> (o .:  "Devices")

-- | ToJSON PluginConfigLinux
instance A.ToJSON PluginConfigLinux where
  toJSON PluginConfigLinux {..} =
   _omitNulls
      [ "Capabilities" .= pluginConfigLinuxCapabilities
      , "AllowAllDevices" .= pluginConfigLinuxAllowAllDevices
      , "Devices" .= pluginConfigLinuxDevices
      ]


-- | Construct a value of type 'PluginConfigLinux' (by applying it's required fields, if any)
mkPluginConfigLinux
  :: [Text] -- ^ 'pluginConfigLinuxCapabilities' 
  -> Bool -- ^ 'pluginConfigLinuxAllowAllDevices' 
  -> [PluginDevice] -- ^ 'pluginConfigLinuxDevices' 
  -> PluginConfigLinux
mkPluginConfigLinux pluginConfigLinuxCapabilities pluginConfigLinuxAllowAllDevices pluginConfigLinuxDevices =
  PluginConfigLinux
  { pluginConfigLinuxCapabilities
  , pluginConfigLinuxAllowAllDevices
  , pluginConfigLinuxDevices
  }

-- ** PluginConfigNetwork
-- | PluginConfigNetwork
data PluginConfigNetwork = PluginConfigNetwork
  { pluginConfigNetworkType :: !(Text) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigNetwork
instance A.FromJSON PluginConfigNetwork where
  parseJSON = A.withObject "PluginConfigNetwork" $ \o ->
    PluginConfigNetwork
      <$> (o .:  "Type")

-- | ToJSON PluginConfigNetwork
instance A.ToJSON PluginConfigNetwork where
  toJSON PluginConfigNetwork {..} =
   _omitNulls
      [ "Type" .= pluginConfigNetworkType
      ]


-- | Construct a value of type 'PluginConfigNetwork' (by applying it's required fields, if any)
mkPluginConfigNetwork
  :: Text -- ^ 'pluginConfigNetworkType' 
  -> PluginConfigNetwork
mkPluginConfigNetwork pluginConfigNetworkType =
  PluginConfigNetwork
  { pluginConfigNetworkType
  }

-- ** PluginConfigRootfs
-- | PluginConfigRootfs
data PluginConfigRootfs = PluginConfigRootfs
  { pluginConfigRootfsType :: !(Maybe Text) -- ^ "type"
  , pluginConfigRootfsDiffIds :: !(Maybe [Text]) -- ^ "diff_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigRootfs
instance A.FromJSON PluginConfigRootfs where
  parseJSON = A.withObject "PluginConfigRootfs" $ \o ->
    PluginConfigRootfs
      <$> (o .:? "type")
      <*> (o .:? "diff_ids")

-- | ToJSON PluginConfigRootfs
instance A.ToJSON PluginConfigRootfs where
  toJSON PluginConfigRootfs {..} =
   _omitNulls
      [ "type" .= pluginConfigRootfsType
      , "diff_ids" .= pluginConfigRootfsDiffIds
      ]


-- | Construct a value of type 'PluginConfigRootfs' (by applying it's required fields, if any)
mkPluginConfigRootfs
  :: PluginConfigRootfs
mkPluginConfigRootfs =
  PluginConfigRootfs
  { pluginConfigRootfsType = Nothing
  , pluginConfigRootfsDiffIds = Nothing
  }

-- ** PluginConfigUser
-- | PluginConfigUser
data PluginConfigUser = PluginConfigUser
  { pluginConfigUserUid :: !(Maybe Int) -- ^ "UID"
  , pluginConfigUserGid :: !(Maybe Int) -- ^ "GID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigUser
instance A.FromJSON PluginConfigUser where
  parseJSON = A.withObject "PluginConfigUser" $ \o ->
    PluginConfigUser
      <$> (o .:? "UID")
      <*> (o .:? "GID")

-- | ToJSON PluginConfigUser
instance A.ToJSON PluginConfigUser where
  toJSON PluginConfigUser {..} =
   _omitNulls
      [ "UID" .= pluginConfigUserUid
      , "GID" .= pluginConfigUserGid
      ]


-- | Construct a value of type 'PluginConfigUser' (by applying it's required fields, if any)
mkPluginConfigUser
  :: PluginConfigUser
mkPluginConfigUser =
  PluginConfigUser
  { pluginConfigUserUid = Nothing
  , pluginConfigUserGid = Nothing
  }

-- ** PluginDevice
-- | PluginDevice
data PluginDevice = PluginDevice
  { pluginDeviceName :: !(Text) -- ^ /Required/ "Name"
  , pluginDeviceDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginDeviceSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginDevicePath :: !(Text) -- ^ /Required/ "Path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginDevice
instance A.FromJSON PluginDevice where
  parseJSON = A.withObject "PluginDevice" $ \o ->
    PluginDevice
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Path")

-- | ToJSON PluginDevice
instance A.ToJSON PluginDevice where
  toJSON PluginDevice {..} =
   _omitNulls
      [ "Name" .= pluginDeviceName
      , "Description" .= pluginDeviceDescription
      , "Settable" .= pluginDeviceSettable
      , "Path" .= pluginDevicePath
      ]


-- | Construct a value of type 'PluginDevice' (by applying it's required fields, if any)
mkPluginDevice
  :: Text -- ^ 'pluginDeviceName' 
  -> Text -- ^ 'pluginDeviceDescription' 
  -> [Text] -- ^ 'pluginDeviceSettable' 
  -> Text -- ^ 'pluginDevicePath' 
  -> PluginDevice
mkPluginDevice pluginDeviceName pluginDeviceDescription pluginDeviceSettable pluginDevicePath =
  PluginDevice
  { pluginDeviceName
  , pluginDeviceDescription
  , pluginDeviceSettable
  , pluginDevicePath
  }

-- ** PluginEnv
-- | PluginEnv
data PluginEnv = PluginEnv
  { pluginEnvName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnvDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginEnvSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginEnvValue :: !(Text) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginEnv
instance A.FromJSON PluginEnv where
  parseJSON = A.withObject "PluginEnv" $ \o ->
    PluginEnv
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginEnv
instance A.ToJSON PluginEnv where
  toJSON PluginEnv {..} =
   _omitNulls
      [ "Name" .= pluginEnvName
      , "Description" .= pluginEnvDescription
      , "Settable" .= pluginEnvSettable
      , "Value" .= pluginEnvValue
      ]


-- | Construct a value of type 'PluginEnv' (by applying it's required fields, if any)
mkPluginEnv
  :: Text -- ^ 'pluginEnvName' 
  -> Text -- ^ 'pluginEnvDescription' 
  -> [Text] -- ^ 'pluginEnvSettable' 
  -> Text -- ^ 'pluginEnvValue' 
  -> PluginEnv
mkPluginEnv pluginEnvName pluginEnvDescription pluginEnvSettable pluginEnvValue =
  PluginEnv
  { pluginEnvName
  , pluginEnvDescription
  , pluginEnvSettable
  , pluginEnvValue
  }

-- ** PluginInterfaceType
-- | PluginInterfaceType
data PluginInterfaceType = PluginInterfaceType
  { pluginInterfaceTypePrefix :: !(Text) -- ^ /Required/ "Prefix"
  , pluginInterfaceTypeCapability :: !(Text) -- ^ /Required/ "Capability"
  , pluginInterfaceTypeVersion :: !(Text) -- ^ /Required/ "Version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginInterfaceType
instance A.FromJSON PluginInterfaceType where
  parseJSON = A.withObject "PluginInterfaceType" $ \o ->
    PluginInterfaceType
      <$> (o .:  "Prefix")
      <*> (o .:  "Capability")
      <*> (o .:  "Version")

-- | ToJSON PluginInterfaceType
instance A.ToJSON PluginInterfaceType where
  toJSON PluginInterfaceType {..} =
   _omitNulls
      [ "Prefix" .= pluginInterfaceTypePrefix
      , "Capability" .= pluginInterfaceTypeCapability
      , "Version" .= pluginInterfaceTypeVersion
      ]


-- | Construct a value of type 'PluginInterfaceType' (by applying it's required fields, if any)
mkPluginInterfaceType
  :: Text -- ^ 'pluginInterfaceTypePrefix' 
  -> Text -- ^ 'pluginInterfaceTypeCapability' 
  -> Text -- ^ 'pluginInterfaceTypeVersion' 
  -> PluginInterfaceType
mkPluginInterfaceType pluginInterfaceTypePrefix pluginInterfaceTypeCapability pluginInterfaceTypeVersion =
  PluginInterfaceType
  { pluginInterfaceTypePrefix
  , pluginInterfaceTypeCapability
  , pluginInterfaceTypeVersion
  }

-- ** PluginMount
-- | PluginMount
data PluginMount = PluginMount
  { pluginMountName :: !(Text) -- ^ /Required/ "Name"
  , pluginMountDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginMountSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginMountSource :: !(Text) -- ^ /Required/ "Source"
  , pluginMountDestination :: !(Text) -- ^ /Required/ "Destination"
  , pluginMountType :: !(Text) -- ^ /Required/ "Type"
  , pluginMountOptions :: !([Text]) -- ^ /Required/ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginMount
instance A.FromJSON PluginMount where
  parseJSON = A.withObject "PluginMount" $ \o ->
    PluginMount
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Source")
      <*> (o .:  "Destination")
      <*> (o .:  "Type")
      <*> (o .:  "Options")

-- | ToJSON PluginMount
instance A.ToJSON PluginMount where
  toJSON PluginMount {..} =
   _omitNulls
      [ "Name" .= pluginMountName
      , "Description" .= pluginMountDescription
      , "Settable" .= pluginMountSettable
      , "Source" .= pluginMountSource
      , "Destination" .= pluginMountDestination
      , "Type" .= pluginMountType
      , "Options" .= pluginMountOptions
      ]


-- | Construct a value of type 'PluginMount' (by applying it's required fields, if any)
mkPluginMount
  :: Text -- ^ 'pluginMountName' 
  -> Text -- ^ 'pluginMountDescription' 
  -> [Text] -- ^ 'pluginMountSettable' 
  -> Text -- ^ 'pluginMountSource' 
  -> Text -- ^ 'pluginMountDestination' 
  -> Text -- ^ 'pluginMountType' 
  -> [Text] -- ^ 'pluginMountOptions' 
  -> PluginMount
mkPluginMount pluginMountName pluginMountDescription pluginMountSettable pluginMountSource pluginMountDestination pluginMountType pluginMountOptions =
  PluginMount
  { pluginMountName
  , pluginMountDescription
  , pluginMountSettable
  , pluginMountSource
  , pluginMountDestination
  , pluginMountType
  , pluginMountOptions
  }

-- ** PluginSettings
-- | PluginSettings
-- Settings that can be modified by users.
data PluginSettings = PluginSettings
  { pluginSettingsMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginSettingsEnv :: !([Text]) -- ^ /Required/ "Env"
  , pluginSettingsArgs :: !([Text]) -- ^ /Required/ "Args"
  , pluginSettingsDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginSettings
instance A.FromJSON PluginSettings where
  parseJSON = A.withObject "PluginSettings" $ \o ->
    PluginSettings
      <$> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:  "Devices")

-- | ToJSON PluginSettings
instance A.ToJSON PluginSettings where
  toJSON PluginSettings {..} =
   _omitNulls
      [ "Mounts" .= pluginSettingsMounts
      , "Env" .= pluginSettingsEnv
      , "Args" .= pluginSettingsArgs
      , "Devices" .= pluginSettingsDevices
      ]


-- | Construct a value of type 'PluginSettings' (by applying it's required fields, if any)
mkPluginSettings
  :: [PluginMount] -- ^ 'pluginSettingsMounts' 
  -> [Text] -- ^ 'pluginSettingsEnv' 
  -> [Text] -- ^ 'pluginSettingsArgs' 
  -> [PluginDevice] -- ^ 'pluginSettingsDevices' 
  -> PluginSettings
mkPluginSettings pluginSettingsMounts pluginSettingsEnv pluginSettingsArgs pluginSettingsDevices =
  PluginSettings
  { pluginSettingsMounts
  , pluginSettingsEnv
  , pluginSettingsArgs
  , pluginSettingsDevices
  }

-- ** Port
-- | Port
-- An open port on a container
data Port = Port
  { portIp :: !(Maybe Text) -- ^ "IP"
  , portPrivatePort :: !(Int) -- ^ /Required/ "PrivatePort" - Port on the container
  , portPublicPort :: !(Maybe Int) -- ^ "PublicPort" - Port exposed on the host
  , portType :: !(E'Type) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Port
instance A.FromJSON Port where
  parseJSON = A.withObject "Port" $ \o ->
    Port
      <$> (o .:? "IP")
      <*> (o .:  "PrivatePort")
      <*> (o .:? "PublicPort")
      <*> (o .:  "Type")

-- | ToJSON Port
instance A.ToJSON Port where
  toJSON Port {..} =
   _omitNulls
      [ "IP" .= portIp
      , "PrivatePort" .= portPrivatePort
      , "PublicPort" .= portPublicPort
      , "Type" .= portType
      ]


-- | Construct a value of type 'Port' (by applying it's required fields, if any)
mkPort
  :: Int -- ^ 'portPrivatePort': Port on the container
  -> E'Type -- ^ 'portType' 
  -> Port
mkPort portPrivatePort portType =
  Port
  { portIp = Nothing
  , portPrivatePort
  , portPublicPort = Nothing
  , portType
  }

-- ** ProcessConfig
-- | ProcessConfig
data ProcessConfig = ProcessConfig
  { processConfigPrivileged :: !(Maybe Bool) -- ^ "privileged"
  , processConfigUser :: !(Maybe Text) -- ^ "user"
  , processConfigTty :: !(Maybe Bool) -- ^ "tty"
  , processConfigEntrypoint :: !(Maybe Text) -- ^ "entrypoint"
  , processConfigArguments :: !(Maybe [Text]) -- ^ "arguments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessConfig
instance A.FromJSON ProcessConfig where
  parseJSON = A.withObject "ProcessConfig" $ \o ->
    ProcessConfig
      <$> (o .:? "privileged")
      <*> (o .:? "user")
      <*> (o .:? "tty")
      <*> (o .:? "entrypoint")
      <*> (o .:? "arguments")

-- | ToJSON ProcessConfig
instance A.ToJSON ProcessConfig where
  toJSON ProcessConfig {..} =
   _omitNulls
      [ "privileged" .= processConfigPrivileged
      , "user" .= processConfigUser
      , "tty" .= processConfigTty
      , "entrypoint" .= processConfigEntrypoint
      , "arguments" .= processConfigArguments
      ]


-- | Construct a value of type 'ProcessConfig' (by applying it's required fields, if any)
mkProcessConfig
  :: ProcessConfig
mkProcessConfig =
  ProcessConfig
  { processConfigPrivileged = Nothing
  , processConfigUser = Nothing
  , processConfigTty = Nothing
  , processConfigEntrypoint = Nothing
  , processConfigArguments = Nothing
  }

-- ** ProgressDetail
-- | ProgressDetail
data ProgressDetail = ProgressDetail
  { progressDetailCode :: !(Maybe Int) -- ^ "code"
  , progressDetailMessage :: !(Maybe Int) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgressDetail
instance A.FromJSON ProgressDetail where
  parseJSON = A.withObject "ProgressDetail" $ \o ->
    ProgressDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ProgressDetail
instance A.ToJSON ProgressDetail where
  toJSON ProgressDetail {..} =
   _omitNulls
      [ "code" .= progressDetailCode
      , "message" .= progressDetailMessage
      ]


-- | Construct a value of type 'ProgressDetail' (by applying it's required fields, if any)
mkProgressDetail
  :: ProgressDetail
mkProgressDetail =
  ProgressDetail
  { progressDetailCode = Nothing
  , progressDetailMessage = Nothing
  }

-- ** PushImageInfo
-- | PushImageInfo
data PushImageInfo = PushImageInfo
  { pushImageInfoError :: !(Maybe Text) -- ^ "error"
  , pushImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , pushImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , pushImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushImageInfo
instance A.FromJSON PushImageInfo where
  parseJSON = A.withObject "PushImageInfo" $ \o ->
    PushImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON PushImageInfo
instance A.ToJSON PushImageInfo where
  toJSON PushImageInfo {..} =
   _omitNulls
      [ "error" .= pushImageInfoError
      , "status" .= pushImageInfoStatus
      , "progress" .= pushImageInfoProgress
      , "progressDetail" .= pushImageInfoProgressDetail
      ]


-- | Construct a value of type 'PushImageInfo' (by applying it's required fields, if any)
mkPushImageInfo
  :: PushImageInfo
mkPushImageInfo =
  PushImageInfo
  { pushImageInfoError = Nothing
  , pushImageInfoStatus = Nothing
  , pushImageInfoProgress = Nothing
  , pushImageInfoProgressDetail = Nothing
  }

-- ** Resources
-- | Resources
-- A container's resources (cgroups config, ulimits, etc)
data Resources = Resources
  { resourcesCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , resourcesMemory :: !(Maybe Int) -- ^ "Memory" - Memory limit in bytes.
  , resourcesCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , resourcesBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , resourcesBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , resourcesBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , resourcesCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , resourcesCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , resourcesCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , resourcesDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , resourcesDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , resourcesDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , resourcesKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , resourcesMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , resourcesMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , resourcesMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , resourcesNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , resourcesOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , resourcesPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , resourcesUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , resourcesCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , resourcesIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Resources
instance A.FromJSON Resources where
  parseJSON = A.withObject "Resources" $ \o ->
    Resources
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCPUs")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")

-- | ToJSON Resources
instance A.ToJSON Resources where
  toJSON Resources {..} =
   _omitNulls
      [ "CpuShares" .= resourcesCpuShares
      , "Memory" .= resourcesMemory
      , "CgroupParent" .= resourcesCgroupParent
      , "BlkioWeight" .= resourcesBlkioWeight
      , "BlkioWeightDevice" .= resourcesBlkioWeightDevice
      , "BlkioDeviceReadBps" .= resourcesBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= resourcesBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= resourcesBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= resourcesBlkioDeviceWriteIOps
      , "CpuPeriod" .= resourcesCpuPeriod
      , "CpuQuota" .= resourcesCpuQuota
      , "CpuRealtimePeriod" .= resourcesCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= resourcesCpuRealtimeRuntime
      , "CpusetCpus" .= resourcesCpusetCpus
      , "CpusetMems" .= resourcesCpusetMems
      , "Devices" .= resourcesDevices
      , "DeviceCgroupRules" .= resourcesDeviceCgroupRules
      , "DiskQuota" .= resourcesDiskQuota
      , "KernelMemory" .= resourcesKernelMemory
      , "MemoryReservation" .= resourcesMemoryReservation
      , "MemorySwap" .= resourcesMemorySwap
      , "MemorySwappiness" .= resourcesMemorySwappiness
      , "NanoCPUs" .= resourcesNanoCpUs
      , "OomKillDisable" .= resourcesOomKillDisable
      , "PidsLimit" .= resourcesPidsLimit
      , "Ulimits" .= resourcesUlimits
      , "CpuCount" .= resourcesCpuCount
      , "CpuPercent" .= resourcesCpuPercent
      , "IOMaximumIOps" .= resourcesIoMaximumIOps
      , "IOMaximumBandwidth" .= resourcesIoMaximumBandwidth
      ]


-- | Construct a value of type 'Resources' (by applying it's required fields, if any)
mkResources
  :: Resources
mkResources =
  Resources
  { resourcesCpuShares = Nothing
  , resourcesMemory = Nothing
  , resourcesCgroupParent = Nothing
  , resourcesBlkioWeight = Nothing
  , resourcesBlkioWeightDevice = Nothing
  , resourcesBlkioDeviceReadBps = Nothing
  , resourcesBlkioDeviceWriteBps = Nothing
  , resourcesBlkioDeviceReadIOps = Nothing
  , resourcesBlkioDeviceWriteIOps = Nothing
  , resourcesCpuPeriod = Nothing
  , resourcesCpuQuota = Nothing
  , resourcesCpuRealtimePeriod = Nothing
  , resourcesCpuRealtimeRuntime = Nothing
  , resourcesCpusetCpus = Nothing
  , resourcesCpusetMems = Nothing
  , resourcesDevices = Nothing
  , resourcesDeviceCgroupRules = Nothing
  , resourcesDiskQuota = Nothing
  , resourcesKernelMemory = Nothing
  , resourcesMemoryReservation = Nothing
  , resourcesMemorySwap = Nothing
  , resourcesMemorySwappiness = Nothing
  , resourcesNanoCpUs = Nothing
  , resourcesOomKillDisable = Nothing
  , resourcesPidsLimit = Nothing
  , resourcesUlimits = Nothing
  , resourcesCpuCount = Nothing
  , resourcesCpuPercent = Nothing
  , resourcesIoMaximumIOps = Nothing
  , resourcesIoMaximumBandwidth = Nothing
  }

-- ** ResourcesBlkioWeightDevice
-- | ResourcesBlkioWeightDevice
data ResourcesBlkioWeightDevice = ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath :: !(Maybe Text) -- ^ "Path"
  , resourcesBlkioWeightDeviceWeight :: !(Maybe Int) -- ^ "Weight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesBlkioWeightDevice
instance A.FromJSON ResourcesBlkioWeightDevice where
  parseJSON = A.withObject "ResourcesBlkioWeightDevice" $ \o ->
    ResourcesBlkioWeightDevice
      <$> (o .:? "Path")
      <*> (o .:? "Weight")

-- | ToJSON ResourcesBlkioWeightDevice
instance A.ToJSON ResourcesBlkioWeightDevice where
  toJSON ResourcesBlkioWeightDevice {..} =
   _omitNulls
      [ "Path" .= resourcesBlkioWeightDevicePath
      , "Weight" .= resourcesBlkioWeightDeviceWeight
      ]


-- | Construct a value of type 'ResourcesBlkioWeightDevice' (by applying it's required fields, if any)
mkResourcesBlkioWeightDevice
  :: ResourcesBlkioWeightDevice
mkResourcesBlkioWeightDevice =
  ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath = Nothing
  , resourcesBlkioWeightDeviceWeight = Nothing
  }

-- ** ResourcesUlimits
-- | ResourcesUlimits
data ResourcesUlimits = ResourcesUlimits
  { resourcesUlimitsName :: !(Maybe Text) -- ^ "Name" - Name of ulimit
  , resourcesUlimitsSoft :: !(Maybe Int) -- ^ "Soft" - Soft limit
  , resourcesUlimitsHard :: !(Maybe Int) -- ^ "Hard" - Hard limit
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesUlimits
instance A.FromJSON ResourcesUlimits where
  parseJSON = A.withObject "ResourcesUlimits" $ \o ->
    ResourcesUlimits
      <$> (o .:? "Name")
      <*> (o .:? "Soft")
      <*> (o .:? "Hard")

-- | ToJSON ResourcesUlimits
instance A.ToJSON ResourcesUlimits where
  toJSON ResourcesUlimits {..} =
   _omitNulls
      [ "Name" .= resourcesUlimitsName
      , "Soft" .= resourcesUlimitsSoft
      , "Hard" .= resourcesUlimitsHard
      ]


-- | Construct a value of type 'ResourcesUlimits' (by applying it's required fields, if any)
mkResourcesUlimits
  :: ResourcesUlimits
mkResourcesUlimits =
  ResourcesUlimits
  { resourcesUlimitsName = Nothing
  , resourcesUlimitsSoft = Nothing
  , resourcesUlimitsHard = Nothing
  }

-- ** RestartPolicy
-- | RestartPolicy
-- The behavior to apply when the container exits. The default is not to restart.  An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server. 
data RestartPolicy = RestartPolicy
  { restartPolicyName :: !(Maybe E'Name) -- ^ "Name" - - Empty string means not to restart - &#x60;always&#x60; Always restart - &#x60;unless-stopped&#x60; Restart always except when the user has manually stopped the container - &#x60;on-failure&#x60; Restart only when the container exit code is non-zero 
  , restartPolicyMaximumRetryCount :: !(Maybe Int) -- ^ "MaximumRetryCount" - If &#x60;on-failure&#x60; is used, the number of times to retry before giving up
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RestartPolicy
instance A.FromJSON RestartPolicy where
  parseJSON = A.withObject "RestartPolicy" $ \o ->
    RestartPolicy
      <$> (o .:? "Name")
      <*> (o .:? "MaximumRetryCount")

-- | ToJSON RestartPolicy
instance A.ToJSON RestartPolicy where
  toJSON RestartPolicy {..} =
   _omitNulls
      [ "Name" .= restartPolicyName
      , "MaximumRetryCount" .= restartPolicyMaximumRetryCount
      ]


-- | Construct a value of type 'RestartPolicy' (by applying it's required fields, if any)
mkRestartPolicy
  :: RestartPolicy
mkRestartPolicy =
  RestartPolicy
  { restartPolicyName = Nothing
  , restartPolicyMaximumRetryCount = Nothing
  }

-- ** Secret
-- | Secret
data Secret = Secret
  { secretId :: !(Maybe Text) -- ^ "ID"
  , secretVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , secretCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , secretUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , secretSpec :: !(Maybe SecretSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Secret
instance A.FromJSON Secret where
  parseJSON = A.withObject "Secret" $ \o ->
    Secret
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Secret
instance A.ToJSON Secret where
  toJSON Secret {..} =
   _omitNulls
      [ "ID" .= secretId
      , "Version" .= secretVersion
      , "CreatedAt" .= secretCreatedAt
      , "UpdatedAt" .= secretUpdatedAt
      , "Spec" .= secretSpec
      ]


-- | Construct a value of type 'Secret' (by applying it's required fields, if any)
mkSecret
  :: Secret
mkSecret =
  Secret
  { secretId = Nothing
  , secretVersion = Nothing
  , secretCreatedAt = Nothing
  , secretUpdatedAt = Nothing
  , secretSpec = Nothing
  }

-- ** SecretSpec
-- | SecretSpec
data SecretSpec = SecretSpec
  { secretSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the secret.
  , secretSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , secretSpecData :: !(Maybe [Text]) -- ^ "Data" - Base64-url-safe-encoded secret data
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecretSpec
instance A.FromJSON SecretSpec where
  parseJSON = A.withObject "SecretSpec" $ \o ->
    SecretSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")

-- | ToJSON SecretSpec
instance A.ToJSON SecretSpec where
  toJSON SecretSpec {..} =
   _omitNulls
      [ "Name" .= secretSpecName
      , "Labels" .= secretSpecLabels
      , "Data" .= secretSpecData
      ]


-- | Construct a value of type 'SecretSpec' (by applying it's required fields, if any)
mkSecretSpec
  :: SecretSpec
mkSecretSpec =
  SecretSpec
  { secretSpecName = Nothing
  , secretSpecLabels = Nothing
  , secretSpecData = Nothing
  }

-- ** Service
-- | Service
data Service = Service
  { serviceId :: !(Maybe Text) -- ^ "ID"
  , serviceVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , serviceCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , serviceUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , serviceSpec :: !(Maybe ServiceSpec) -- ^ "Spec"
  , serviceEndpoint :: !(Maybe ServiceEndpoint) -- ^ "Endpoint"
  , serviceUpdateStatus :: !(Maybe ServiceUpdateStatus) -- ^ "UpdateStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Service
instance A.FromJSON Service where
  parseJSON = A.withObject "Service" $ \o ->
    Service
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Endpoint")
      <*> (o .:? "UpdateStatus")

-- | ToJSON Service
instance A.ToJSON Service where
  toJSON Service {..} =
   _omitNulls
      [ "ID" .= serviceId
      , "Version" .= serviceVersion
      , "CreatedAt" .= serviceCreatedAt
      , "UpdatedAt" .= serviceUpdatedAt
      , "Spec" .= serviceSpec
      , "Endpoint" .= serviceEndpoint
      , "UpdateStatus" .= serviceUpdateStatus
      ]


-- | Construct a value of type 'Service' (by applying it's required fields, if any)
mkService
  :: Service
mkService =
  Service
  { serviceId = Nothing
  , serviceVersion = Nothing
  , serviceCreatedAt = Nothing
  , serviceUpdatedAt = Nothing
  , serviceSpec = Nothing
  , serviceEndpoint = Nothing
  , serviceUpdateStatus = Nothing
  }

-- ** ServiceEndpoint
-- | ServiceEndpoint
data ServiceEndpoint = ServiceEndpoint
  { serviceEndpointSpec :: !(Maybe EndpointSpec) -- ^ "Spec"
  , serviceEndpointPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports"
  , serviceEndpointVirtualIPs :: !(Maybe [ServiceEndpointVirtualIPs]) -- ^ "VirtualIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpoint
instance A.FromJSON ServiceEndpoint where
  parseJSON = A.withObject "ServiceEndpoint" $ \o ->
    ServiceEndpoint
      <$> (o .:? "Spec")
      <*> (o .:? "Ports")
      <*> (o .:? "VirtualIPs")

-- | ToJSON ServiceEndpoint
instance A.ToJSON ServiceEndpoint where
  toJSON ServiceEndpoint {..} =
   _omitNulls
      [ "Spec" .= serviceEndpointSpec
      , "Ports" .= serviceEndpointPorts
      , "VirtualIPs" .= serviceEndpointVirtualIPs
      ]


-- | Construct a value of type 'ServiceEndpoint' (by applying it's required fields, if any)
mkServiceEndpoint
  :: ServiceEndpoint
mkServiceEndpoint =
  ServiceEndpoint
  { serviceEndpointSpec = Nothing
  , serviceEndpointPorts = Nothing
  , serviceEndpointVirtualIPs = Nothing
  }

-- ** ServiceEndpointVirtualIPs
-- | ServiceEndpointVirtualIPs
data ServiceEndpointVirtualIPs = ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , serviceEndpointVirtualIPsAddr :: !(Maybe Text) -- ^ "Addr"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpointVirtualIPs
instance A.FromJSON ServiceEndpointVirtualIPs where
  parseJSON = A.withObject "ServiceEndpointVirtualIPs" $ \o ->
    ServiceEndpointVirtualIPs
      <$> (o .:? "NetworkID")
      <*> (o .:? "Addr")

-- | ToJSON ServiceEndpointVirtualIPs
instance A.ToJSON ServiceEndpointVirtualIPs where
  toJSON ServiceEndpointVirtualIPs {..} =
   _omitNulls
      [ "NetworkID" .= serviceEndpointVirtualIPsNetworkId
      , "Addr" .= serviceEndpointVirtualIPsAddr
      ]


-- | Construct a value of type 'ServiceEndpointVirtualIPs' (by applying it's required fields, if any)
mkServiceEndpointVirtualIPs
  :: ServiceEndpointVirtualIPs
mkServiceEndpointVirtualIPs =
  ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId = Nothing
  , serviceEndpointVirtualIPsAddr = Nothing
  }

-- ** ServiceSpec
-- | ServiceSpec
-- User modifiable configuration for a service.
data ServiceSpec = ServiceSpec
  { serviceSpecName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceSpecTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceSpecMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceSpecUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceSpecRollbackConfig :: !(Maybe ServiceSpecRollbackConfig) -- ^ "RollbackConfig"
  , serviceSpecNetworks :: !(Maybe [TaskSpecNetworks]) -- ^ "Networks" - Array of network names or IDs to attach the service to.
  , serviceSpecEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpec
instance A.FromJSON ServiceSpec where
  parseJSON = A.withObject "ServiceSpec" $ \o ->
    ServiceSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "RollbackConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceSpec
instance A.ToJSON ServiceSpec where
  toJSON ServiceSpec {..} =
   _omitNulls
      [ "Name" .= serviceSpecName
      , "Labels" .= serviceSpecLabels
      , "TaskTemplate" .= serviceSpecTaskTemplate
      , "Mode" .= serviceSpecMode
      , "UpdateConfig" .= serviceSpecUpdateConfig
      , "RollbackConfig" .= serviceSpecRollbackConfig
      , "Networks" .= serviceSpecNetworks
      , "EndpointSpec" .= serviceSpecEndpointSpec
      ]


-- | Construct a value of type 'ServiceSpec' (by applying it's required fields, if any)
mkServiceSpec
  :: ServiceSpec
mkServiceSpec =
  ServiceSpec
  { serviceSpecName = Nothing
  , serviceSpecLabels = Nothing
  , serviceSpecTaskTemplate = Nothing
  , serviceSpecMode = Nothing
  , serviceSpecUpdateConfig = Nothing
  , serviceSpecRollbackConfig = Nothing
  , serviceSpecNetworks = Nothing
  , serviceSpecEndpointSpec = Nothing
  }

-- ** ServiceSpecMode
-- | ServiceSpecMode
-- Scheduling mode for the service.
data ServiceSpecMode = ServiceSpecMode
  { serviceSpecModeReplicated :: !(Maybe ServiceSpecModeReplicated) -- ^ "Replicated"
  , serviceSpecModeGlobal :: !(Maybe A.Value) -- ^ "Global"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecMode
instance A.FromJSON ServiceSpecMode where
  parseJSON = A.withObject "ServiceSpecMode" $ \o ->
    ServiceSpecMode
      <$> (o .:? "Replicated")
      <*> (o .:? "Global")

-- | ToJSON ServiceSpecMode
instance A.ToJSON ServiceSpecMode where
  toJSON ServiceSpecMode {..} =
   _omitNulls
      [ "Replicated" .= serviceSpecModeReplicated
      , "Global" .= serviceSpecModeGlobal
      ]


-- | Construct a value of type 'ServiceSpecMode' (by applying it's required fields, if any)
mkServiceSpecMode
  :: ServiceSpecMode
mkServiceSpecMode =
  ServiceSpecMode
  { serviceSpecModeReplicated = Nothing
  , serviceSpecModeGlobal = Nothing
  }

-- ** ServiceSpecModeReplicated
-- | ServiceSpecModeReplicated
data ServiceSpecModeReplicated = ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas :: !(Maybe Integer) -- ^ "Replicas"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecModeReplicated
instance A.FromJSON ServiceSpecModeReplicated where
  parseJSON = A.withObject "ServiceSpecModeReplicated" $ \o ->
    ServiceSpecModeReplicated
      <$> (o .:? "Replicas")

-- | ToJSON ServiceSpecModeReplicated
instance A.ToJSON ServiceSpecModeReplicated where
  toJSON ServiceSpecModeReplicated {..} =
   _omitNulls
      [ "Replicas" .= serviceSpecModeReplicatedReplicas
      ]


-- | Construct a value of type 'ServiceSpecModeReplicated' (by applying it's required fields, if any)
mkServiceSpecModeReplicated
  :: ServiceSpecModeReplicated
mkServiceSpecModeReplicated =
  ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas = Nothing
  }

-- ** ServiceSpecRollbackConfig
-- | ServiceSpecRollbackConfig
-- Specification for the rollback strategy of the service.
data ServiceSpecRollbackConfig = ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be rolled back in one iteration (0 means unlimited parallelism).
  , serviceSpecRollbackConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between rollback iterations, in nanoseconds.
  , serviceSpecRollbackConfigFailureAction :: !(Maybe E'FailureAction2) -- ^ "FailureAction" - Action to take if an rolled back task fails to run, or stops running during the rollback.
  , serviceSpecRollbackConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each rolled back task for failures, in nanoseconds.
  , serviceSpecRollbackConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during a rollback before the failure action is invoked, specified as a floating point number between 0 and 1.
  , serviceSpecRollbackConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecRollbackConfig
instance A.FromJSON ServiceSpecRollbackConfig where
  parseJSON = A.withObject "ServiceSpecRollbackConfig" $ \o ->
    ServiceSpecRollbackConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecRollbackConfig
instance A.ToJSON ServiceSpecRollbackConfig where
  toJSON ServiceSpecRollbackConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecRollbackConfigParallelism
      , "Delay" .= serviceSpecRollbackConfigDelay
      , "FailureAction" .= serviceSpecRollbackConfigFailureAction
      , "Monitor" .= serviceSpecRollbackConfigMonitor
      , "MaxFailureRatio" .= serviceSpecRollbackConfigMaxFailureRatio
      , "Order" .= serviceSpecRollbackConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecRollbackConfig' (by applying it's required fields, if any)
mkServiceSpecRollbackConfig
  :: ServiceSpecRollbackConfig
mkServiceSpecRollbackConfig =
  ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism = Nothing
  , serviceSpecRollbackConfigDelay = Nothing
  , serviceSpecRollbackConfigFailureAction = Nothing
  , serviceSpecRollbackConfigMonitor = Nothing
  , serviceSpecRollbackConfigMaxFailureRatio = Nothing
  , serviceSpecRollbackConfigOrder = Nothing
  }

-- ** ServiceSpecUpdateConfig
-- | ServiceSpecUpdateConfig
-- Specification for the update strategy of the service.
data ServiceSpecUpdateConfig = ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism).
  , serviceSpecUpdateConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between updates, in nanoseconds.
  , serviceSpecUpdateConfigFailureAction :: !(Maybe E'FailureAction) -- ^ "FailureAction" - Action to take if an updated task fails to run, or stops running during the update.
  , serviceSpecUpdateConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each updated task for failures, in nanoseconds.
  , serviceSpecUpdateConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1.
  , serviceSpecUpdateConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecUpdateConfig
instance A.FromJSON ServiceSpecUpdateConfig where
  parseJSON = A.withObject "ServiceSpecUpdateConfig" $ \o ->
    ServiceSpecUpdateConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecUpdateConfig
instance A.ToJSON ServiceSpecUpdateConfig where
  toJSON ServiceSpecUpdateConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecUpdateConfigParallelism
      , "Delay" .= serviceSpecUpdateConfigDelay
      , "FailureAction" .= serviceSpecUpdateConfigFailureAction
      , "Monitor" .= serviceSpecUpdateConfigMonitor
      , "MaxFailureRatio" .= serviceSpecUpdateConfigMaxFailureRatio
      , "Order" .= serviceSpecUpdateConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecUpdateConfig' (by applying it's required fields, if any)
mkServiceSpecUpdateConfig
  :: ServiceSpecUpdateConfig
mkServiceSpecUpdateConfig =
  ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism = Nothing
  , serviceSpecUpdateConfigDelay = Nothing
  , serviceSpecUpdateConfigFailureAction = Nothing
  , serviceSpecUpdateConfigMonitor = Nothing
  , serviceSpecUpdateConfigMaxFailureRatio = Nothing
  , serviceSpecUpdateConfigOrder = Nothing
  }

-- ** ServiceUpdateResponse
-- | ServiceUpdateResponse
data ServiceUpdateResponse = ServiceUpdateResponse
  { serviceUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings" - Optional warning messages
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateResponse
instance A.FromJSON ServiceUpdateResponse where
  parseJSON = A.withObject "ServiceUpdateResponse" $ \o ->
    ServiceUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ServiceUpdateResponse
instance A.ToJSON ServiceUpdateResponse where
  toJSON ServiceUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= serviceUpdateResponseWarnings
      ]


-- | Construct a value of type 'ServiceUpdateResponse' (by applying it's required fields, if any)
mkServiceUpdateResponse
  :: ServiceUpdateResponse
mkServiceUpdateResponse =
  ServiceUpdateResponse
  { serviceUpdateResponseWarnings = Nothing
  }

-- ** ServiceUpdateStatus
-- | ServiceUpdateStatus
-- The status of a service update.
data ServiceUpdateStatus = ServiceUpdateStatus
  { serviceUpdateStatusState :: !(Maybe E'State) -- ^ "State"
  , serviceUpdateStatusStartedAt :: !(Maybe Text) -- ^ "StartedAt"
  , serviceUpdateStatusCompletedAt :: !(Maybe Text) -- ^ "CompletedAt"
  , serviceUpdateStatusMessage :: !(Maybe Text) -- ^ "Message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateStatus
instance A.FromJSON ServiceUpdateStatus where
  parseJSON = A.withObject "ServiceUpdateStatus" $ \o ->
    ServiceUpdateStatus
      <$> (o .:? "State")
      <*> (o .:? "StartedAt")
      <*> (o .:? "CompletedAt")
      <*> (o .:? "Message")

-- | ToJSON ServiceUpdateStatus
instance A.ToJSON ServiceUpdateStatus where
  toJSON ServiceUpdateStatus {..} =
   _omitNulls
      [ "State" .= serviceUpdateStatusState
      , "StartedAt" .= serviceUpdateStatusStartedAt
      , "CompletedAt" .= serviceUpdateStatusCompletedAt
      , "Message" .= serviceUpdateStatusMessage
      ]


-- | Construct a value of type 'ServiceUpdateStatus' (by applying it's required fields, if any)
mkServiceUpdateStatus
  :: ServiceUpdateStatus
mkServiceUpdateStatus =
  ServiceUpdateStatus
  { serviceUpdateStatusState = Nothing
  , serviceUpdateStatusStartedAt = Nothing
  , serviceUpdateStatusCompletedAt = Nothing
  , serviceUpdateStatusMessage = Nothing
  }

-- ** SwarmSpec
-- | SwarmSpec
-- User modifiable swarm configuration.
data SwarmSpec = SwarmSpec
  { swarmSpecName :: !(Maybe Text) -- ^ "Name" - Name of the swarm.
  , swarmSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , swarmSpecOrchestration :: !(Maybe SwarmSpecOrchestration) -- ^ "Orchestration"
  , swarmSpecRaft :: !(Maybe SwarmSpecRaft) -- ^ "Raft"
  , swarmSpecDispatcher :: !(Maybe SwarmSpecDispatcher) -- ^ "Dispatcher"
  , swarmSpecCaConfig :: !(Maybe SwarmSpecCAConfig) -- ^ "CAConfig"
  , swarmSpecEncryptionConfig :: !(Maybe SwarmSpecEncryptionConfig) -- ^ "EncryptionConfig"
  , swarmSpecTaskDefaults :: !(Maybe SwarmSpecTaskDefaults) -- ^ "TaskDefaults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpec
instance A.FromJSON SwarmSpec where
  parseJSON = A.withObject "SwarmSpec" $ \o ->
    SwarmSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Orchestration")
      <*> (o .:? "Raft")
      <*> (o .:? "Dispatcher")
      <*> (o .:? "CAConfig")
      <*> (o .:? "EncryptionConfig")
      <*> (o .:? "TaskDefaults")

-- | ToJSON SwarmSpec
instance A.ToJSON SwarmSpec where
  toJSON SwarmSpec {..} =
   _omitNulls
      [ "Name" .= swarmSpecName
      , "Labels" .= swarmSpecLabels
      , "Orchestration" .= swarmSpecOrchestration
      , "Raft" .= swarmSpecRaft
      , "Dispatcher" .= swarmSpecDispatcher
      , "CAConfig" .= swarmSpecCaConfig
      , "EncryptionConfig" .= swarmSpecEncryptionConfig
      , "TaskDefaults" .= swarmSpecTaskDefaults
      ]


-- | Construct a value of type 'SwarmSpec' (by applying it's required fields, if any)
mkSwarmSpec
  :: SwarmSpec
mkSwarmSpec =
  SwarmSpec
  { swarmSpecName = Nothing
  , swarmSpecLabels = Nothing
  , swarmSpecOrchestration = Nothing
  , swarmSpecRaft = Nothing
  , swarmSpecDispatcher = Nothing
  , swarmSpecCaConfig = Nothing
  , swarmSpecEncryptionConfig = Nothing
  , swarmSpecTaskDefaults = Nothing
  }

-- ** SwarmSpecCAConfig
-- | SwarmSpecCAConfig
-- CA configuration.
data SwarmSpecCAConfig = SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry :: !(Maybe Integer) -- ^ "NodeCertExpiry" - The duration node certificates are issued for.
  , swarmSpecCAConfigExternalCAs :: !(Maybe [SwarmSpecCAConfigExternalCAs]) -- ^ "ExternalCAs" - Configuration for forwarding signing requests to an external certificate authority.
  , swarmSpecCAConfigSigningCaCert :: !(Maybe Text) -- ^ "SigningCACert" - The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.
  , swarmSpecCAConfigSigningCaKey :: !(Maybe Text) -- ^ "SigningCAKey" - The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.
  , swarmSpecCAConfigForceRotate :: !(Maybe A.Value) -- ^ "ForceRotate" - An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in &#x60;SigningCACert&#x60; and &#x60;SigningCAKey&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfig
instance A.FromJSON SwarmSpecCAConfig where
  parseJSON = A.withObject "SwarmSpecCAConfig" $ \o ->
    SwarmSpecCAConfig
      <$> (o .:? "NodeCertExpiry")
      <*> (o .:? "ExternalCAs")
      <*> (o .:? "SigningCACert")
      <*> (o .:? "SigningCAKey")
      <*> (o .:? "ForceRotate")

-- | ToJSON SwarmSpecCAConfig
instance A.ToJSON SwarmSpecCAConfig where
  toJSON SwarmSpecCAConfig {..} =
   _omitNulls
      [ "NodeCertExpiry" .= swarmSpecCAConfigNodeCertExpiry
      , "ExternalCAs" .= swarmSpecCAConfigExternalCAs
      , "SigningCACert" .= swarmSpecCAConfigSigningCaCert
      , "SigningCAKey" .= swarmSpecCAConfigSigningCaKey
      , "ForceRotate" .= swarmSpecCAConfigForceRotate
      ]


-- | Construct a value of type 'SwarmSpecCAConfig' (by applying it's required fields, if any)
mkSwarmSpecCAConfig
  :: SwarmSpecCAConfig
mkSwarmSpecCAConfig =
  SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry = Nothing
  , swarmSpecCAConfigExternalCAs = Nothing
  , swarmSpecCAConfigSigningCaCert = Nothing
  , swarmSpecCAConfigSigningCaKey = Nothing
  , swarmSpecCAConfigForceRotate = Nothing
  }

-- ** SwarmSpecCAConfigExternalCAs
-- | SwarmSpecCAConfigExternalCAs
data SwarmSpecCAConfigExternalCAs = SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol :: !(Maybe E'Protocol) -- ^ "Protocol" - Protocol for communication with the external CA (currently only &#x60;cfssl&#x60; is supported).
  , swarmSpecCAConfigExternalCAsUrl :: !(Maybe Text) -- ^ "URL" - URL where certificate signing requests should be sent.
  , swarmSpecCAConfigExternalCAsOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.
  , swarmSpecCAConfigExternalCAsCaCert :: !(Maybe Text) -- ^ "CACert" - The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfigExternalCAs
instance A.FromJSON SwarmSpecCAConfigExternalCAs where
  parseJSON = A.withObject "SwarmSpecCAConfigExternalCAs" $ \o ->
    SwarmSpecCAConfigExternalCAs
      <$> (o .:? "Protocol")
      <*> (o .:? "URL")
      <*> (o .:? "Options")
      <*> (o .:? "CACert")

-- | ToJSON SwarmSpecCAConfigExternalCAs
instance A.ToJSON SwarmSpecCAConfigExternalCAs where
  toJSON SwarmSpecCAConfigExternalCAs {..} =
   _omitNulls
      [ "Protocol" .= swarmSpecCAConfigExternalCAsProtocol
      , "URL" .= swarmSpecCAConfigExternalCAsUrl
      , "Options" .= swarmSpecCAConfigExternalCAsOptions
      , "CACert" .= swarmSpecCAConfigExternalCAsCaCert
      ]


-- | Construct a value of type 'SwarmSpecCAConfigExternalCAs' (by applying it's required fields, if any)
mkSwarmSpecCAConfigExternalCAs
  :: SwarmSpecCAConfigExternalCAs
mkSwarmSpecCAConfigExternalCAs =
  SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol = Nothing
  , swarmSpecCAConfigExternalCAsUrl = Nothing
  , swarmSpecCAConfigExternalCAsOptions = Nothing
  , swarmSpecCAConfigExternalCAsCaCert = Nothing
  }

-- ** SwarmSpecDispatcher
-- | SwarmSpecDispatcher
-- Dispatcher configuration.
data SwarmSpecDispatcher = SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod :: !(Maybe Integer) -- ^ "HeartbeatPeriod" - The delay for an agent to send a heartbeat to the dispatcher.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecDispatcher
instance A.FromJSON SwarmSpecDispatcher where
  parseJSON = A.withObject "SwarmSpecDispatcher" $ \o ->
    SwarmSpecDispatcher
      <$> (o .:? "HeartbeatPeriod")

-- | ToJSON SwarmSpecDispatcher
instance A.ToJSON SwarmSpecDispatcher where
  toJSON SwarmSpecDispatcher {..} =
   _omitNulls
      [ "HeartbeatPeriod" .= swarmSpecDispatcherHeartbeatPeriod
      ]


-- | Construct a value of type 'SwarmSpecDispatcher' (by applying it's required fields, if any)
mkSwarmSpecDispatcher
  :: SwarmSpecDispatcher
mkSwarmSpecDispatcher =
  SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod = Nothing
  }

-- ** SwarmSpecEncryptionConfig
-- | SwarmSpecEncryptionConfig
-- Parameters related to encryption-at-rest.
data SwarmSpecEncryptionConfig = SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers :: !(Maybe Bool) -- ^ "AutoLockManagers" - If set, generate a key and use it to lock data stored on the managers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecEncryptionConfig
instance A.FromJSON SwarmSpecEncryptionConfig where
  parseJSON = A.withObject "SwarmSpecEncryptionConfig" $ \o ->
    SwarmSpecEncryptionConfig
      <$> (o .:? "AutoLockManagers")

-- | ToJSON SwarmSpecEncryptionConfig
instance A.ToJSON SwarmSpecEncryptionConfig where
  toJSON SwarmSpecEncryptionConfig {..} =
   _omitNulls
      [ "AutoLockManagers" .= swarmSpecEncryptionConfigAutoLockManagers
      ]


-- | Construct a value of type 'SwarmSpecEncryptionConfig' (by applying it's required fields, if any)
mkSwarmSpecEncryptionConfig
  :: SwarmSpecEncryptionConfig
mkSwarmSpecEncryptionConfig =
  SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers = Nothing
  }

-- ** SwarmSpecOrchestration
-- | SwarmSpecOrchestration
-- Orchestration configuration.
data SwarmSpecOrchestration = SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit :: !(Maybe Integer) -- ^ "TaskHistoryRetentionLimit" - The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecOrchestration
instance A.FromJSON SwarmSpecOrchestration where
  parseJSON = A.withObject "SwarmSpecOrchestration" $ \o ->
    SwarmSpecOrchestration
      <$> (o .:? "TaskHistoryRetentionLimit")

-- | ToJSON SwarmSpecOrchestration
instance A.ToJSON SwarmSpecOrchestration where
  toJSON SwarmSpecOrchestration {..} =
   _omitNulls
      [ "TaskHistoryRetentionLimit" .= swarmSpecOrchestrationTaskHistoryRetentionLimit
      ]


-- | Construct a value of type 'SwarmSpecOrchestration' (by applying it's required fields, if any)
mkSwarmSpecOrchestration
  :: SwarmSpecOrchestration
mkSwarmSpecOrchestration =
  SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit = Nothing
  }

-- ** SwarmSpecRaft
-- | SwarmSpecRaft
-- Raft configuration.
data SwarmSpecRaft = SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval :: !(Maybe Integer) -- ^ "SnapshotInterval" - The number of log entries between snapshots.
  , swarmSpecRaftKeepOldSnapshots :: !(Maybe Integer) -- ^ "KeepOldSnapshots" - The number of snapshots to keep beyond the current snapshot.
  , swarmSpecRaftLogEntriesForSlowFollowers :: !(Maybe Integer) -- ^ "LogEntriesForSlowFollowers" - The number of log entries to keep around to sync up slow followers after a snapshot is created.
  , swarmSpecRaftElectionTick :: !(Maybe Int) -- ^ "ElectionTick" - The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. &#x60;ElectionTick&#x60; must be greater than &#x60;HeartbeatTick&#x60;.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  , swarmSpecRaftHeartbeatTick :: !(Maybe Int) -- ^ "HeartbeatTick" - The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecRaft
instance A.FromJSON SwarmSpecRaft where
  parseJSON = A.withObject "SwarmSpecRaft" $ \o ->
    SwarmSpecRaft
      <$> (o .:? "SnapshotInterval")
      <*> (o .:? "KeepOldSnapshots")
      <*> (o .:? "LogEntriesForSlowFollowers")
      <*> (o .:? "ElectionTick")
      <*> (o .:? "HeartbeatTick")

-- | ToJSON SwarmSpecRaft
instance A.ToJSON SwarmSpecRaft where
  toJSON SwarmSpecRaft {..} =
   _omitNulls
      [ "SnapshotInterval" .= swarmSpecRaftSnapshotInterval
      , "KeepOldSnapshots" .= swarmSpecRaftKeepOldSnapshots
      , "LogEntriesForSlowFollowers" .= swarmSpecRaftLogEntriesForSlowFollowers
      , "ElectionTick" .= swarmSpecRaftElectionTick
      , "HeartbeatTick" .= swarmSpecRaftHeartbeatTick
      ]


-- | Construct a value of type 'SwarmSpecRaft' (by applying it's required fields, if any)
mkSwarmSpecRaft
  :: SwarmSpecRaft
mkSwarmSpecRaft =
  SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval = Nothing
  , swarmSpecRaftKeepOldSnapshots = Nothing
  , swarmSpecRaftLogEntriesForSlowFollowers = Nothing
  , swarmSpecRaftElectionTick = Nothing
  , swarmSpecRaftHeartbeatTick = Nothing
  }

-- ** SwarmSpecTaskDefaults
-- | SwarmSpecTaskDefaults
-- Defaults for creating tasks in this cluster.
data SwarmSpecTaskDefaults = SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver :: !(Maybe SwarmSpecTaskDefaultsLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaults
instance A.FromJSON SwarmSpecTaskDefaults where
  parseJSON = A.withObject "SwarmSpecTaskDefaults" $ \o ->
    SwarmSpecTaskDefaults
      <$> (o .:? "LogDriver")

-- | ToJSON SwarmSpecTaskDefaults
instance A.ToJSON SwarmSpecTaskDefaults where
  toJSON SwarmSpecTaskDefaults {..} =
   _omitNulls
      [ "LogDriver" .= swarmSpecTaskDefaultsLogDriver
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaults' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaults
  :: SwarmSpecTaskDefaults
mkSwarmSpecTaskDefaults =
  SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver = Nothing
  }

-- ** SwarmSpecTaskDefaultsLogDriver
-- | SwarmSpecTaskDefaultsLogDriver
-- The log driver to use for tasks created in the orchestrator if unspecified by a service.  Updating this value will only have an affect on new tasks. Old tasks will continue use their previously configured log driver until recreated. 
data SwarmSpecTaskDefaultsLogDriver = SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName :: !(Maybe Text) -- ^ "Name"
  , swarmSpecTaskDefaultsLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaultsLogDriver
instance A.FromJSON SwarmSpecTaskDefaultsLogDriver where
  parseJSON = A.withObject "SwarmSpecTaskDefaultsLogDriver" $ \o ->
    SwarmSpecTaskDefaultsLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON SwarmSpecTaskDefaultsLogDriver
instance A.ToJSON SwarmSpecTaskDefaultsLogDriver where
  toJSON SwarmSpecTaskDefaultsLogDriver {..} =
   _omitNulls
      [ "Name" .= swarmSpecTaskDefaultsLogDriverName
      , "Options" .= swarmSpecTaskDefaultsLogDriverOptions
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaultsLogDriver' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaultsLogDriver
  :: SwarmSpecTaskDefaultsLogDriver
mkSwarmSpecTaskDefaultsLogDriver =
  SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName = Nothing
  , swarmSpecTaskDefaultsLogDriverOptions = Nothing
  }

-- ** TLSInfo
-- | TLSInfo
-- Information about the issuer of leaf TLS certificates and the trusted root CA certificate
data TLSInfo = TLSInfo
  { tLSInfoTrustRoot :: !(Maybe Text) -- ^ "TrustRoot" - The root CA certificate(s) that are used to validate leaf TLS certificates
  , tLSInfoCertIssuerSubject :: !(Maybe Text) -- ^ "CertIssuerSubject" - The base64-url-safe-encoded raw subject bytes of the issuer
  , tLSInfoCertIssuerPublicKey :: !(Maybe Text) -- ^ "CertIssuerPublicKey" - The base64-url-safe-encoded raw public key bytes of the issuer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TLSInfo
instance A.FromJSON TLSInfo where
  parseJSON = A.withObject "TLSInfo" $ \o ->
    TLSInfo
      <$> (o .:? "TrustRoot")
      <*> (o .:? "CertIssuerSubject")
      <*> (o .:? "CertIssuerPublicKey")

-- | ToJSON TLSInfo
instance A.ToJSON TLSInfo where
  toJSON TLSInfo {..} =
   _omitNulls
      [ "TrustRoot" .= tLSInfoTrustRoot
      , "CertIssuerSubject" .= tLSInfoCertIssuerSubject
      , "CertIssuerPublicKey" .= tLSInfoCertIssuerPublicKey
      ]


-- | Construct a value of type 'TLSInfo' (by applying it's required fields, if any)
mkTLSInfo
  :: TLSInfo
mkTLSInfo =
  TLSInfo
  { tLSInfoTrustRoot = Nothing
  , tLSInfoCertIssuerSubject = Nothing
  , tLSInfoCertIssuerPublicKey = Nothing
  }

-- ** Task
-- | Task
data Task = Task
  { taskId :: !(Maybe Text) -- ^ "ID" - The ID of the task.
  , taskVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , taskCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , taskUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , taskName :: !(Maybe Text) -- ^ "Name" - Name of the task.
  , taskLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , taskSpec :: !(Maybe TaskSpec) -- ^ "Spec"
  , taskServiceId :: !(Maybe Text) -- ^ "ServiceID" - The ID of the service this task is part of.
  , taskSlot :: !(Maybe Int) -- ^ "Slot"
  , taskNodeId :: !(Maybe Text) -- ^ "NodeID" - The ID of the node that this task is on.
  , taskStatus :: !(Maybe TaskStatus) -- ^ "Status"
  , taskDesiredState :: !(Maybe TaskState) -- ^ "DesiredState"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Task
instance A.FromJSON Task where
  parseJSON = A.withObject "Task" $ \o ->
    Task
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Spec")
      <*> (o .:? "ServiceID")
      <*> (o .:? "Slot")
      <*> (o .:? "NodeID")
      <*> (o .:? "Status")
      <*> (o .:? "DesiredState")

-- | ToJSON Task
instance A.ToJSON Task where
  toJSON Task {..} =
   _omitNulls
      [ "ID" .= taskId
      , "Version" .= taskVersion
      , "CreatedAt" .= taskCreatedAt
      , "UpdatedAt" .= taskUpdatedAt
      , "Name" .= taskName
      , "Labels" .= taskLabels
      , "Spec" .= taskSpec
      , "ServiceID" .= taskServiceId
      , "Slot" .= taskSlot
      , "NodeID" .= taskNodeId
      , "Status" .= taskStatus
      , "DesiredState" .= taskDesiredState
      ]


-- | Construct a value of type 'Task' (by applying it's required fields, if any)
mkTask
  :: Task
mkTask =
  Task
  { taskId = Nothing
  , taskVersion = Nothing
  , taskCreatedAt = Nothing
  , taskUpdatedAt = Nothing
  , taskName = Nothing
  , taskLabels = Nothing
  , taskSpec = Nothing
  , taskServiceId = Nothing
  , taskSlot = Nothing
  , taskNodeId = Nothing
  , taskStatus = Nothing
  , taskDesiredState = Nothing
  }

-- ** TaskSpec
-- | TaskSpec
-- User modifiable task configuration.
data TaskSpec = TaskSpec
  { taskSpecContainerSpec :: !(Maybe TaskSpecContainerSpec) -- ^ "ContainerSpec"
  , taskSpecResources :: !(Maybe TaskSpecResources) -- ^ "Resources"
  , taskSpecRestartPolicy :: !(Maybe TaskSpecRestartPolicy) -- ^ "RestartPolicy"
  , taskSpecPlacement :: !(Maybe TaskSpecPlacement) -- ^ "Placement"
  , taskSpecForceUpdate :: !(Maybe Int) -- ^ "ForceUpdate" - A counter that triggers an update even if no relevant parameters have been changed.
  , taskSpecRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime is the type of runtime specified for the task executor.
  , taskSpecNetworks :: !(Maybe [TaskSpecNetworks]) -- ^ "Networks"
  , taskSpecLogDriver :: !(Maybe TaskSpecLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpec
instance A.FromJSON TaskSpec where
  parseJSON = A.withObject "TaskSpec" $ \o ->
    TaskSpec
      <$> (o .:? "ContainerSpec")
      <*> (o .:? "Resources")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "Placement")
      <*> (o .:? "ForceUpdate")
      <*> (o .:? "Runtime")
      <*> (o .:? "Networks")
      <*> (o .:? "LogDriver")

-- | ToJSON TaskSpec
instance A.ToJSON TaskSpec where
  toJSON TaskSpec {..} =
   _omitNulls
      [ "ContainerSpec" .= taskSpecContainerSpec
      , "Resources" .= taskSpecResources
      , "RestartPolicy" .= taskSpecRestartPolicy
      , "Placement" .= taskSpecPlacement
      , "ForceUpdate" .= taskSpecForceUpdate
      , "Runtime" .= taskSpecRuntime
      , "Networks" .= taskSpecNetworks
      , "LogDriver" .= taskSpecLogDriver
      ]


-- | Construct a value of type 'TaskSpec' (by applying it's required fields, if any)
mkTaskSpec
  :: TaskSpec
mkTaskSpec =
  TaskSpec
  { taskSpecContainerSpec = Nothing
  , taskSpecResources = Nothing
  , taskSpecRestartPolicy = Nothing
  , taskSpecPlacement = Nothing
  , taskSpecForceUpdate = Nothing
  , taskSpecRuntime = Nothing
  , taskSpecNetworks = Nothing
  , taskSpecLogDriver = Nothing
  }

-- ** TaskSpecContainerSpec
-- | TaskSpecContainerSpec
data TaskSpecContainerSpec = TaskSpecContainerSpec
  { taskSpecContainerSpecImage :: !(Maybe Text) -- ^ "Image" - The image name to use for the container.
  , taskSpecContainerSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value data.
  , taskSpecContainerSpecCommand :: !(Maybe [Text]) -- ^ "Command" - The command to be run in the image.
  , taskSpecContainerSpecArgs :: !(Maybe [Text]) -- ^ "Args" - Arguments to the command.
  , taskSpecContainerSpecHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , taskSpecContainerSpecEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;VAR&#x3D;value&#x60;.
  , taskSpecContainerSpecDir :: !(Maybe Text) -- ^ "Dir" - The working directory for commands to run in.
  , taskSpecContainerSpecUser :: !(Maybe Text) -- ^ "User" - The user inside the container.
  , taskSpecContainerSpecGroups :: !(Maybe [Text]) -- ^ "Groups" - A list of additional groups that the container process will run as.
  , taskSpecContainerSpecPrivileges :: !(Maybe TaskSpecContainerSpecPrivileges) -- ^ "Privileges"
  , taskSpecContainerSpecTty :: !(Maybe Bool) -- ^ "TTY" - Whether a pseudo-TTY should be allocated.
  , taskSpecContainerSpecOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , taskSpecContainerSpecReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Mount the container&#39;s root filesystem as read only.
  , taskSpecContainerSpecMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to containers created as part of the service.
  , taskSpecContainerSpecStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop the container.
  , taskSpecContainerSpecStopGracePeriod :: !(Maybe Integer) -- ^ "StopGracePeriod" - Amount of time to wait for the container to terminate before forcefully killing it.
  , taskSpecContainerSpecHealthCheck :: !(Maybe HealthConfig) -- ^ "HealthCheck"
  , taskSpecContainerSpecHosts :: !(Maybe [Text]) -- ^ "Hosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. The format of extra hosts on swarmkit is specified in: http://man7.org/linux/man-pages/man5/hosts.5.html   IP_address canonical_hostname [aliases...] 
  , taskSpecContainerSpecDnsConfig :: !(Maybe TaskSpecContainerSpecDNSConfig) -- ^ "DNSConfig"
  , taskSpecContainerSpecSecrets :: !(Maybe [TaskSpecContainerSpecSecrets]) -- ^ "Secrets" - Secrets contains references to zero or more secrets that will be exposed to the service.
  , taskSpecContainerSpecConfigs :: !(Maybe [TaskSpecContainerSpecConfigs]) -- ^ "Configs" - Configs contains references to zero or more configs that will be exposed to the service.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpec
instance A.FromJSON TaskSpecContainerSpec where
  parseJSON = A.withObject "TaskSpecContainerSpec" $ \o ->
    TaskSpecContainerSpec
      <$> (o .:? "Image")
      <*> (o .:? "Labels")
      <*> (o .:? "Command")
      <*> (o .:? "Args")
      <*> (o .:? "Hostname")
      <*> (o .:? "Env")
      <*> (o .:? "Dir")
      <*> (o .:? "User")
      <*> (o .:? "Groups")
      <*> (o .:? "Privileges")
      <*> (o .:? "TTY")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Mounts")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopGracePeriod")
      <*> (o .:? "HealthCheck")
      <*> (o .:? "Hosts")
      <*> (o .:? "DNSConfig")
      <*> (o .:? "Secrets")
      <*> (o .:? "Configs")

-- | ToJSON TaskSpecContainerSpec
instance A.ToJSON TaskSpecContainerSpec where
  toJSON TaskSpecContainerSpec {..} =
   _omitNulls
      [ "Image" .= taskSpecContainerSpecImage
      , "Labels" .= taskSpecContainerSpecLabels
      , "Command" .= taskSpecContainerSpecCommand
      , "Args" .= taskSpecContainerSpecArgs
      , "Hostname" .= taskSpecContainerSpecHostname
      , "Env" .= taskSpecContainerSpecEnv
      , "Dir" .= taskSpecContainerSpecDir
      , "User" .= taskSpecContainerSpecUser
      , "Groups" .= taskSpecContainerSpecGroups
      , "Privileges" .= taskSpecContainerSpecPrivileges
      , "TTY" .= taskSpecContainerSpecTty
      , "OpenStdin" .= taskSpecContainerSpecOpenStdin
      , "ReadOnly" .= taskSpecContainerSpecReadOnly
      , "Mounts" .= taskSpecContainerSpecMounts
      , "StopSignal" .= taskSpecContainerSpecStopSignal
      , "StopGracePeriod" .= taskSpecContainerSpecStopGracePeriod
      , "HealthCheck" .= taskSpecContainerSpecHealthCheck
      , "Hosts" .= taskSpecContainerSpecHosts
      , "DNSConfig" .= taskSpecContainerSpecDnsConfig
      , "Secrets" .= taskSpecContainerSpecSecrets
      , "Configs" .= taskSpecContainerSpecConfigs
      ]


-- | Construct a value of type 'TaskSpecContainerSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpec
  :: TaskSpecContainerSpec
mkTaskSpecContainerSpec =
  TaskSpecContainerSpec
  { taskSpecContainerSpecImage = Nothing
  , taskSpecContainerSpecLabels = Nothing
  , taskSpecContainerSpecCommand = Nothing
  , taskSpecContainerSpecArgs = Nothing
  , taskSpecContainerSpecHostname = Nothing
  , taskSpecContainerSpecEnv = Nothing
  , taskSpecContainerSpecDir = Nothing
  , taskSpecContainerSpecUser = Nothing
  , taskSpecContainerSpecGroups = Nothing
  , taskSpecContainerSpecPrivileges = Nothing
  , taskSpecContainerSpecTty = Nothing
  , taskSpecContainerSpecOpenStdin = Nothing
  , taskSpecContainerSpecReadOnly = Nothing
  , taskSpecContainerSpecMounts = Nothing
  , taskSpecContainerSpecStopSignal = Nothing
  , taskSpecContainerSpecStopGracePeriod = Nothing
  , taskSpecContainerSpecHealthCheck = Nothing
  , taskSpecContainerSpecHosts = Nothing
  , taskSpecContainerSpecDnsConfig = Nothing
  , taskSpecContainerSpecSecrets = Nothing
  , taskSpecContainerSpecConfigs = Nothing
  }

-- ** TaskSpecContainerSpecConfigs
-- | TaskSpecContainerSpecConfigs
data TaskSpecContainerSpecConfigs = TaskSpecContainerSpecConfigs
  { taskSpecContainerSpecConfigsFile :: !(Maybe TaskSpecContainerSpecFile) -- ^ "File"
  , taskSpecContainerSpecConfigsConfigId :: !(Maybe Text) -- ^ "ConfigID" - ConfigID represents the ID of the specific config that we&#39;re referencing.
  , taskSpecContainerSpecConfigsConfigName :: !(Maybe Text) -- ^ "ConfigName" - ConfigName is the name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecConfigs
instance A.FromJSON TaskSpecContainerSpecConfigs where
  parseJSON = A.withObject "TaskSpecContainerSpecConfigs" $ \o ->
    TaskSpecContainerSpecConfigs
      <$> (o .:? "File")
      <*> (o .:? "ConfigID")
      <*> (o .:? "ConfigName")

-- | ToJSON TaskSpecContainerSpecConfigs
instance A.ToJSON TaskSpecContainerSpecConfigs where
  toJSON TaskSpecContainerSpecConfigs {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecConfigsFile
      , "ConfigID" .= taskSpecContainerSpecConfigsConfigId
      , "ConfigName" .= taskSpecContainerSpecConfigsConfigName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecConfigs' (by applying it's required fields, if any)
mkTaskSpecContainerSpecConfigs
  :: TaskSpecContainerSpecConfigs
mkTaskSpecContainerSpecConfigs =
  TaskSpecContainerSpecConfigs
  { taskSpecContainerSpecConfigsFile = Nothing
  , taskSpecContainerSpecConfigsConfigId = Nothing
  , taskSpecContainerSpecConfigsConfigName = Nothing
  }

-- ** TaskSpecContainerSpecDNSConfig
-- | TaskSpecContainerSpecDNSConfig
-- Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
data TaskSpecContainerSpecDNSConfig = TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers :: !(Maybe [Text]) -- ^ "Nameservers" - The IP addresses of the name servers.
  , taskSpecContainerSpecDNSConfigSearch :: !(Maybe [Text]) -- ^ "Search" - A search list for host-name lookup.
  , taskSpecContainerSpecDNSConfigOptions :: !(Maybe [Text]) -- ^ "Options" - A list of internal resolver variables to be modified (e.g., &#x60;debug&#x60;, &#x60;ndots:3&#x60;, etc.).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecDNSConfig
instance A.FromJSON TaskSpecContainerSpecDNSConfig where
  parseJSON = A.withObject "TaskSpecContainerSpecDNSConfig" $ \o ->
    TaskSpecContainerSpecDNSConfig
      <$> (o .:? "Nameservers")
      <*> (o .:? "Search")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecContainerSpecDNSConfig
instance A.ToJSON TaskSpecContainerSpecDNSConfig where
  toJSON TaskSpecContainerSpecDNSConfig {..} =
   _omitNulls
      [ "Nameservers" .= taskSpecContainerSpecDNSConfigNameservers
      , "Search" .= taskSpecContainerSpecDNSConfigSearch
      , "Options" .= taskSpecContainerSpecDNSConfigOptions
      ]


-- | Construct a value of type 'TaskSpecContainerSpecDNSConfig' (by applying it's required fields, if any)
mkTaskSpecContainerSpecDNSConfig
  :: TaskSpecContainerSpecDNSConfig
mkTaskSpecContainerSpecDNSConfig =
  TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers = Nothing
  , taskSpecContainerSpecDNSConfigSearch = Nothing
  , taskSpecContainerSpecDNSConfigOptions = Nothing
  }

-- ** TaskSpecContainerSpecFile
-- | TaskSpecContainerSpecFile
-- File represents a specific target that is backed by a file.
data TaskSpecContainerSpecFile = TaskSpecContainerSpecFile
  { taskSpecContainerSpecFileName :: !(Maybe Text) -- ^ "Name" - Name represents the final filename in the filesystem.
  , taskSpecContainerSpecFileUid :: !(Maybe Text) -- ^ "UID" - UID represents the file UID.
  , taskSpecContainerSpecFileGid :: !(Maybe Text) -- ^ "GID" - GID represents the file GID.
  , taskSpecContainerSpecFileMode :: !(Maybe Int) -- ^ "Mode" - Mode represents the FileMode of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecFile
instance A.FromJSON TaskSpecContainerSpecFile where
  parseJSON = A.withObject "TaskSpecContainerSpecFile" $ \o ->
    TaskSpecContainerSpecFile
      <$> (o .:? "Name")
      <*> (o .:? "UID")
      <*> (o .:? "GID")
      <*> (o .:? "Mode")

-- | ToJSON TaskSpecContainerSpecFile
instance A.ToJSON TaskSpecContainerSpecFile where
  toJSON TaskSpecContainerSpecFile {..} =
   _omitNulls
      [ "Name" .= taskSpecContainerSpecFileName
      , "UID" .= taskSpecContainerSpecFileUid
      , "GID" .= taskSpecContainerSpecFileGid
      , "Mode" .= taskSpecContainerSpecFileMode
      ]


-- | Construct a value of type 'TaskSpecContainerSpecFile' (by applying it's required fields, if any)
mkTaskSpecContainerSpecFile
  :: TaskSpecContainerSpecFile
mkTaskSpecContainerSpecFile =
  TaskSpecContainerSpecFile
  { taskSpecContainerSpecFileName = Nothing
  , taskSpecContainerSpecFileUid = Nothing
  , taskSpecContainerSpecFileGid = Nothing
  , taskSpecContainerSpecFileMode = Nothing
  }

-- ** TaskSpecContainerSpecPrivileges
-- | TaskSpecContainerSpecPrivileges
-- Security options for the container
data TaskSpecContainerSpecPrivileges = TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec :: !(Maybe TaskSpecContainerSpecPrivilegesCredentialSpec) -- ^ "CredentialSpec"
  , taskSpecContainerSpecPrivilegesSeLinuxContext :: !(Maybe TaskSpecContainerSpecPrivilegesSELinuxContext) -- ^ "SELinuxContext"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivileges
instance A.FromJSON TaskSpecContainerSpecPrivileges where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivileges" $ \o ->
    TaskSpecContainerSpecPrivileges
      <$> (o .:? "CredentialSpec")
      <*> (o .:? "SELinuxContext")

-- | ToJSON TaskSpecContainerSpecPrivileges
instance A.ToJSON TaskSpecContainerSpecPrivileges where
  toJSON TaskSpecContainerSpecPrivileges {..} =
   _omitNulls
      [ "CredentialSpec" .= taskSpecContainerSpecPrivilegesCredentialSpec
      , "SELinuxContext" .= taskSpecContainerSpecPrivilegesSeLinuxContext
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivileges' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivileges
  :: TaskSpecContainerSpecPrivileges
mkTaskSpecContainerSpecPrivileges =
  TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec = Nothing
  , taskSpecContainerSpecPrivilegesSeLinuxContext = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesCredentialSpec
-- | TaskSpecContainerSpecPrivilegesCredentialSpec
-- CredentialSpec for managed service account (Windows only)
data TaskSpecContainerSpecPrivilegesCredentialSpec = TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecFile :: !(Maybe Text) -- ^ "File" - Load credential spec from this file. The file is read by the daemon, and must be present in the &#x60;CredentialSpecs&#x60; subdirectory in the docker data directory, which defaults to &#x60;C:\\ProgramData\\Docker\\&#x60; on Windows.  For example, specifying &#x60;spec.json&#x60; loads &#x60;C:\\ProgramData\\Docker\\CredentialSpecs\\spec.json&#x60;.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: &#x60;CredentialSpec.File&#x60; and &#x60;CredentialSpec.Registry&#x60; are mutually exclusive. 
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry :: !(Maybe Text) -- ^ "Registry" - Load credential spec from this value in the Windows registry. The specified registry value must be located in:  &#x60;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs&#x60;  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;   &gt; **Note**: &#x60;CredentialSpec.File&#x60; and &#x60;CredentialSpec.Registry&#x60; are mutually exclusive. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesCredentialSpec" $ \o ->
    TaskSpecContainerSpecPrivilegesCredentialSpec
      <$> (o .:? "File")
      <*> (o .:? "Registry")

-- | ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  toJSON TaskSpecContainerSpecPrivilegesCredentialSpec {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecPrivilegesCredentialSpecFile
      , "Registry" .= taskSpecContainerSpecPrivilegesCredentialSpecRegistry
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesCredentialSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesCredentialSpec
  :: TaskSpecContainerSpecPrivilegesCredentialSpec
mkTaskSpecContainerSpecPrivilegesCredentialSpec =
  TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecFile = Nothing
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesSELinuxContext
-- | TaskSpecContainerSpecPrivilegesSELinuxContext
-- SELinux labels of the container
data TaskSpecContainerSpecPrivilegesSELinuxContext = TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable :: !(Maybe Bool) -- ^ "Disable" - Disable SELinux
  , taskSpecContainerSpecPrivilegesSELinuxContextUser :: !(Maybe Text) -- ^ "User" - SELinux user label
  , taskSpecContainerSpecPrivilegesSELinuxContextRole :: !(Maybe Text) -- ^ "Role" - SELinux role label
  , taskSpecContainerSpecPrivilegesSELinuxContextType :: !(Maybe Text) -- ^ "Type" - SELinux type label
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel :: !(Maybe Text) -- ^ "Level" - SELinux level label
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesSELinuxContext" $ \o ->
    TaskSpecContainerSpecPrivilegesSELinuxContext
      <$> (o .:? "Disable")
      <*> (o .:? "User")
      <*> (o .:? "Role")
      <*> (o .:? "Type")
      <*> (o .:? "Level")

-- | ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  toJSON TaskSpecContainerSpecPrivilegesSELinuxContext {..} =
   _omitNulls
      [ "Disable" .= taskSpecContainerSpecPrivilegesSELinuxContextDisable
      , "User" .= taskSpecContainerSpecPrivilegesSELinuxContextUser
      , "Role" .= taskSpecContainerSpecPrivilegesSELinuxContextRole
      , "Type" .= taskSpecContainerSpecPrivilegesSELinuxContextType
      , "Level" .= taskSpecContainerSpecPrivilegesSELinuxContextLevel
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesSELinuxContext' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesSELinuxContext
  :: TaskSpecContainerSpecPrivilegesSELinuxContext
mkTaskSpecContainerSpecPrivilegesSELinuxContext =
  TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextUser = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextRole = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextType = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel = Nothing
  }

-- ** TaskSpecContainerSpecSecrets
-- | TaskSpecContainerSpecSecrets
data TaskSpecContainerSpecSecrets = TaskSpecContainerSpecSecrets
  { taskSpecContainerSpecSecretsFile :: !(Maybe TaskSpecContainerSpecFile) -- ^ "File"
  , taskSpecContainerSpecSecretsSecretId :: !(Maybe Text) -- ^ "SecretID" - SecretID represents the ID of the specific secret that we&#39;re referencing.
  , taskSpecContainerSpecSecretsSecretName :: !(Maybe Text) -- ^ "SecretName" - SecretName is the name of the secret that this references, but this is just provided for lookup/display purposes. The secret in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecSecrets
instance A.FromJSON TaskSpecContainerSpecSecrets where
  parseJSON = A.withObject "TaskSpecContainerSpecSecrets" $ \o ->
    TaskSpecContainerSpecSecrets
      <$> (o .:? "File")
      <*> (o .:? "SecretID")
      <*> (o .:? "SecretName")

-- | ToJSON TaskSpecContainerSpecSecrets
instance A.ToJSON TaskSpecContainerSpecSecrets where
  toJSON TaskSpecContainerSpecSecrets {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecSecretsFile
      , "SecretID" .= taskSpecContainerSpecSecretsSecretId
      , "SecretName" .= taskSpecContainerSpecSecretsSecretName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecSecrets' (by applying it's required fields, if any)
mkTaskSpecContainerSpecSecrets
  :: TaskSpecContainerSpecSecrets
mkTaskSpecContainerSpecSecrets =
  TaskSpecContainerSpecSecrets
  { taskSpecContainerSpecSecretsFile = Nothing
  , taskSpecContainerSpecSecretsSecretId = Nothing
  , taskSpecContainerSpecSecretsSecretName = Nothing
  }

-- ** TaskSpecLogDriver
-- | TaskSpecLogDriver
-- Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
data TaskSpecLogDriver = TaskSpecLogDriver
  { taskSpecLogDriverName :: !(Maybe Text) -- ^ "Name"
  , taskSpecLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecLogDriver
instance A.FromJSON TaskSpecLogDriver where
  parseJSON = A.withObject "TaskSpecLogDriver" $ \o ->
    TaskSpecLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecLogDriver
instance A.ToJSON TaskSpecLogDriver where
  toJSON TaskSpecLogDriver {..} =
   _omitNulls
      [ "Name" .= taskSpecLogDriverName
      , "Options" .= taskSpecLogDriverOptions
      ]


-- | Construct a value of type 'TaskSpecLogDriver' (by applying it's required fields, if any)
mkTaskSpecLogDriver
  :: TaskSpecLogDriver
mkTaskSpecLogDriver =
  TaskSpecLogDriver
  { taskSpecLogDriverName = Nothing
  , taskSpecLogDriverOptions = Nothing
  }

-- ** TaskSpecNetworks
-- | TaskSpecNetworks
data TaskSpecNetworks = TaskSpecNetworks
  { taskSpecNetworksTarget :: !(Maybe Text) -- ^ "Target"
  , taskSpecNetworksAliases :: !(Maybe [Text]) -- ^ "Aliases"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecNetworks
instance A.FromJSON TaskSpecNetworks where
  parseJSON = A.withObject "TaskSpecNetworks" $ \o ->
    TaskSpecNetworks
      <$> (o .:? "Target")
      <*> (o .:? "Aliases")

-- | ToJSON TaskSpecNetworks
instance A.ToJSON TaskSpecNetworks where
  toJSON TaskSpecNetworks {..} =
   _omitNulls
      [ "Target" .= taskSpecNetworksTarget
      , "Aliases" .= taskSpecNetworksAliases
      ]


-- | Construct a value of type 'TaskSpecNetworks' (by applying it's required fields, if any)
mkTaskSpecNetworks
  :: TaskSpecNetworks
mkTaskSpecNetworks =
  TaskSpecNetworks
  { taskSpecNetworksTarget = Nothing
  , taskSpecNetworksAliases = Nothing
  }

-- ** TaskSpecPlacement
-- | TaskSpecPlacement
data TaskSpecPlacement = TaskSpecPlacement
  { taskSpecPlacementConstraints :: !(Maybe [Text]) -- ^ "Constraints" - An array of constraints.
  , taskSpecPlacementPreferences :: !(Maybe [TaskSpecPlacementPreferences]) -- ^ "Preferences" - Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.
  , taskSpecPlacementPlatforms :: !(Maybe [NodeDescriptionPlatform]) -- ^ "Platforms" - An array of supported platforms.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacement
instance A.FromJSON TaskSpecPlacement where
  parseJSON = A.withObject "TaskSpecPlacement" $ \o ->
    TaskSpecPlacement
      <$> (o .:? "Constraints")
      <*> (o .:? "Preferences")
      <*> (o .:? "Platforms")

-- | ToJSON TaskSpecPlacement
instance A.ToJSON TaskSpecPlacement where
  toJSON TaskSpecPlacement {..} =
   _omitNulls
      [ "Constraints" .= taskSpecPlacementConstraints
      , "Preferences" .= taskSpecPlacementPreferences
      , "Platforms" .= taskSpecPlacementPlatforms
      ]


-- | Construct a value of type 'TaskSpecPlacement' (by applying it's required fields, if any)
mkTaskSpecPlacement
  :: TaskSpecPlacement
mkTaskSpecPlacement =
  TaskSpecPlacement
  { taskSpecPlacementConstraints = Nothing
  , taskSpecPlacementPreferences = Nothing
  , taskSpecPlacementPlatforms = Nothing
  }

-- ** TaskSpecPlacementPreferences
-- | TaskSpecPlacementPreferences
data TaskSpecPlacementPreferences = TaskSpecPlacementPreferences
  { taskSpecPlacementPreferencesSpread :: !(Maybe TaskSpecPlacementSpread) -- ^ "Spread"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementPreferences
instance A.FromJSON TaskSpecPlacementPreferences where
  parseJSON = A.withObject "TaskSpecPlacementPreferences" $ \o ->
    TaskSpecPlacementPreferences
      <$> (o .:? "Spread")

-- | ToJSON TaskSpecPlacementPreferences
instance A.ToJSON TaskSpecPlacementPreferences where
  toJSON TaskSpecPlacementPreferences {..} =
   _omitNulls
      [ "Spread" .= taskSpecPlacementPreferencesSpread
      ]


-- | Construct a value of type 'TaskSpecPlacementPreferences' (by applying it's required fields, if any)
mkTaskSpecPlacementPreferences
  :: TaskSpecPlacementPreferences
mkTaskSpecPlacementPreferences =
  TaskSpecPlacementPreferences
  { taskSpecPlacementPreferencesSpread = Nothing
  }

-- ** TaskSpecPlacementSpread
-- | TaskSpecPlacementSpread
data TaskSpecPlacementSpread = TaskSpecPlacementSpread
  { taskSpecPlacementSpreadSpreadDescriptor :: !(Maybe Text) -- ^ "SpreadDescriptor" - label descriptor, such as engine.labels.az
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementSpread
instance A.FromJSON TaskSpecPlacementSpread where
  parseJSON = A.withObject "TaskSpecPlacementSpread" $ \o ->
    TaskSpecPlacementSpread
      <$> (o .:? "SpreadDescriptor")

-- | ToJSON TaskSpecPlacementSpread
instance A.ToJSON TaskSpecPlacementSpread where
  toJSON TaskSpecPlacementSpread {..} =
   _omitNulls
      [ "SpreadDescriptor" .= taskSpecPlacementSpreadSpreadDescriptor
      ]


-- | Construct a value of type 'TaskSpecPlacementSpread' (by applying it's required fields, if any)
mkTaskSpecPlacementSpread
  :: TaskSpecPlacementSpread
mkTaskSpecPlacementSpread =
  TaskSpecPlacementSpread
  { taskSpecPlacementSpreadSpreadDescriptor = Nothing
  }

-- ** TaskSpecResources
-- | TaskSpecResources
-- Resource requirements which apply to each individual container created as part of the service.
data TaskSpecResources = TaskSpecResources
  { taskSpecResourcesLimits :: !(Maybe TaskSpecResourcesLimits) -- ^ "Limits"
  , taskSpecResourcesReservation :: !(Maybe TaskSpecResourcesReservation) -- ^ "Reservation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResources
instance A.FromJSON TaskSpecResources where
  parseJSON = A.withObject "TaskSpecResources" $ \o ->
    TaskSpecResources
      <$> (o .:? "Limits")
      <*> (o .:? "Reservation")

-- | ToJSON TaskSpecResources
instance A.ToJSON TaskSpecResources where
  toJSON TaskSpecResources {..} =
   _omitNulls
      [ "Limits" .= taskSpecResourcesLimits
      , "Reservation" .= taskSpecResourcesReservation
      ]


-- | Construct a value of type 'TaskSpecResources' (by applying it's required fields, if any)
mkTaskSpecResources
  :: TaskSpecResources
mkTaskSpecResources =
  TaskSpecResources
  { taskSpecResourcesLimits = Nothing
  , taskSpecResourcesReservation = Nothing
  }

-- ** TaskSpecResourcesLimits
-- | TaskSpecResourcesLimits
-- Define resources limits.
data TaskSpecResourcesLimits = TaskSpecResourcesLimits
  { taskSpecResourcesLimitsNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU limit in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPU shares.
  , taskSpecResourcesLimitsMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes" - Memory limit in Bytes.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResourcesLimits
instance A.FromJSON TaskSpecResourcesLimits where
  parseJSON = A.withObject "TaskSpecResourcesLimits" $ \o ->
    TaskSpecResourcesLimits
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON TaskSpecResourcesLimits
instance A.ToJSON TaskSpecResourcesLimits where
  toJSON TaskSpecResourcesLimits {..} =
   _omitNulls
      [ "NanoCPUs" .= taskSpecResourcesLimitsNanoCpUs
      , "MemoryBytes" .= taskSpecResourcesLimitsMemoryBytes
      ]


-- | Construct a value of type 'TaskSpecResourcesLimits' (by applying it's required fields, if any)
mkTaskSpecResourcesLimits
  :: TaskSpecResourcesLimits
mkTaskSpecResourcesLimits =
  TaskSpecResourcesLimits
  { taskSpecResourcesLimitsNanoCpUs = Nothing
  , taskSpecResourcesLimitsMemoryBytes = Nothing
  }

-- ** TaskSpecResourcesReservation
-- | TaskSpecResourcesReservation
-- Define resources reservation.
data TaskSpecResourcesReservation = TaskSpecResourcesReservation
  { taskSpecResourcesReservationNanoCpUs :: !(Maybe Integer) -- ^ "NanoCPUs" - CPU reservation in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPU shares.
  , taskSpecResourcesReservationMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes" - Memory reservation in Bytes.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResourcesReservation
instance A.FromJSON TaskSpecResourcesReservation where
  parseJSON = A.withObject "TaskSpecResourcesReservation" $ \o ->
    TaskSpecResourcesReservation
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")

-- | ToJSON TaskSpecResourcesReservation
instance A.ToJSON TaskSpecResourcesReservation where
  toJSON TaskSpecResourcesReservation {..} =
   _omitNulls
      [ "NanoCPUs" .= taskSpecResourcesReservationNanoCpUs
      , "MemoryBytes" .= taskSpecResourcesReservationMemoryBytes
      ]


-- | Construct a value of type 'TaskSpecResourcesReservation' (by applying it's required fields, if any)
mkTaskSpecResourcesReservation
  :: TaskSpecResourcesReservation
mkTaskSpecResourcesReservation =
  TaskSpecResourcesReservation
  { taskSpecResourcesReservationNanoCpUs = Nothing
  , taskSpecResourcesReservationMemoryBytes = Nothing
  }

-- ** TaskSpecRestartPolicy
-- | TaskSpecRestartPolicy
-- Specification for the restart policy which applies to containers created as part of this service.
data TaskSpecRestartPolicy = TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition :: !(Maybe E'Condition) -- ^ "Condition" - Condition for restart.
  , taskSpecRestartPolicyDelay :: !(Maybe Integer) -- ^ "Delay" - Delay between restart attempts.
  , taskSpecRestartPolicyMaxAttempts :: !(Maybe Integer) -- ^ "MaxAttempts" - Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
  , taskSpecRestartPolicyWindow :: !(Maybe Integer) -- ^ "Window" - Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecRestartPolicy
instance A.FromJSON TaskSpecRestartPolicy where
  parseJSON = A.withObject "TaskSpecRestartPolicy" $ \o ->
    TaskSpecRestartPolicy
      <$> (o .:? "Condition")
      <*> (o .:? "Delay")
      <*> (o .:? "MaxAttempts")
      <*> (o .:? "Window")

-- | ToJSON TaskSpecRestartPolicy
instance A.ToJSON TaskSpecRestartPolicy where
  toJSON TaskSpecRestartPolicy {..} =
   _omitNulls
      [ "Condition" .= taskSpecRestartPolicyCondition
      , "Delay" .= taskSpecRestartPolicyDelay
      , "MaxAttempts" .= taskSpecRestartPolicyMaxAttempts
      , "Window" .= taskSpecRestartPolicyWindow
      ]


-- | Construct a value of type 'TaskSpecRestartPolicy' (by applying it's required fields, if any)
mkTaskSpecRestartPolicy
  :: TaskSpecRestartPolicy
mkTaskSpecRestartPolicy =
  TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition = Nothing
  , taskSpecRestartPolicyDelay = Nothing
  , taskSpecRestartPolicyMaxAttempts = Nothing
  , taskSpecRestartPolicyWindow = Nothing
  }

-- ** TaskStatus
-- | TaskStatus
data TaskStatus = TaskStatus
  { taskStatusTimestamp :: !(Maybe Text) -- ^ "Timestamp"
  , taskStatusState :: !(Maybe TaskState) -- ^ "State"
  , taskStatusMessage :: !(Maybe Text) -- ^ "Message"
  , taskStatusErr :: !(Maybe Text) -- ^ "Err"
  , taskStatusContainerStatus :: !(Maybe TaskStatusContainerStatus) -- ^ "ContainerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatus
instance A.FromJSON TaskStatus where
  parseJSON = A.withObject "TaskStatus" $ \o ->
    TaskStatus
      <$> (o .:? "Timestamp")
      <*> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Err")
      <*> (o .:? "ContainerStatus")

-- | ToJSON TaskStatus
instance A.ToJSON TaskStatus where
  toJSON TaskStatus {..} =
   _omitNulls
      [ "Timestamp" .= taskStatusTimestamp
      , "State" .= taskStatusState
      , "Message" .= taskStatusMessage
      , "Err" .= taskStatusErr
      , "ContainerStatus" .= taskStatusContainerStatus
      ]


-- | Construct a value of type 'TaskStatus' (by applying it's required fields, if any)
mkTaskStatus
  :: TaskStatus
mkTaskStatus =
  TaskStatus
  { taskStatusTimestamp = Nothing
  , taskStatusState = Nothing
  , taskStatusMessage = Nothing
  , taskStatusErr = Nothing
  , taskStatusContainerStatus = Nothing
  }

-- ** TaskStatusContainerStatus
-- | TaskStatusContainerStatus
data TaskStatusContainerStatus = TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , taskStatusContainerStatusPid :: !(Maybe Int) -- ^ "PID"
  , taskStatusContainerStatusExitCode :: !(Maybe Int) -- ^ "ExitCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatusContainerStatus
instance A.FromJSON TaskStatusContainerStatus where
  parseJSON = A.withObject "TaskStatusContainerStatus" $ \o ->
    TaskStatusContainerStatus
      <$> (o .:? "ContainerID")
      <*> (o .:? "PID")
      <*> (o .:? "ExitCode")

-- | ToJSON TaskStatusContainerStatus
instance A.ToJSON TaskStatusContainerStatus where
  toJSON TaskStatusContainerStatus {..} =
   _omitNulls
      [ "ContainerID" .= taskStatusContainerStatusContainerId
      , "PID" .= taskStatusContainerStatusPid
      , "ExitCode" .= taskStatusContainerStatusExitCode
      ]


-- | Construct a value of type 'TaskStatusContainerStatus' (by applying it's required fields, if any)
mkTaskStatusContainerStatus
  :: TaskStatusContainerStatus
mkTaskStatusContainerStatus =
  TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId = Nothing
  , taskStatusContainerStatusPid = Nothing
  , taskStatusContainerStatusExitCode = Nothing
  }

-- ** ThrottleDevice
-- | ThrottleDevice
data ThrottleDevice = ThrottleDevice
  { throttleDevicePath :: !(Maybe Text) -- ^ "Path" - Device path
  , throttleDeviceRate :: !(Maybe Integer) -- ^ "Rate" - Rate
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThrottleDevice
instance A.FromJSON ThrottleDevice where
  parseJSON = A.withObject "ThrottleDevice" $ \o ->
    ThrottleDevice
      <$> (o .:? "Path")
      <*> (o .:? "Rate")

-- | ToJSON ThrottleDevice
instance A.ToJSON ThrottleDevice where
  toJSON ThrottleDevice {..} =
   _omitNulls
      [ "Path" .= throttleDevicePath
      , "Rate" .= throttleDeviceRate
      ]


-- | Construct a value of type 'ThrottleDevice' (by applying it's required fields, if any)
mkThrottleDevice
  :: ThrottleDevice
mkThrottleDevice =
  ThrottleDevice
  { throttleDevicePath = Nothing
  , throttleDeviceRate = Nothing
  }

-- ** Volume
-- | Volume
data Volume = Volume
  { volumeName :: !(Text) -- ^ /Required/ "Name" - Name of the volume.
  , volumeDriver :: !(Text) -- ^ /Required/ "Driver" - Name of the volume driver used by the volume.
  , volumeMountpoint :: !(Text) -- ^ /Required/ "Mountpoint" - Mount path of the volume on the host.
  , volumeStatus :: !(Maybe (Map.Map String A.Value)) -- ^ "Status" - Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: &#x60;{\&quot;key\&quot;:\&quot;value\&quot;,\&quot;key2\&quot;:\&quot;value2\&quot;}&#x60;.  The &#x60;Status&#x60; field is optional, and is omitted if the volume driver does not support this feature. 
  , volumeLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels" - User-defined key/value metadata.
  , volumeScope :: !(E'Scope) -- ^ /Required/ "Scope" - The level at which the volume exists. Either &#x60;global&#x60; for cluster-wide, or &#x60;local&#x60; for machine level.
  , volumeOptions :: !((Map.Map String Text)) -- ^ /Required/ "Options" - The driver specific options used when creating the volume.
  , volumeUsageData :: !(Maybe VolumeUsageData) -- ^ "UsageData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Volume
instance A.FromJSON Volume where
  parseJSON = A.withObject "Volume" $ \o ->
    Volume
      <$> (o .:  "Name")
      <*> (o .:  "Driver")
      <*> (o .:  "Mountpoint")
      <*> (o .:? "Status")
      <*> (o .:  "Labels")
      <*> (o .:  "Scope")
      <*> (o .:  "Options")
      <*> (o .:? "UsageData")

-- | ToJSON Volume
instance A.ToJSON Volume where
  toJSON Volume {..} =
   _omitNulls
      [ "Name" .= volumeName
      , "Driver" .= volumeDriver
      , "Mountpoint" .= volumeMountpoint
      , "Status" .= volumeStatus
      , "Labels" .= volumeLabels
      , "Scope" .= volumeScope
      , "Options" .= volumeOptions
      , "UsageData" .= volumeUsageData
      ]


-- | Construct a value of type 'Volume' (by applying it's required fields, if any)
mkVolume
  :: Text -- ^ 'volumeName': Name of the volume.
  -> Text -- ^ 'volumeDriver': Name of the volume driver used by the volume.
  -> Text -- ^ 'volumeMountpoint': Mount path of the volume on the host.
  -> (Map.Map String Text) -- ^ 'volumeLabels': User-defined key/value metadata.
  -> E'Scope -- ^ 'volumeScope': The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
  -> (Map.Map String Text) -- ^ 'volumeOptions': The driver specific options used when creating the volume.
  -> Volume
mkVolume volumeName volumeDriver volumeMountpoint volumeLabels volumeScope volumeOptions =
  Volume
  { volumeName
  , volumeDriver
  , volumeMountpoint
  , volumeStatus = Nothing
  , volumeLabels
  , volumeScope
  , volumeOptions
  , volumeUsageData = Nothing
  }

-- ** VolumeUsageData
-- | VolumeUsageData
-- Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints. 
data VolumeUsageData = VolumeUsageData
  { volumeUsageDataSize :: !(Int) -- ^ /Required/ "Size" - Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the &#x60;\&quot;local\&quot;&#x60; volume driver. For volumes created with other volume drivers, this field is set to &#x60;-1&#x60; (\&quot;not available\&quot;) 
  , volumeUsageDataRefCount :: !(Int) -- ^ /Required/ "RefCount" - The number of containers referencing this volume. This field is set to &#x60;-1&#x60; if the reference-count is not available. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeUsageData
instance A.FromJSON VolumeUsageData where
  parseJSON = A.withObject "VolumeUsageData" $ \o ->
    VolumeUsageData
      <$> (o .:  "Size")
      <*> (o .:  "RefCount")

-- | ToJSON VolumeUsageData
instance A.ToJSON VolumeUsageData where
  toJSON VolumeUsageData {..} =
   _omitNulls
      [ "Size" .= volumeUsageDataSize
      , "RefCount" .= volumeUsageDataRefCount
      ]


-- | Construct a value of type 'VolumeUsageData' (by applying it's required fields, if any)
mkVolumeUsageData
  :: Int -- ^ 'volumeUsageDataSize': Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\") 
  -> Int -- ^ 'volumeUsageDataRefCount': The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available. 
  -> VolumeUsageData
mkVolumeUsageData volumeUsageDataSize volumeUsageDataRefCount =
  VolumeUsageData
  { volumeUsageDataSize
  , volumeUsageDataRefCount
  }


-- * Enums


-- ** E'Availability

-- | Enum of 'Text' . 
-- Availability of the node.
data E'Availability
  = E'Availability'Active -- ^ @"active"@
  | E'Availability'Pause -- ^ @"pause"@
  | E'Availability'Drain -- ^ @"drain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Availability where toJSON = A.toJSON . fromE'Availability
instance A.FromJSON E'Availability where parseJSON o = P.either P.fail (pure . P.id) . toE'Availability =<< A.parseJSON o
instance WH.ToHttpApiData E'Availability where toQueryParam = WH.toQueryParam . fromE'Availability
instance WH.FromHttpApiData E'Availability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Availability
instance MimeRender MimeMultipartFormData E'Availability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Availability' enum
fromE'Availability :: E'Availability -> Text
fromE'Availability = \case
  E'Availability'Active -> "active"
  E'Availability'Pause -> "pause"
  E'Availability'Drain -> "drain"

-- | parse 'E'Availability' enum
toE'Availability :: Text -> P.Either String E'Availability
toE'Availability = \case
  "active" -> P.Right E'Availability'Active
  "pause" -> P.Right E'Availability'Pause
  "drain" -> P.Right E'Availability'Drain
  s -> P.Left $ "toE'Availability: enum parse failure: " P.++ P.show s


-- ** E'Condition

-- | Enum of 'Text' . 
-- Condition for restart.
data E'Condition
  = E'Condition'None -- ^ @"none"@
  | E'Condition'On_failure -- ^ @"on-failure"@
  | E'Condition'Any -- ^ @"any"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition where toJSON = A.toJSON . fromE'Condition
instance A.FromJSON E'Condition where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition where toQueryParam = WH.toQueryParam . fromE'Condition
instance WH.FromHttpApiData E'Condition where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition
instance MimeRender MimeMultipartFormData E'Condition where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition' enum
fromE'Condition :: E'Condition -> Text
fromE'Condition = \case
  E'Condition'None -> "none"
  E'Condition'On_failure -> "on-failure"
  E'Condition'Any -> "any"

-- | parse 'E'Condition' enum
toE'Condition :: Text -> P.Either String E'Condition
toE'Condition = \case
  "none" -> P.Right E'Condition'None
  "on-failure" -> P.Right E'Condition'On_failure
  "any" -> P.Right E'Condition'Any
  s -> P.Left $ "toE'Condition: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Application_x_tar -- ^ @"application/x-tar"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Application_x_tar -> "application/x-tar"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/x-tar" -> P.Right E'ContentType'Application_x_tar
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'FailureAction

-- | Enum of 'Text' . 
-- Action to take if an updated task fails to run, or stops running during the update.
data E'FailureAction
  = E'FailureAction'Continue -- ^ @"continue"@
  | E'FailureAction'Pause -- ^ @"pause"@
  | E'FailureAction'Rollback -- ^ @"rollback"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction where toJSON = A.toJSON . fromE'FailureAction
instance A.FromJSON E'FailureAction where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction where toQueryParam = WH.toQueryParam . fromE'FailureAction
instance WH.FromHttpApiData E'FailureAction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction
instance MimeRender MimeMultipartFormData E'FailureAction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction' enum
fromE'FailureAction :: E'FailureAction -> Text
fromE'FailureAction = \case
  E'FailureAction'Continue -> "continue"
  E'FailureAction'Pause -> "pause"
  E'FailureAction'Rollback -> "rollback"

-- | parse 'E'FailureAction' enum
toE'FailureAction :: Text -> P.Either String E'FailureAction
toE'FailureAction = \case
  "continue" -> P.Right E'FailureAction'Continue
  "pause" -> P.Right E'FailureAction'Pause
  "rollback" -> P.Right E'FailureAction'Rollback
  s -> P.Left $ "toE'FailureAction: enum parse failure: " P.++ P.show s


-- ** E'FailureAction2

-- | Enum of 'Text' . 
-- Action to take if an rolled back task fails to run, or stops running during the rollback.
data E'FailureAction2
  = E'FailureAction2'Continue -- ^ @"continue"@
  | E'FailureAction2'Pause -- ^ @"pause"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction2 where toJSON = A.toJSON . fromE'FailureAction2
instance A.FromJSON E'FailureAction2 where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction2 =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction2 where toQueryParam = WH.toQueryParam . fromE'FailureAction2
instance WH.FromHttpApiData E'FailureAction2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction2
instance MimeRender MimeMultipartFormData E'FailureAction2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction2' enum
fromE'FailureAction2 :: E'FailureAction2 -> Text
fromE'FailureAction2 = \case
  E'FailureAction2'Continue -> "continue"
  E'FailureAction2'Pause -> "pause"

-- | parse 'E'FailureAction2' enum
toE'FailureAction2 :: Text -> P.Either String E'FailureAction2
toE'FailureAction2 = \case
  "continue" -> P.Right E'FailureAction2'Continue
  "pause" -> P.Right E'FailureAction2'Pause
  s -> P.Left $ "toE'FailureAction2: enum parse failure: " P.++ P.show s


-- ** E'Isolation

-- | Enum of 'Text' . 
-- Isolation technology of the container. (Windows only)
data E'Isolation
  = E'Isolation'Default -- ^ @"default"@
  | E'Isolation'Process -- ^ @"process"@
  | E'Isolation'Hyperv -- ^ @"hyperv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation where toJSON = A.toJSON . fromE'Isolation
instance A.FromJSON E'Isolation where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation where toQueryParam = WH.toQueryParam . fromE'Isolation
instance WH.FromHttpApiData E'Isolation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation
instance MimeRender MimeMultipartFormData E'Isolation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation' enum
fromE'Isolation :: E'Isolation -> Text
fromE'Isolation = \case
  E'Isolation'Default -> "default"
  E'Isolation'Process -> "process"
  E'Isolation'Hyperv -> "hyperv"

-- | parse 'E'Isolation' enum
toE'Isolation :: Text -> P.Either String E'Isolation
toE'Isolation = \case
  "default" -> P.Right E'Isolation'Default
  "process" -> P.Right E'Isolation'Process
  "hyperv" -> P.Right E'Isolation'Hyperv
  s -> P.Left $ "toE'Isolation: enum parse failure: " P.++ P.show s


-- ** E'Mode

-- | Enum of 'Text' . 
-- The mode of resolution to use for internal load balancing between tasks.
data E'Mode
  = E'Mode'Vip -- ^ @"vip"@
  | E'Mode'Dnsrr -- ^ @"dnsrr"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode where toJSON = A.toJSON . fromE'Mode
instance A.FromJSON E'Mode where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode where toQueryParam = WH.toQueryParam . fromE'Mode
instance WH.FromHttpApiData E'Mode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode
instance MimeRender MimeMultipartFormData E'Mode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode' enum
fromE'Mode :: E'Mode -> Text
fromE'Mode = \case
  E'Mode'Vip -> "vip"
  E'Mode'Dnsrr -> "dnsrr"

-- | parse 'E'Mode' enum
toE'Mode :: Text -> P.Either String E'Mode
toE'Mode = \case
  "vip" -> P.Right E'Mode'Vip
  "dnsrr" -> P.Right E'Mode'Dnsrr
  s -> P.Left $ "toE'Mode: enum parse failure: " P.++ P.show s


-- ** E'Name

-- | Enum of 'Text' . 
-- - Empty string means not to restart - `always` Always restart - `unless-stopped` Restart always except when the user has manually stopped the container - `on-failure` Restart only when the container exit code is non-zero 
data E'Name
  = E'Name'Empty -- ^ @""@
  | E'Name'Always -- ^ @"always"@
  | E'Name'Unless_stopped -- ^ @"unless-stopped"@
  | E'Name'On_failure -- ^ @"on-failure"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Name where toJSON = A.toJSON . fromE'Name
instance A.FromJSON E'Name where parseJSON o = P.either P.fail (pure . P.id) . toE'Name =<< A.parseJSON o
instance WH.ToHttpApiData E'Name where toQueryParam = WH.toQueryParam . fromE'Name
instance WH.FromHttpApiData E'Name where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Name
instance MimeRender MimeMultipartFormData E'Name where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Name' enum
fromE'Name :: E'Name -> Text
fromE'Name = \case
  E'Name'Empty -> ""
  E'Name'Always -> "always"
  E'Name'Unless_stopped -> "unless-stopped"
  E'Name'On_failure -> "on-failure"

-- | parse 'E'Name' enum
toE'Name :: Text -> P.Either String E'Name
toE'Name = \case
  "" -> P.Right E'Name'Empty
  "always" -> P.Right E'Name'Always
  "unless-stopped" -> P.Right E'Name'Unless_stopped
  "on-failure" -> P.Right E'Name'On_failure
  s -> P.Left $ "toE'Name: enum parse failure: " P.++ P.show s


-- ** E'Order

-- | Enum of 'Text' . 
-- The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
data E'Order
  = E'Order'Stop_first -- ^ @"stop-first"@
  | E'Order'Start_first -- ^ @"start-first"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Order where toJSON = A.toJSON . fromE'Order
instance A.FromJSON E'Order where parseJSON o = P.either P.fail (pure . P.id) . toE'Order =<< A.parseJSON o
instance WH.ToHttpApiData E'Order where toQueryParam = WH.toQueryParam . fromE'Order
instance WH.FromHttpApiData E'Order where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Order
instance MimeRender MimeMultipartFormData E'Order where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Order' enum
fromE'Order :: E'Order -> Text
fromE'Order = \case
  E'Order'Stop_first -> "stop-first"
  E'Order'Start_first -> "start-first"

-- | parse 'E'Order' enum
toE'Order :: Text -> P.Either String E'Order
toE'Order = \case
  "stop-first" -> P.Right E'Order'Stop_first
  "start-first" -> P.Right E'Order'Start_first
  s -> P.Left $ "toE'Order: enum parse failure: " P.++ P.show s


-- ** E'Protocol

-- | Enum of 'Text' . 
-- Protocol for communication with the external CA (currently only `cfssl` is supported).
data E'Protocol
  = E'Protocol'Cfssl -- ^ @"cfssl"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Protocol where toJSON = A.toJSON . fromE'Protocol
instance A.FromJSON E'Protocol where parseJSON o = P.either P.fail (pure . P.id) . toE'Protocol =<< A.parseJSON o
instance WH.ToHttpApiData E'Protocol where toQueryParam = WH.toQueryParam . fromE'Protocol
instance WH.FromHttpApiData E'Protocol where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Protocol
instance MimeRender MimeMultipartFormData E'Protocol where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Protocol' enum
fromE'Protocol :: E'Protocol -> Text
fromE'Protocol = \case
  E'Protocol'Cfssl -> "cfssl"

-- | parse 'E'Protocol' enum
toE'Protocol :: Text -> P.Either String E'Protocol
toE'Protocol = \case
  "cfssl" -> P.Right E'Protocol'Cfssl
  s -> P.Left $ "toE'Protocol: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' . 
-- Role of the node.
data E'Role
  = E'Role'Worker -- ^ @"worker"@
  | E'Role'Manager -- ^ @"manager"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'Worker -> "worker"
  E'Role'Manager -> "manager"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "worker" -> P.Right E'Role'Worker
  "manager" -> P.Right E'Role'Manager
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Scope

-- | Enum of 'Text' . 
-- The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
data E'Scope
  = E'Scope'Local -- ^ @"local"@
  | E'Scope'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope where toJSON = A.toJSON . fromE'Scope
instance A.FromJSON E'Scope where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope where toQueryParam = WH.toQueryParam . fromE'Scope
instance WH.FromHttpApiData E'Scope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope
instance MimeRender MimeMultipartFormData E'Scope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope' enum
fromE'Scope :: E'Scope -> Text
fromE'Scope = \case
  E'Scope'Local -> "local"
  E'Scope'Global -> "global"

-- | parse 'E'Scope' enum
toE'Scope :: Text -> P.Either String E'Scope
toE'Scope = \case
  "local" -> P.Right E'Scope'Local
  "global" -> P.Right E'Scope'Global
  s -> P.Left $ "toE'Scope: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Updating -- ^ @"updating"@
  | E'State'Paused -- ^ @"paused"@
  | E'State'Completed -- ^ @"completed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Updating -> "updating"
  E'State'Paused -> "paused"
  E'State'Completed -> "completed"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "updating" -> P.Right E'State'Updating
  "paused" -> P.Right E'State'Paused
  "completed" -> P.Right E'State'Completed
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' . 
-- The status of the container. For example, `\"running\"` or `\"exited\"`. 
data E'Status
  = E'Status'Created -- ^ @"created"@
  | E'Status'Running -- ^ @"running"@
  | E'Status'Paused -- ^ @"paused"@
  | E'Status'Restarting -- ^ @"restarting"@
  | E'Status'Removing -- ^ @"removing"@
  | E'Status'Exited -- ^ @"exited"@
  | E'Status'Dead -- ^ @"dead"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Created -> "created"
  E'Status'Running -> "running"
  E'Status'Paused -> "paused"
  E'Status'Restarting -> "restarting"
  E'Status'Removing -> "removing"
  E'Status'Exited -> "exited"
  E'Status'Dead -> "dead"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "created" -> P.Right E'Status'Created
  "running" -> P.Right E'Status'Running
  "paused" -> P.Right E'Status'Paused
  "restarting" -> P.Right E'Status'Restarting
  "removing" -> P.Right E'Status'Removing
  "exited" -> P.Right E'Status'Exited
  "dead" -> P.Right E'Status'Dead
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Tcp -- ^ @"tcp"@
  | E'Type'Udp -- ^ @"udp"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Tcp -> "tcp"
  E'Type'Udp -> "udp"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "tcp" -> P.Right E'Type'Tcp
  "udp" -> P.Right E'Type'Udp
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' . 
-- The mount type. Available types:  - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container. - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
data E'Type2
  = E'Type2'Bind -- ^ @"bind"@
  | E'Type2'Volume -- ^ @"volume"@
  | E'Type2'Tmpfs -- ^ @"tmpfs"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Bind -> "bind"
  E'Type2'Volume -> "volume"
  E'Type2'Tmpfs -> "tmpfs"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "bind" -> P.Right E'Type2'Bind
  "volume" -> P.Right E'Type2'Volume
  "tmpfs" -> P.Right E'Type2'Tmpfs
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'Json_file -- ^ @"json-file"@
  | E'Type3'Syslog -- ^ @"syslog"@
  | E'Type3'Journald -- ^ @"journald"@
  | E'Type3'Gelf -- ^ @"gelf"@
  | E'Type3'Fluentd -- ^ @"fluentd"@
  | E'Type3'Awslogs -- ^ @"awslogs"@
  | E'Type3'Splunk -- ^ @"splunk"@
  | E'Type3'Etwlogs -- ^ @"etwlogs"@
  | E'Type3'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Json_file -> "json-file"
  E'Type3'Syslog -> "syslog"
  E'Type3'Journald -> "journald"
  E'Type3'Gelf -> "gelf"
  E'Type3'Fluentd -> "fluentd"
  E'Type3'Awslogs -> "awslogs"
  E'Type3'Splunk -> "splunk"
  E'Type3'Etwlogs -> "etwlogs"
  E'Type3'None -> "none"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "json-file" -> P.Right E'Type3'Json_file
  "syslog" -> P.Right E'Type3'Syslog
  "journald" -> P.Right E'Type3'Journald
  "gelf" -> P.Right E'Type3'Gelf
  "fluentd" -> P.Right E'Type3'Fluentd
  "awslogs" -> P.Right E'Type3'Awslogs
  "splunk" -> P.Right E'Type3'Splunk
  "etwlogs" -> P.Right E'Type3'Etwlogs
  "none" -> P.Right E'Type3'None
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** TaskState

-- | Enum of 'Text'
data TaskState
  = TaskState'New -- ^ @"new"@
  | TaskState'Allocated -- ^ @"allocated"@
  | TaskState'Pending -- ^ @"pending"@
  | TaskState'Assigned -- ^ @"assigned"@
  | TaskState'Accepted -- ^ @"accepted"@
  | TaskState'Preparing -- ^ @"preparing"@
  | TaskState'Ready -- ^ @"ready"@
  | TaskState'Starting -- ^ @"starting"@
  | TaskState'Running -- ^ @"running"@
  | TaskState'Complete -- ^ @"complete"@
  | TaskState'Shutdown -- ^ @"shutdown"@
  | TaskState'Failed -- ^ @"failed"@
  | TaskState'Rejected -- ^ @"rejected"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TaskState where toJSON = A.toJSON . fromTaskState
instance A.FromJSON TaskState where parseJSON o = P.either P.fail (pure . P.id) . toTaskState =<< A.parseJSON o
instance WH.ToHttpApiData TaskState where toQueryParam = WH.toQueryParam . fromTaskState
instance WH.FromHttpApiData TaskState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTaskState
instance MimeRender MimeMultipartFormData TaskState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TaskState' enum
fromTaskState :: TaskState -> Text
fromTaskState = \case
  TaskState'New -> "new"
  TaskState'Allocated -> "allocated"
  TaskState'Pending -> "pending"
  TaskState'Assigned -> "assigned"
  TaskState'Accepted -> "accepted"
  TaskState'Preparing -> "preparing"
  TaskState'Ready -> "ready"
  TaskState'Starting -> "starting"
  TaskState'Running -> "running"
  TaskState'Complete -> "complete"
  TaskState'Shutdown -> "shutdown"
  TaskState'Failed -> "failed"
  TaskState'Rejected -> "rejected"

-- | parse 'TaskState' enum
toTaskState :: Text -> P.Either String TaskState
toTaskState = \case
  "new" -> P.Right TaskState'New
  "allocated" -> P.Right TaskState'Allocated
  "pending" -> P.Right TaskState'Pending
  "assigned" -> P.Right TaskState'Assigned
  "accepted" -> P.Right TaskState'Accepted
  "preparing" -> P.Right TaskState'Preparing
  "ready" -> P.Right TaskState'Ready
  "starting" -> P.Right TaskState'Starting
  "running" -> P.Right TaskState'Running
  "complete" -> P.Right TaskState'Complete
  "shutdown" -> P.Right TaskState'Shutdown
  "failed" -> P.Right TaskState'Failed
  "rejected" -> P.Right TaskState'Rejected
  s -> P.Left $ "toTaskState: enum parse failure: " P.++ P.show s



