{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.36) is used. For example, calling `/info` is the same as calling `/v1.36/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a Base64 encoded (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 

   OpenAPI Version: 3.0.1
   Docker Engine API API version: 1.36
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : DockerEngine.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.Model where

import DockerEngine.Core
import DockerEngine.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** All
newtype All = All { unAll :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: [PluginPullRequestInner] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** BodyText
newtype BodyText = BodyText { unBodyText :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Buildargs
newtype Buildargs = Buildargs { unBuildargs :: Int } deriving (P.Eq, P.Show)

-- ** Cachefrom
newtype Cachefrom = Cachefrom { unCachefrom :: Text } deriving (P.Eq, P.Show)

-- ** Changes
newtype Changes = Changes { unChanges :: Text } deriving (P.Eq, P.Show)

-- ** Comment
newtype Comment = Comment { unComment :: Text } deriving (P.Eq, P.Show)

-- ** Condition
newtype Condition = Condition { unCondition :: E'Condition2 } deriving (P.Eq, P.Show)

-- ** Container
newtype Container = Container { unContainer :: Text } deriving (P.Eq, P.Show)

-- ** Cpuperiod
newtype Cpuperiod = Cpuperiod { unCpuperiod :: Int } deriving (P.Eq, P.Show)

-- ** Cpuquota
newtype Cpuquota = Cpuquota { unCpuquota :: Int } deriving (P.Eq, P.Show)

-- ** Cpusetcpus
newtype Cpusetcpus = Cpusetcpus { unCpusetcpus :: Text } deriving (P.Eq, P.Show)

-- ** Cpushares
newtype Cpushares = Cpushares { unCpushares :: Int } deriving (P.Eq, P.Show)

-- ** DetachKeys
newtype DetachKeys = DetachKeys { unDetachKeys :: Text } deriving (P.Eq, P.Show)

-- ** Details
newtype Details = Details { unDetails :: Bool } deriving (P.Eq, P.Show)

-- ** Digests
newtype Digests = Digests { unDigests :: Bool } deriving (P.Eq, P.Show)

-- ** Dockerfile
newtype Dockerfile = Dockerfile { unDockerfile :: Text } deriving (P.Eq, P.Show)

-- ** Extrahosts
newtype Extrahosts = Extrahosts { unExtrahosts :: Text } deriving (P.Eq, P.Show)

-- ** Filters
newtype Filters = Filters { unFilters :: Text } deriving (P.Eq, P.Show)

-- ** Follow
newtype Follow = Follow { unFollow :: Bool } deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)

-- ** Forcerm
newtype Forcerm = Forcerm { unForcerm :: Bool } deriving (P.Eq, P.Show)

-- ** FromImage
newtype FromImage = FromImage { unFromImage :: Text } deriving (P.Eq, P.Show)

-- ** FromSrc
newtype FromSrc = FromSrc { unFromSrc :: Text } deriving (P.Eq, P.Show)

-- ** H
newtype H = H { unH :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** ImagesTarball
newtype ImagesTarball = ImagesTarball { unImagesTarball :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputImage
newtype InputImage = InputImage { unInputImage :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputStream
newtype InputStream = InputStream { unInputStream :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputStreamFilePath
newtype InputStreamFilePath = InputStreamFilePath { unInputStreamFilePath :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InsertDefaults
newtype InsertDefaults = InsertDefaults { unInsertDefaults :: Bool } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Link
newtype Link = Link { unLink :: Bool } deriving (P.Eq, P.Show)

-- ** Logs
newtype Logs = Logs { unLogs :: Bool } deriving (P.Eq, P.Show)

-- ** Memory
newtype Memory = Memory { unMemory :: Int } deriving (P.Eq, P.Show)

-- ** Memswap
newtype Memswap = Memswap { unMemswap :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Names
newtype Names = Names { unNames :: [Text] } deriving (P.Eq, P.Show)

-- ** Networkmode
newtype Networkmode = Networkmode { unNetworkmode :: Text } deriving (P.Eq, P.Show)

-- ** NoOverwriteDirNonDir
newtype NoOverwriteDirNonDir = NoOverwriteDirNonDir { unNoOverwriteDirNonDir :: Text } deriving (P.Eq, P.Show)

-- ** Nocache
newtype Nocache = Nocache { unNocache :: Bool } deriving (P.Eq, P.Show)

-- ** Noprune
newtype Noprune = Noprune { unNoprune :: Bool } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** Pause
newtype Pause = Pause { unPause :: Bool } deriving (P.Eq, P.Show)

-- ** Platform2
newtype Platform2 = Platform2 { unPlatform2 :: Text } deriving (P.Eq, P.Show)

-- ** PsArgs
newtype PsArgs = PsArgs { unPsArgs :: Text } deriving (P.Eq, P.Show)

-- ** Pull
newtype Pull = Pull { unPull :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Bool } deriving (P.Eq, P.Show)

-- ** Quiet
newtype Quiet = Quiet { unQuiet :: Bool } deriving (P.Eq, P.Show)

-- ** RegistryAuthFrom
newtype RegistryAuthFrom = RegistryAuthFrom { unRegistryAuthFrom :: Text } deriving (P.Eq, P.Show)

-- ** Remote
newtype Remote = Remote { unRemote :: Text } deriving (P.Eq, P.Show)

-- ** Repo
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)

-- ** Rm
newtype Rm = Rm { unRm :: Bool } deriving (P.Eq, P.Show)

-- ** Rollback
newtype Rollback = Rollback { unRollback :: Text } deriving (P.Eq, P.Show)

-- ** RotateManagerToken
newtype RotateManagerToken = RotateManagerToken { unRotateManagerToken :: Bool } deriving (P.Eq, P.Show)

-- ** RotateManagerUnlockKey
newtype RotateManagerUnlockKey = RotateManagerUnlockKey { unRotateManagerUnlockKey :: Bool } deriving (P.Eq, P.Show)

-- ** RotateWorkerToken
newtype RotateWorkerToken = RotateWorkerToken { unRotateWorkerToken :: Bool } deriving (P.Eq, P.Show)

-- ** Scope
newtype Scope = Scope { unScope :: Text } deriving (P.Eq, P.Show)

-- ** Shmsize
newtype Shmsize = Shmsize { unShmsize :: Int } deriving (P.Eq, P.Show)

-- ** Signal
newtype Signal = Signal { unSignal :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Int } deriving (P.Eq, P.Show)

-- ** SinceText
newtype SinceText = SinceText { unSinceText :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Bool } deriving (P.Eq, P.Show)

-- ** Squash
newtype Squash = Squash { unSquash :: Bool } deriving (P.Eq, P.Show)

-- ** Stderr
newtype Stderr = Stderr { unStderr :: Bool } deriving (P.Eq, P.Show)

-- ** Stdin
newtype Stdin = Stdin { unStdin :: Bool } deriving (P.Eq, P.Show)

-- ** Stdout
newtype Stdout = Stdout { unStdout :: Bool } deriving (P.Eq, P.Show)

-- ** Stream
newtype Stream = Stream { unStream :: Bool } deriving (P.Eq, P.Show)

-- ** T
newtype T = T { unT :: Int } deriving (P.Eq, P.Show)

-- ** TText
newtype TText = TText { unTText :: Text } deriving (P.Eq, P.Show)

-- ** Tag
newtype Tag = Tag { unTag :: Text } deriving (P.Eq, P.Show)

-- ** Tail
newtype Tail = Tail { unTail :: Text } deriving (P.Eq, P.Show)

-- ** TarContext
newtype TarContext = TarContext { unTarContext :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Term
newtype Term = Term { unTerm :: Text } deriving (P.Eq, P.Show)

-- ** Timeout
newtype Timeout = Timeout { unTimeout :: Int } deriving (P.Eq, P.Show)

-- ** Timestamps
newtype Timestamps = Timestamps { unTimestamps :: Bool } deriving (P.Eq, P.Show)

-- ** Until
newtype Until = Until { unUntil :: Int } deriving (P.Eq, P.Show)

-- ** UntilText
newtype UntilText = UntilText { unUntilText :: Text } deriving (P.Eq, P.Show)

-- ** V
newtype V = V { unV :: Bool } deriving (P.Eq, P.Show)

-- ** Verbose
newtype Verbose = Verbose { unVerbose :: Bool } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Integer } deriving (P.Eq, P.Show)

-- ** VersionInt
newtype VersionInt = VersionInt { unVersionInt :: Int } deriving (P.Eq, P.Show)

-- ** W
newtype W = W { unW :: Int } deriving (P.Eq, P.Show)

-- ** XRegistryAuth
newtype XRegistryAuth = XRegistryAuth { unXRegistryAuth :: Text } deriving (P.Eq, P.Show)

-- ** XRegistryConfig
newtype XRegistryConfig = XRegistryConfig { unXRegistryConfig :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Address
-- | Address
-- Address represents an IPv4 or IPv6 IP address.
data Address = Address
  { addressAddr :: !(Maybe Text) -- ^ "Addr" - IP address.
  , addressPrefixLen :: !(Maybe Int) -- ^ "PrefixLen" - Mask length of the IP address.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Address
instance A.FromJSON Address where
  parseJSON = A.withObject "Address" $ \o ->
    Address
      <$> (o .:? "Addr")
      <*> (o .:? "PrefixLen")

-- | ToJSON Address
instance A.ToJSON Address where
  toJSON Address {..} =
   _omitNulls
      [ "Addr" .= addressAddr
      , "PrefixLen" .= addressPrefixLen
      ]


-- | Construct a value of type 'Address' (by applying it's required fields, if any)
mkAddress
  :: Address
mkAddress =
  Address
  { addressAddr = Nothing
  , addressPrefixLen = Nothing
  }

-- ** AuthConfig
-- | AuthConfig
data AuthConfig = AuthConfig
  { authConfigUsername :: !(Maybe Text) -- ^ "username"
  , authConfigPassword :: !(Maybe Text) -- ^ "password"
  , authConfigEmail :: !(Maybe Text) -- ^ "email"
  , authConfigServeraddress :: !(Maybe Text) -- ^ "serveraddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthConfig
instance A.FromJSON AuthConfig where
  parseJSON = A.withObject "AuthConfig" $ \o ->
    AuthConfig
      <$> (o .:? "username")
      <*> (o .:? "password")
      <*> (o .:? "email")
      <*> (o .:? "serveraddress")

-- | ToJSON AuthConfig
instance A.ToJSON AuthConfig where
  toJSON AuthConfig {..} =
   _omitNulls
      [ "username" .= authConfigUsername
      , "password" .= authConfigPassword
      , "email" .= authConfigEmail
      , "serveraddress" .= authConfigServeraddress
      ]


-- | Construct a value of type 'AuthConfig' (by applying it's required fields, if any)
mkAuthConfig
  :: AuthConfig
mkAuthConfig =
  AuthConfig
  { authConfigUsername = Nothing
  , authConfigPassword = Nothing
  , authConfigEmail = Nothing
  , authConfigServeraddress = Nothing
  }

-- ** BuildInfo
-- | BuildInfo
data BuildInfo = BuildInfo
  { buildInfoId :: !(Maybe Text) -- ^ "id"
  , buildInfoStream :: !(Maybe Text) -- ^ "stream"
  , buildInfoError :: !(Maybe Text) -- ^ "error"
  , buildInfoErrorDetail :: !(Maybe ErrorDetail) -- ^ "errorDetail"
  , buildInfoStatus :: !(Maybe Text) -- ^ "status"
  , buildInfoProgress :: !(Maybe Text) -- ^ "progress"
  , buildInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  , buildInfoAux :: !(Maybe ImageID) -- ^ "aux"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildInfo
instance A.FromJSON BuildInfo where
  parseJSON = A.withObject "BuildInfo" $ \o ->
    BuildInfo
      <$> (o .:? "id")
      <*> (o .:? "stream")
      <*> (o .:? "error")
      <*> (o .:? "errorDetail")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")
      <*> (o .:? "aux")

-- | ToJSON BuildInfo
instance A.ToJSON BuildInfo where
  toJSON BuildInfo {..} =
   _omitNulls
      [ "id" .= buildInfoId
      , "stream" .= buildInfoStream
      , "error" .= buildInfoError
      , "errorDetail" .= buildInfoErrorDetail
      , "status" .= buildInfoStatus
      , "progress" .= buildInfoProgress
      , "progressDetail" .= buildInfoProgressDetail
      , "aux" .= buildInfoAux
      ]


-- | Construct a value of type 'BuildInfo' (by applying it's required fields, if any)
mkBuildInfo
  :: BuildInfo
mkBuildInfo =
  BuildInfo
  { buildInfoId = Nothing
  , buildInfoStream = Nothing
  , buildInfoError = Nothing
  , buildInfoErrorDetail = Nothing
  , buildInfoStatus = Nothing
  , buildInfoProgress = Nothing
  , buildInfoProgressDetail = Nothing
  , buildInfoAux = Nothing
  }

-- ** BuildPruneResponse
-- | BuildPruneResponse
-- BuildPruneResponse
-- 
data BuildPruneResponse = BuildPruneResponse
  { buildPruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildPruneResponse
instance A.FromJSON BuildPruneResponse where
  parseJSON = A.withObject "BuildPruneResponse" $ \o ->
    BuildPruneResponse
      <$> (o .:? "SpaceReclaimed")

-- | ToJSON BuildPruneResponse
instance A.ToJSON BuildPruneResponse where
  toJSON BuildPruneResponse {..} =
   _omitNulls
      [ "SpaceReclaimed" .= buildPruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'BuildPruneResponse' (by applying it's required fields, if any)
mkBuildPruneResponse
  :: BuildPruneResponse
mkBuildPruneResponse =
  BuildPruneResponse
  { buildPruneResponseSpaceReclaimed = Nothing
  }

-- ** ClusterInfo
-- | ClusterInfo
-- ClusterInfo represents information about the swarm as is returned by the \"/info\" endpoint. Join-tokens are not included. 
data ClusterInfo = ClusterInfo
  { clusterInfoId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , clusterInfoVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , clusterInfoCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the swarm was initialised in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , clusterInfoUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the swarm was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , clusterInfoSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  , clusterInfoTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  , clusterInfoRootRotationInProgress :: !(Maybe Bool) -- ^ "RootRotationInProgress" - Whether there is currently a root CA rotation in progress for the swarm
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClusterInfo
instance A.FromJSON ClusterInfo where
  parseJSON = A.withObject "ClusterInfo" $ \o ->
    ClusterInfo
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "TLSInfo")
      <*> (o .:? "RootRotationInProgress")

-- | ToJSON ClusterInfo
instance A.ToJSON ClusterInfo where
  toJSON ClusterInfo {..} =
   _omitNulls
      [ "ID" .= clusterInfoId
      , "Version" .= clusterInfoVersion
      , "CreatedAt" .= clusterInfoCreatedAt
      , "UpdatedAt" .= clusterInfoUpdatedAt
      , "Spec" .= clusterInfoSpec
      , "TLSInfo" .= clusterInfoTlsInfo
      , "RootRotationInProgress" .= clusterInfoRootRotationInProgress
      ]


-- | Construct a value of type 'ClusterInfo' (by applying it's required fields, if any)
mkClusterInfo
  :: ClusterInfo
mkClusterInfo =
  ClusterInfo
  { clusterInfoId = Nothing
  , clusterInfoVersion = Nothing
  , clusterInfoCreatedAt = Nothing
  , clusterInfoUpdatedAt = Nothing
  , clusterInfoSpec = Nothing
  , clusterInfoTlsInfo = Nothing
  , clusterInfoRootRotationInProgress = Nothing
  }

-- ** Commit
-- | Commit
-- Commit holds the Git-commit (SHA1) that a binary was built from, as reported in the version-string of external tools, such as `containerd`, or `runC`. 
data Commit = Commit
  { commitId :: !(Maybe Text) -- ^ "ID" - Actual commit ID of external tool.
  , commitExpected :: !(Maybe Text) -- ^ "Expected" - Commit ID of external tool expected by dockerd as set at build time. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Commit
instance A.FromJSON Commit where
  parseJSON = A.withObject "Commit" $ \o ->
    Commit
      <$> (o .:? "ID")
      <*> (o .:? "Expected")

-- | ToJSON Commit
instance A.ToJSON Commit where
  toJSON Commit {..} =
   _omitNulls
      [ "ID" .= commitId
      , "Expected" .= commitExpected
      ]


-- | Construct a value of type 'Commit' (by applying it's required fields, if any)
mkCommit
  :: Commit
mkCommit =
  Commit
  { commitId = Nothing
  , commitExpected = Nothing
  }

-- ** Config
-- | Config
data Config = Config
  { configId :: !(Maybe Text) -- ^ "ID"
  , configVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , configCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , configUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , configSpec :: !(Maybe ConfigSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Config
instance A.FromJSON Config where
  parseJSON = A.withObject "Config" $ \o ->
    Config
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Config
instance A.ToJSON Config where
  toJSON Config {..} =
   _omitNulls
      [ "ID" .= configId
      , "Version" .= configVersion
      , "CreatedAt" .= configCreatedAt
      , "UpdatedAt" .= configUpdatedAt
      , "Spec" .= configSpec
      ]


-- | Construct a value of type 'Config' (by applying it's required fields, if any)
mkConfig
  :: Config
mkConfig =
  Config
  { configId = Nothing
  , configVersion = Nothing
  , configCreatedAt = Nothing
  , configUpdatedAt = Nothing
  , configSpec = Nothing
  }

-- ** ConfigCreateRequest
-- | ConfigCreateRequest
data ConfigCreateRequest = ConfigCreateRequest
  { configCreateRequestName :: !(Maybe Text) -- ^ "Name" - User-defined name of the config.
  , configCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , configCreateRequestData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2)) config data. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigCreateRequest
instance A.FromJSON ConfigCreateRequest where
  parseJSON = A.withObject "ConfigCreateRequest" $ \o ->
    ConfigCreateRequest
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")

-- | ToJSON ConfigCreateRequest
instance A.ToJSON ConfigCreateRequest where
  toJSON ConfigCreateRequest {..} =
   _omitNulls
      [ "Name" .= configCreateRequestName
      , "Labels" .= configCreateRequestLabels
      , "Data" .= configCreateRequestData
      ]


-- | Construct a value of type 'ConfigCreateRequest' (by applying it's required fields, if any)
mkConfigCreateRequest
  :: ConfigCreateRequest
mkConfigCreateRequest =
  ConfigCreateRequest
  { configCreateRequestName = Nothing
  , configCreateRequestLabels = Nothing
  , configCreateRequestData = Nothing
  }

-- ** ConfigSpec
-- | ConfigSpec
data ConfigSpec = ConfigSpec
  { configSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the config.
  , configSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , configSpecData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2)) config data. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigSpec
instance A.FromJSON ConfigSpec where
  parseJSON = A.withObject "ConfigSpec" $ \o ->
    ConfigSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")

-- | ToJSON ConfigSpec
instance A.ToJSON ConfigSpec where
  toJSON ConfigSpec {..} =
   _omitNulls
      [ "Name" .= configSpecName
      , "Labels" .= configSpecLabels
      , "Data" .= configSpecData
      ]


-- | Construct a value of type 'ConfigSpec' (by applying it's required fields, if any)
mkConfigSpec
  :: ConfigSpec
mkConfigSpec =
  ConfigSpec
  { configSpecName = Nothing
  , configSpecLabels = Nothing
  , configSpecData = Nothing
  }

-- ** ContainerChangeResponseItem
-- | ContainerChangeResponseItem
-- ContainerChangeResponseItem
-- 
-- change item in response to ContainerChanges operation
data ContainerChangeResponseItem = ContainerChangeResponseItem
  { containerChangeResponseItemPath :: !(Text) -- ^ /Required/ "Path" - Path to file that has changed
  , containerChangeResponseItemKind :: !(Int) -- ^ /Required/ "Kind" - Kind of change
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerChangeResponseItem
instance A.FromJSON ContainerChangeResponseItem where
  parseJSON = A.withObject "ContainerChangeResponseItem" $ \o ->
    ContainerChangeResponseItem
      <$> (o .:  "Path")
      <*> (o .:  "Kind")

-- | ToJSON ContainerChangeResponseItem
instance A.ToJSON ContainerChangeResponseItem where
  toJSON ContainerChangeResponseItem {..} =
   _omitNulls
      [ "Path" .= containerChangeResponseItemPath
      , "Kind" .= containerChangeResponseItemKind
      ]


-- | Construct a value of type 'ContainerChangeResponseItem' (by applying it's required fields, if any)
mkContainerChangeResponseItem
  :: Text -- ^ 'containerChangeResponseItemPath': Path to file that has changed
  -> Int -- ^ 'containerChangeResponseItemKind': Kind of change
  -> ContainerChangeResponseItem
mkContainerChangeResponseItem containerChangeResponseItemPath containerChangeResponseItemKind =
  ContainerChangeResponseItem
  { containerChangeResponseItemPath
  , containerChangeResponseItemKind
  }

-- ** ContainerConfig
-- | ContainerConfig
-- Configuration for a container that is portable between hosts.  When used as `ContainerConfig` field in an image, `ContainerConfig` is an optional field containing the configuration of the container that was last committed when creating the image.  Previous versions of Docker builder used this field to store build cache, and it is not in active use anymore. 
data ContainerConfig = ContainerConfig
  { containerConfigHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , containerConfigDomainname :: !(Maybe Text) -- ^ "Domainname" - The domain name to use for the container.
  , containerConfigUser :: !(Maybe Text) -- ^ "User" - The user that commands are run as inside the container.
  , containerConfigAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Whether to attach to &#x60;stdin&#x60;.
  , containerConfigAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Whether to attach to &#x60;stdout&#x60;.
  , containerConfigAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Whether to attach to &#x60;stderr&#x60;.
  , containerConfigExposedPorts :: !(Maybe (Map.Map String A.Value)) -- ^ "ExposedPorts" - An object mapping ports to an empty object in the form:  &#x60;{\&quot;&lt;port&gt;/&lt;tcp|udp&gt;\&quot;: {}}&#x60; 
  , containerConfigTty :: !(Maybe Bool) -- ^ "Tty" - Attach standard streams to a TTY, including &#x60;stdin&#x60; if it is not closed.
  , containerConfigOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , containerConfigStdinOnce :: !(Maybe Bool) -- ^ "StdinOnce" - Close &#x60;stdin&#x60; after one attached client disconnects
  , containerConfigEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables to set inside the container in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;. A variable without &#x60;&#x3D;&#x60; is removed from the environment, rather than to have an empty value. 
  , containerConfigCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run specified as a string or an array of strings.
  , containerConfigHealthcheck :: !(Maybe HealthConfig) -- ^ "Healthcheck"
  , containerConfigArgsEscaped :: !(Maybe Bool) -- ^ "ArgsEscaped" - Command is already escaped (Windows only)
  , containerConfigImage :: !(Maybe Text) -- ^ "Image" - The name of the image to use when creating the container
  , containerConfigVolumes :: !(Maybe ContainerConfigVolumes) -- ^ "Volumes"
  , containerConfigWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for commands to run in.
  , containerConfigEntrypoint :: !(Maybe [Text]) -- ^ "Entrypoint" - The entry point for the container as a string or an array of strings.  If the array consists of exactly one empty string (&#x60;[\&quot;\&quot;]&#x60;) then the entry point is reset to system default (i.e., the entry point used by docker when there is no &#x60;ENTRYPOINT&#x60; instruction in the &#x60;Dockerfile&#x60;). 
  , containerConfigNetworkDisabled :: !(Maybe Bool) -- ^ "NetworkDisabled" - Disable networking for the container.
  , containerConfigMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address of the container.
  , containerConfigOnBuild :: !(Maybe [Text]) -- ^ "OnBuild" - &#x60;ONBUILD&#x60; metadata that were defined in the image&#39;s &#x60;Dockerfile&#x60;.
  , containerConfigLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerConfigStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop a container as a string or unsigned integer.
  , containerConfigStopTimeout :: !(Maybe Int) -- ^ "StopTimeout" - Timeout to stop a container in seconds.
  , containerConfigShell :: !(Maybe [Text]) -- ^ "Shell" - Shell for when &#x60;RUN&#x60;, &#x60;CMD&#x60;, and &#x60;ENTRYPOINT&#x60; uses a shell.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerConfig
instance A.FromJSON ContainerConfig where
  parseJSON = A.withObject "ContainerConfig" $ \o ->
    ContainerConfig
      <$> (o .:? "Hostname")
      <*> (o .:? "Domainname")
      <*> (o .:? "User")
      <*> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "ExposedPorts")
      <*> (o .:? "Tty")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "StdinOnce")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Healthcheck")
      <*> (o .:? "ArgsEscaped")
      <*> (o .:? "Image")
      <*> (o .:? "Volumes")
      <*> (o .:? "WorkingDir")
      <*> (o .:? "Entrypoint")
      <*> (o .:? "NetworkDisabled")
      <*> (o .:? "MacAddress")
      <*> (o .:? "OnBuild")
      <*> (o .:? "Labels")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopTimeout")
      <*> (o .:? "Shell")

-- | ToJSON ContainerConfig
instance A.ToJSON ContainerConfig where
  toJSON ContainerConfig {..} =
   _omitNulls
      [ "Hostname" .= containerConfigHostname
      , "Domainname" .= containerConfigDomainname
      , "User" .= containerConfigUser
      , "AttachStdin" .= containerConfigAttachStdin
      , "AttachStdout" .= containerConfigAttachStdout
      , "AttachStderr" .= containerConfigAttachStderr
      , "ExposedPorts" .= containerConfigExposedPorts
      , "Tty" .= containerConfigTty
      , "OpenStdin" .= containerConfigOpenStdin
      , "StdinOnce" .= containerConfigStdinOnce
      , "Env" .= containerConfigEnv
      , "Cmd" .= containerConfigCmd
      , "Healthcheck" .= containerConfigHealthcheck
      , "ArgsEscaped" .= containerConfigArgsEscaped
      , "Image" .= containerConfigImage
      , "Volumes" .= containerConfigVolumes
      , "WorkingDir" .= containerConfigWorkingDir
      , "Entrypoint" .= containerConfigEntrypoint
      , "NetworkDisabled" .= containerConfigNetworkDisabled
      , "MacAddress" .= containerConfigMacAddress
      , "OnBuild" .= containerConfigOnBuild
      , "Labels" .= containerConfigLabels
      , "StopSignal" .= containerConfigStopSignal
      , "StopTimeout" .= containerConfigStopTimeout
      , "Shell" .= containerConfigShell
      ]


-- | Construct a value of type 'ContainerConfig' (by applying it's required fields, if any)
mkContainerConfig
  :: ContainerConfig
mkContainerConfig =
  ContainerConfig
  { containerConfigHostname = Nothing
  , containerConfigDomainname = Nothing
  , containerConfigUser = Nothing
  , containerConfigAttachStdin = Nothing
  , containerConfigAttachStdout = Nothing
  , containerConfigAttachStderr = Nothing
  , containerConfigExposedPorts = Nothing
  , containerConfigTty = Nothing
  , containerConfigOpenStdin = Nothing
  , containerConfigStdinOnce = Nothing
  , containerConfigEnv = Nothing
  , containerConfigCmd = Nothing
  , containerConfigHealthcheck = Nothing
  , containerConfigArgsEscaped = Nothing
  , containerConfigImage = Nothing
  , containerConfigVolumes = Nothing
  , containerConfigWorkingDir = Nothing
  , containerConfigEntrypoint = Nothing
  , containerConfigNetworkDisabled = Nothing
  , containerConfigMacAddress = Nothing
  , containerConfigOnBuild = Nothing
  , containerConfigLabels = Nothing
  , containerConfigStopSignal = Nothing
  , containerConfigStopTimeout = Nothing
  , containerConfigShell = Nothing
  }

-- ** ContainerConfigVolumes
-- | ContainerConfigVolumes
-- An object mapping mount point paths inside the container to empty objects.
data ContainerConfigVolumes = ContainerConfigVolumes
  { containerConfigVolumesAdditionalProperties :: !(Maybe A.Value) -- ^ "additionalProperties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerConfigVolumes
instance A.FromJSON ContainerConfigVolumes where
  parseJSON = A.withObject "ContainerConfigVolumes" $ \o ->
    ContainerConfigVolumes
      <$> (o .:? "additionalProperties")

-- | ToJSON ContainerConfigVolumes
instance A.ToJSON ContainerConfigVolumes where
  toJSON ContainerConfigVolumes {..} =
   _omitNulls
      [ "additionalProperties" .= containerConfigVolumesAdditionalProperties
      ]


-- | Construct a value of type 'ContainerConfigVolumes' (by applying it's required fields, if any)
mkContainerConfigVolumes
  :: ContainerConfigVolumes
mkContainerConfigVolumes =
  ContainerConfigVolumes
  { containerConfigVolumesAdditionalProperties = Nothing
  }

-- ** ContainerCreateRequest
-- | ContainerCreateRequest
data ContainerCreateRequest = ContainerCreateRequest
  { containerCreateRequestHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , containerCreateRequestDomainname :: !(Maybe Text) -- ^ "Domainname" - The domain name to use for the container.
  , containerCreateRequestUser :: !(Maybe Text) -- ^ "User" - The user that commands are run as inside the container.
  , containerCreateRequestAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Whether to attach to &#x60;stdin&#x60;.
  , containerCreateRequestAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Whether to attach to &#x60;stdout&#x60;.
  , containerCreateRequestAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Whether to attach to &#x60;stderr&#x60;.
  , containerCreateRequestExposedPorts :: !(Maybe (Map.Map String A.Value)) -- ^ "ExposedPorts" - An object mapping ports to an empty object in the form:  &#x60;{\&quot;&lt;port&gt;/&lt;tcp|udp&gt;\&quot;: {}}&#x60; 
  , containerCreateRequestTty :: !(Maybe Bool) -- ^ "Tty" - Attach standard streams to a TTY, including &#x60;stdin&#x60; if it is not closed.
  , containerCreateRequestOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , containerCreateRequestStdinOnce :: !(Maybe Bool) -- ^ "StdinOnce" - Close &#x60;stdin&#x60; after one attached client disconnects
  , containerCreateRequestEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables to set inside the container in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;. A variable without &#x60;&#x3D;&#x60; is removed from the environment, rather than to have an empty value. 
  , containerCreateRequestCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run specified as a string or an array of strings.
  , containerCreateRequestHealthcheck :: !(Maybe HealthConfig) -- ^ "Healthcheck"
  , containerCreateRequestArgsEscaped :: !(Maybe Bool) -- ^ "ArgsEscaped" - Command is already escaped (Windows only)
  , containerCreateRequestImage :: !(Maybe Text) -- ^ "Image" - The name of the image to use when creating the container
  , containerCreateRequestVolumes :: !(Maybe ContainerConfigVolumes) -- ^ "Volumes"
  , containerCreateRequestWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for commands to run in.
  , containerCreateRequestEntrypoint :: !(Maybe [Text]) -- ^ "Entrypoint" - The entry point for the container as a string or an array of strings.  If the array consists of exactly one empty string (&#x60;[\&quot;\&quot;]&#x60;) then the entry point is reset to system default (i.e., the entry point used by docker when there is no &#x60;ENTRYPOINT&#x60; instruction in the &#x60;Dockerfile&#x60;). 
  , containerCreateRequestNetworkDisabled :: !(Maybe Bool) -- ^ "NetworkDisabled" - Disable networking for the container.
  , containerCreateRequestMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address of the container.
  , containerCreateRequestOnBuild :: !(Maybe [Text]) -- ^ "OnBuild" - &#x60;ONBUILD&#x60; metadata that were defined in the image&#39;s &#x60;Dockerfile&#x60;.
  , containerCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerCreateRequestStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop a container as a string or unsigned integer.
  , containerCreateRequestStopTimeout :: !(Maybe Int) -- ^ "StopTimeout" - Timeout to stop a container in seconds.
  , containerCreateRequestShell :: !(Maybe [Text]) -- ^ "Shell" - Shell for when &#x60;RUN&#x60;, &#x60;CMD&#x60;, and &#x60;ENTRYPOINT&#x60; uses a shell.
  , containerCreateRequestHostConfig :: !(Maybe HostConfig) -- ^ "HostConfig"
  , containerCreateRequestNetworkingConfig :: !(Maybe ContainerCreateRequestAllOfNetworkingConfig) -- ^ "NetworkingConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerCreateRequest
instance A.FromJSON ContainerCreateRequest where
  parseJSON = A.withObject "ContainerCreateRequest" $ \o ->
    ContainerCreateRequest
      <$> (o .:? "Hostname")
      <*> (o .:? "Domainname")
      <*> (o .:? "User")
      <*> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "ExposedPorts")
      <*> (o .:? "Tty")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "StdinOnce")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Healthcheck")
      <*> (o .:? "ArgsEscaped")
      <*> (o .:? "Image")
      <*> (o .:? "Volumes")
      <*> (o .:? "WorkingDir")
      <*> (o .:? "Entrypoint")
      <*> (o .:? "NetworkDisabled")
      <*> (o .:? "MacAddress")
      <*> (o .:? "OnBuild")
      <*> (o .:? "Labels")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopTimeout")
      <*> (o .:? "Shell")
      <*> (o .:? "HostConfig")
      <*> (o .:? "NetworkingConfig")

-- | ToJSON ContainerCreateRequest
instance A.ToJSON ContainerCreateRequest where
  toJSON ContainerCreateRequest {..} =
   _omitNulls
      [ "Hostname" .= containerCreateRequestHostname
      , "Domainname" .= containerCreateRequestDomainname
      , "User" .= containerCreateRequestUser
      , "AttachStdin" .= containerCreateRequestAttachStdin
      , "AttachStdout" .= containerCreateRequestAttachStdout
      , "AttachStderr" .= containerCreateRequestAttachStderr
      , "ExposedPorts" .= containerCreateRequestExposedPorts
      , "Tty" .= containerCreateRequestTty
      , "OpenStdin" .= containerCreateRequestOpenStdin
      , "StdinOnce" .= containerCreateRequestStdinOnce
      , "Env" .= containerCreateRequestEnv
      , "Cmd" .= containerCreateRequestCmd
      , "Healthcheck" .= containerCreateRequestHealthcheck
      , "ArgsEscaped" .= containerCreateRequestArgsEscaped
      , "Image" .= containerCreateRequestImage
      , "Volumes" .= containerCreateRequestVolumes
      , "WorkingDir" .= containerCreateRequestWorkingDir
      , "Entrypoint" .= containerCreateRequestEntrypoint
      , "NetworkDisabled" .= containerCreateRequestNetworkDisabled
      , "MacAddress" .= containerCreateRequestMacAddress
      , "OnBuild" .= containerCreateRequestOnBuild
      , "Labels" .= containerCreateRequestLabels
      , "StopSignal" .= containerCreateRequestStopSignal
      , "StopTimeout" .= containerCreateRequestStopTimeout
      , "Shell" .= containerCreateRequestShell
      , "HostConfig" .= containerCreateRequestHostConfig
      , "NetworkingConfig" .= containerCreateRequestNetworkingConfig
      ]


-- | Construct a value of type 'ContainerCreateRequest' (by applying it's required fields, if any)
mkContainerCreateRequest
  :: ContainerCreateRequest
mkContainerCreateRequest =
  ContainerCreateRequest
  { containerCreateRequestHostname = Nothing
  , containerCreateRequestDomainname = Nothing
  , containerCreateRequestUser = Nothing
  , containerCreateRequestAttachStdin = Nothing
  , containerCreateRequestAttachStdout = Nothing
  , containerCreateRequestAttachStderr = Nothing
  , containerCreateRequestExposedPorts = Nothing
  , containerCreateRequestTty = Nothing
  , containerCreateRequestOpenStdin = Nothing
  , containerCreateRequestStdinOnce = Nothing
  , containerCreateRequestEnv = Nothing
  , containerCreateRequestCmd = Nothing
  , containerCreateRequestHealthcheck = Nothing
  , containerCreateRequestArgsEscaped = Nothing
  , containerCreateRequestImage = Nothing
  , containerCreateRequestVolumes = Nothing
  , containerCreateRequestWorkingDir = Nothing
  , containerCreateRequestEntrypoint = Nothing
  , containerCreateRequestNetworkDisabled = Nothing
  , containerCreateRequestMacAddress = Nothing
  , containerCreateRequestOnBuild = Nothing
  , containerCreateRequestLabels = Nothing
  , containerCreateRequestStopSignal = Nothing
  , containerCreateRequestStopTimeout = Nothing
  , containerCreateRequestShell = Nothing
  , containerCreateRequestHostConfig = Nothing
  , containerCreateRequestNetworkingConfig = Nothing
  }

-- ** ContainerCreateRequestAllOfNetworkingConfig
-- | ContainerCreateRequestAllOfNetworkingConfig
-- This container's networking configuration.
data ContainerCreateRequestAllOfNetworkingConfig = ContainerCreateRequestAllOfNetworkingConfig
  { containerCreateRequestAllOfNetworkingConfigEndpointsConfig :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "EndpointsConfig" - A mapping of network name to endpoint configuration for that network.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerCreateRequestAllOfNetworkingConfig
instance A.FromJSON ContainerCreateRequestAllOfNetworkingConfig where
  parseJSON = A.withObject "ContainerCreateRequestAllOfNetworkingConfig" $ \o ->
    ContainerCreateRequestAllOfNetworkingConfig
      <$> (o .:? "EndpointsConfig")

-- | ToJSON ContainerCreateRequestAllOfNetworkingConfig
instance A.ToJSON ContainerCreateRequestAllOfNetworkingConfig where
  toJSON ContainerCreateRequestAllOfNetworkingConfig {..} =
   _omitNulls
      [ "EndpointsConfig" .= containerCreateRequestAllOfNetworkingConfigEndpointsConfig
      ]


-- | Construct a value of type 'ContainerCreateRequestAllOfNetworkingConfig' (by applying it's required fields, if any)
mkContainerCreateRequestAllOfNetworkingConfig
  :: ContainerCreateRequestAllOfNetworkingConfig
mkContainerCreateRequestAllOfNetworkingConfig =
  ContainerCreateRequestAllOfNetworkingConfig
  { containerCreateRequestAllOfNetworkingConfigEndpointsConfig = Nothing
  }

-- ** ContainerCreateResponse
-- | ContainerCreateResponse
-- ContainerCreateResponse
-- 
-- OK response to ContainerCreate operation
data ContainerCreateResponse = ContainerCreateResponse
  { containerCreateResponseId :: !(Text) -- ^ /Required/ "Id" - The ID of the created container
  , containerCreateResponseWarnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings encountered when creating the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerCreateResponse
instance A.FromJSON ContainerCreateResponse where
  parseJSON = A.withObject "ContainerCreateResponse" $ \o ->
    ContainerCreateResponse
      <$> (o .:  "Id")
      <*> (o .:  "Warnings")

-- | ToJSON ContainerCreateResponse
instance A.ToJSON ContainerCreateResponse where
  toJSON ContainerCreateResponse {..} =
   _omitNulls
      [ "Id" .= containerCreateResponseId
      , "Warnings" .= containerCreateResponseWarnings
      ]


-- | Construct a value of type 'ContainerCreateResponse' (by applying it's required fields, if any)
mkContainerCreateResponse
  :: Text -- ^ 'containerCreateResponseId': The ID of the created container
  -> [Text] -- ^ 'containerCreateResponseWarnings': Warnings encountered when creating the container
  -> ContainerCreateResponse
mkContainerCreateResponse containerCreateResponseId containerCreateResponseWarnings =
  ContainerCreateResponse
  { containerCreateResponseId
  , containerCreateResponseWarnings
  }

-- ** ContainerExecRequest
-- | ContainerExecRequest
data ContainerExecRequest = ContainerExecRequest
  { containerExecRequestAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Attach to &#x60;stdin&#x60; of the exec command.
  , containerExecRequestAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Attach to &#x60;stdout&#x60; of the exec command.
  , containerExecRequestAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Attach to &#x60;stderr&#x60; of the exec command.
  , containerExecRequestDetachKeys :: !(Maybe Text) -- ^ "DetachKeys" - Override the key sequence for detaching a container. Format is a single character &#x60;[a-Z]&#x60; or &#x60;ctrl-&lt;value&gt;&#x60; where &#x60;&lt;value&gt;&#x60; is one of: &#x60;a-z&#x60;, &#x60;@&#x60;, &#x60;^&#x60;, &#x60;[&#x60;, &#x60;,&#x60; or &#x60;_&#x60;.
  , containerExecRequestTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  , containerExecRequestEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;.
  , containerExecRequestCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run, as a string or array of strings.
  , containerExecRequestPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Runs the exec process with extended privileges.
  , containerExecRequestUser :: !(Maybe Text) -- ^ "User" - The user, and optionally, group to run the exec process inside the container. Format is one of: &#x60;user&#x60;, &#x60;user:group&#x60;, &#x60;uid&#x60;, or &#x60;uid:gid&#x60;.
  , containerExecRequestWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for the exec process inside the container.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerExecRequest
instance A.FromJSON ContainerExecRequest where
  parseJSON = A.withObject "ContainerExecRequest" $ \o ->
    ContainerExecRequest
      <$> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "DetachKeys")
      <*> (o .:? "Tty")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Privileged")
      <*> (o .:? "User")
      <*> (o .:? "WorkingDir")

-- | ToJSON ContainerExecRequest
instance A.ToJSON ContainerExecRequest where
  toJSON ContainerExecRequest {..} =
   _omitNulls
      [ "AttachStdin" .= containerExecRequestAttachStdin
      , "AttachStdout" .= containerExecRequestAttachStdout
      , "AttachStderr" .= containerExecRequestAttachStderr
      , "DetachKeys" .= containerExecRequestDetachKeys
      , "Tty" .= containerExecRequestTty
      , "Env" .= containerExecRequestEnv
      , "Cmd" .= containerExecRequestCmd
      , "Privileged" .= containerExecRequestPrivileged
      , "User" .= containerExecRequestUser
      , "WorkingDir" .= containerExecRequestWorkingDir
      ]


-- | Construct a value of type 'ContainerExecRequest' (by applying it's required fields, if any)
mkContainerExecRequest
  :: ContainerExecRequest
mkContainerExecRequest =
  ContainerExecRequest
  { containerExecRequestAttachStdin = Nothing
  , containerExecRequestAttachStdout = Nothing
  , containerExecRequestAttachStderr = Nothing
  , containerExecRequestDetachKeys = Nothing
  , containerExecRequestTty = Nothing
  , containerExecRequestEnv = Nothing
  , containerExecRequestCmd = Nothing
  , containerExecRequestPrivileged = Nothing
  , containerExecRequestUser = Nothing
  , containerExecRequestWorkingDir = Nothing
  }

-- ** ContainerInspectResponse
-- | ContainerInspectResponse
-- ContainerInspectResponse
-- 
data ContainerInspectResponse = ContainerInspectResponse
  { containerInspectResponseId :: !(Maybe Text) -- ^ "Id" - The ID of the container
  , containerInspectResponseCreated :: !(Maybe Text) -- ^ "Created" - The time the container was created
  , containerInspectResponsePath :: !(Maybe Text) -- ^ "Path" - The path to the command being run
  , containerInspectResponseArgs :: !(Maybe [Text]) -- ^ "Args" - The arguments to the command being run
  , containerInspectResponseState :: !(Maybe ContainerInspectResponseState) -- ^ "State"
  , containerInspectResponseImage :: !(Maybe Text) -- ^ "Image" - The container&#39;s image
  , containerInspectResponseResolvConfPath :: !(Maybe Text) -- ^ "ResolvConfPath"
  , containerInspectResponseHostnamePath :: !(Maybe Text) -- ^ "HostnamePath"
  , containerInspectResponseHostsPath :: !(Maybe Text) -- ^ "HostsPath"
  , containerInspectResponseLogPath :: !(Maybe Text) -- ^ "LogPath"
  , containerInspectResponseNode :: !(Maybe A.Value) -- ^ "Node" - TODO
  , containerInspectResponseName :: !(Maybe Text) -- ^ "Name"
  , containerInspectResponseRestartCount :: !(Maybe Int) -- ^ "RestartCount"
  , containerInspectResponseDriver :: !(Maybe Text) -- ^ "Driver"
  , containerInspectResponseMountLabel :: !(Maybe Text) -- ^ "MountLabel"
  , containerInspectResponseProcessLabel :: !(Maybe Text) -- ^ "ProcessLabel"
  , containerInspectResponseAppArmorProfile :: !(Maybe Text) -- ^ "AppArmorProfile"
  , containerInspectResponseExecIds :: !(Maybe Text) -- ^ "ExecIDs"
  , containerInspectResponseHostConfig :: !(Maybe HostConfig) -- ^ "HostConfig"
  , containerInspectResponseGraphDriver :: !(Maybe GraphDriverData) -- ^ "GraphDriver"
  , containerInspectResponseSizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container.
  , containerInspectResponseSizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container.
  , containerInspectResponseMounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  , containerInspectResponseConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , containerInspectResponseNetworkSettings :: !(Maybe NetworkSettings) -- ^ "NetworkSettings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerInspectResponse
instance A.FromJSON ContainerInspectResponse where
  parseJSON = A.withObject "ContainerInspectResponse" $ \o ->
    ContainerInspectResponse
      <$> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Path")
      <*> (o .:? "Args")
      <*> (o .:? "State")
      <*> (o .:? "Image")
      <*> (o .:? "ResolvConfPath")
      <*> (o .:? "HostnamePath")
      <*> (o .:? "HostsPath")
      <*> (o .:? "LogPath")
      <*> (o .:? "Node")
      <*> (o .:? "Name")
      <*> (o .:? "RestartCount")
      <*> (o .:? "Driver")
      <*> (o .:? "MountLabel")
      <*> (o .:? "ProcessLabel")
      <*> (o .:? "AppArmorProfile")
      <*> (o .:? "ExecIDs")
      <*> (o .:? "HostConfig")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Mounts")
      <*> (o .:? "Config")
      <*> (o .:? "NetworkSettings")

-- | ToJSON ContainerInspectResponse
instance A.ToJSON ContainerInspectResponse where
  toJSON ContainerInspectResponse {..} =
   _omitNulls
      [ "Id" .= containerInspectResponseId
      , "Created" .= containerInspectResponseCreated
      , "Path" .= containerInspectResponsePath
      , "Args" .= containerInspectResponseArgs
      , "State" .= containerInspectResponseState
      , "Image" .= containerInspectResponseImage
      , "ResolvConfPath" .= containerInspectResponseResolvConfPath
      , "HostnamePath" .= containerInspectResponseHostnamePath
      , "HostsPath" .= containerInspectResponseHostsPath
      , "LogPath" .= containerInspectResponseLogPath
      , "Node" .= containerInspectResponseNode
      , "Name" .= containerInspectResponseName
      , "RestartCount" .= containerInspectResponseRestartCount
      , "Driver" .= containerInspectResponseDriver
      , "MountLabel" .= containerInspectResponseMountLabel
      , "ProcessLabel" .= containerInspectResponseProcessLabel
      , "AppArmorProfile" .= containerInspectResponseAppArmorProfile
      , "ExecIDs" .= containerInspectResponseExecIds
      , "HostConfig" .= containerInspectResponseHostConfig
      , "GraphDriver" .= containerInspectResponseGraphDriver
      , "SizeRw" .= containerInspectResponseSizeRw
      , "SizeRootFs" .= containerInspectResponseSizeRootFs
      , "Mounts" .= containerInspectResponseMounts
      , "Config" .= containerInspectResponseConfig
      , "NetworkSettings" .= containerInspectResponseNetworkSettings
      ]


-- | Construct a value of type 'ContainerInspectResponse' (by applying it's required fields, if any)
mkContainerInspectResponse
  :: ContainerInspectResponse
mkContainerInspectResponse =
  ContainerInspectResponse
  { containerInspectResponseId = Nothing
  , containerInspectResponseCreated = Nothing
  , containerInspectResponsePath = Nothing
  , containerInspectResponseArgs = Nothing
  , containerInspectResponseState = Nothing
  , containerInspectResponseImage = Nothing
  , containerInspectResponseResolvConfPath = Nothing
  , containerInspectResponseHostnamePath = Nothing
  , containerInspectResponseHostsPath = Nothing
  , containerInspectResponseLogPath = Nothing
  , containerInspectResponseNode = Nothing
  , containerInspectResponseName = Nothing
  , containerInspectResponseRestartCount = Nothing
  , containerInspectResponseDriver = Nothing
  , containerInspectResponseMountLabel = Nothing
  , containerInspectResponseProcessLabel = Nothing
  , containerInspectResponseAppArmorProfile = Nothing
  , containerInspectResponseExecIds = Nothing
  , containerInspectResponseHostConfig = Nothing
  , containerInspectResponseGraphDriver = Nothing
  , containerInspectResponseSizeRw = Nothing
  , containerInspectResponseSizeRootFs = Nothing
  , containerInspectResponseMounts = Nothing
  , containerInspectResponseConfig = Nothing
  , containerInspectResponseNetworkSettings = Nothing
  }

-- ** ContainerInspectResponseState
-- | ContainerInspectResponseState
-- The state of the container.
data ContainerInspectResponseState = ContainerInspectResponseState
  { containerInspectResponseStateStatus :: !(Maybe E'Status) -- ^ "Status" - The status of the container. For example, &#x60;\&quot;running\&quot;&#x60; or &#x60;\&quot;exited\&quot;&#x60;. 
  , containerInspectResponseStateRunning :: !(Maybe Bool) -- ^ "Running" - Whether this container is running.  Note that a running container can be _paused_. The &#x60;Running&#x60; and &#x60;Paused&#x60; booleans are not mutually exclusive:  When pausing a container (on Linux), the cgroups freezer is used to suspend all processes in the container. Freezing the process requires the process to be running. As a result, paused containers are both &#x60;Running&#x60; _and_ &#x60;Paused&#x60;.  Use the &#x60;Status&#x60; field instead to determine if a container&#39;s state is \&quot;running\&quot;. 
  , containerInspectResponseStatePaused :: !(Maybe Bool) -- ^ "Paused" - Whether this container is paused.
  , containerInspectResponseStateRestarting :: !(Maybe Bool) -- ^ "Restarting" - Whether this container is restarting.
  , containerInspectResponseStateOomKilled :: !(Maybe Bool) -- ^ "OOMKilled" - Whether this container has been killed because it ran out of memory.
  , containerInspectResponseStateDead :: !(Maybe Bool) -- ^ "Dead"
  , containerInspectResponseStatePid :: !(Maybe Int) -- ^ "Pid" - The process ID of this container
  , containerInspectResponseStateExitCode :: !(Maybe Int) -- ^ "ExitCode" - The last exit code of this container
  , containerInspectResponseStateError :: !(Maybe Text) -- ^ "Error"
  , containerInspectResponseStateStartedAt :: !(Maybe Text) -- ^ "StartedAt" - The time when this container was last started.
  , containerInspectResponseStateFinishedAt :: !(Maybe Text) -- ^ "FinishedAt" - The time when this container last exited.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerInspectResponseState
instance A.FromJSON ContainerInspectResponseState where
  parseJSON = A.withObject "ContainerInspectResponseState" $ \o ->
    ContainerInspectResponseState
      <$> (o .:? "Status")
      <*> (o .:? "Running")
      <*> (o .:? "Paused")
      <*> (o .:? "Restarting")
      <*> (o .:? "OOMKilled")
      <*> (o .:? "Dead")
      <*> (o .:? "Pid")
      <*> (o .:? "ExitCode")
      <*> (o .:? "Error")
      <*> (o .:? "StartedAt")
      <*> (o .:? "FinishedAt")

-- | ToJSON ContainerInspectResponseState
instance A.ToJSON ContainerInspectResponseState where
  toJSON ContainerInspectResponseState {..} =
   _omitNulls
      [ "Status" .= containerInspectResponseStateStatus
      , "Running" .= containerInspectResponseStateRunning
      , "Paused" .= containerInspectResponseStatePaused
      , "Restarting" .= containerInspectResponseStateRestarting
      , "OOMKilled" .= containerInspectResponseStateOomKilled
      , "Dead" .= containerInspectResponseStateDead
      , "Pid" .= containerInspectResponseStatePid
      , "ExitCode" .= containerInspectResponseStateExitCode
      , "Error" .= containerInspectResponseStateError
      , "StartedAt" .= containerInspectResponseStateStartedAt
      , "FinishedAt" .= containerInspectResponseStateFinishedAt
      ]


-- | Construct a value of type 'ContainerInspectResponseState' (by applying it's required fields, if any)
mkContainerInspectResponseState
  :: ContainerInspectResponseState
mkContainerInspectResponseState =
  ContainerInspectResponseState
  { containerInspectResponseStateStatus = Nothing
  , containerInspectResponseStateRunning = Nothing
  , containerInspectResponseStatePaused = Nothing
  , containerInspectResponseStateRestarting = Nothing
  , containerInspectResponseStateOomKilled = Nothing
  , containerInspectResponseStateDead = Nothing
  , containerInspectResponseStatePid = Nothing
  , containerInspectResponseStateExitCode = Nothing
  , containerInspectResponseStateError = Nothing
  , containerInspectResponseStateStartedAt = Nothing
  , containerInspectResponseStateFinishedAt = Nothing
  }

-- ** ContainerPruneResponse
-- | ContainerPruneResponse
-- ContainerPruneResponse
-- 
data ContainerPruneResponse = ContainerPruneResponse
  { containerPruneResponseContainersDeleted :: !(Maybe [Text]) -- ^ "ContainersDeleted" - Container IDs that were deleted
  , containerPruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerPruneResponse
instance A.FromJSON ContainerPruneResponse where
  parseJSON = A.withObject "ContainerPruneResponse" $ \o ->
    ContainerPruneResponse
      <$> (o .:? "ContainersDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON ContainerPruneResponse
instance A.ToJSON ContainerPruneResponse where
  toJSON ContainerPruneResponse {..} =
   _omitNulls
      [ "ContainersDeleted" .= containerPruneResponseContainersDeleted
      , "SpaceReclaimed" .= containerPruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'ContainerPruneResponse' (by applying it's required fields, if any)
mkContainerPruneResponse
  :: ContainerPruneResponse
mkContainerPruneResponse =
  ContainerPruneResponse
  { containerPruneResponseContainersDeleted = Nothing
  , containerPruneResponseSpaceReclaimed = Nothing
  }

-- ** ContainerSummary
-- | ContainerSummary
data ContainerSummary = ContainerSummary
  { containerSummaryId :: !(Maybe Text) -- ^ "Id" - The ID of this container
  , containerSummaryNames :: !(Maybe [Text]) -- ^ "Names" - The names that this container has been given
  , containerSummaryImage :: !(Maybe Text) -- ^ "Image" - The name of the image used when creating this container
  , containerSummaryImageId :: !(Maybe Text) -- ^ "ImageID" - The ID of the image that this container was created from
  , containerSummaryCommand :: !(Maybe Text) -- ^ "Command" - Command to run when starting the container
  , containerSummaryCreated :: !(Maybe Integer) -- ^ "Created" - When the container was created
  , containerSummaryPorts :: !(Maybe [Port]) -- ^ "Ports" - The ports exposed by this container
  , containerSummarySizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container
  , containerSummarySizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container
  , containerSummaryLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerSummaryState :: !(Maybe Text) -- ^ "State" - The state of this container (e.g. &#x60;Exited&#x60;)
  , containerSummaryStatus :: !(Maybe Text) -- ^ "Status" - Additional human-readable status of this container (e.g. &#x60;Exit 0&#x60;)
  , containerSummaryHostConfig :: !(Maybe ContainerSummaryHostConfig) -- ^ "HostConfig"
  , containerSummaryNetworkSettings :: !(Maybe ContainerSummaryNetworkSettings) -- ^ "NetworkSettings"
  , containerSummaryMounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummary
instance A.FromJSON ContainerSummary where
  parseJSON = A.withObject "ContainerSummary" $ \o ->
    ContainerSummary
      <$> (o .:? "Id")
      <*> (o .:? "Names")
      <*> (o .:? "Image")
      <*> (o .:? "ImageID")
      <*> (o .:? "Command")
      <*> (o .:? "Created")
      <*> (o .:? "Ports")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Labels")
      <*> (o .:? "State")
      <*> (o .:? "Status")
      <*> (o .:? "HostConfig")
      <*> (o .:? "NetworkSettings")
      <*> (o .:? "Mounts")

-- | ToJSON ContainerSummary
instance A.ToJSON ContainerSummary where
  toJSON ContainerSummary {..} =
   _omitNulls
      [ "Id" .= containerSummaryId
      , "Names" .= containerSummaryNames
      , "Image" .= containerSummaryImage
      , "ImageID" .= containerSummaryImageId
      , "Command" .= containerSummaryCommand
      , "Created" .= containerSummaryCreated
      , "Ports" .= containerSummaryPorts
      , "SizeRw" .= containerSummarySizeRw
      , "SizeRootFs" .= containerSummarySizeRootFs
      , "Labels" .= containerSummaryLabels
      , "State" .= containerSummaryState
      , "Status" .= containerSummaryStatus
      , "HostConfig" .= containerSummaryHostConfig
      , "NetworkSettings" .= containerSummaryNetworkSettings
      , "Mounts" .= containerSummaryMounts
      ]


-- | Construct a value of type 'ContainerSummary' (by applying it's required fields, if any)
mkContainerSummary
  :: ContainerSummary
mkContainerSummary =
  ContainerSummary
  { containerSummaryId = Nothing
  , containerSummaryNames = Nothing
  , containerSummaryImage = Nothing
  , containerSummaryImageId = Nothing
  , containerSummaryCommand = Nothing
  , containerSummaryCreated = Nothing
  , containerSummaryPorts = Nothing
  , containerSummarySizeRw = Nothing
  , containerSummarySizeRootFs = Nothing
  , containerSummaryLabels = Nothing
  , containerSummaryState = Nothing
  , containerSummaryStatus = Nothing
  , containerSummaryHostConfig = Nothing
  , containerSummaryNetworkSettings = Nothing
  , containerSummaryMounts = Nothing
  }

-- ** ContainerSummaryHostConfig
-- | ContainerSummaryHostConfig
data ContainerSummaryHostConfig = ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryHostConfig
instance A.FromJSON ContainerSummaryHostConfig where
  parseJSON = A.withObject "ContainerSummaryHostConfig" $ \o ->
    ContainerSummaryHostConfig
      <$> (o .:? "NetworkMode")

-- | ToJSON ContainerSummaryHostConfig
instance A.ToJSON ContainerSummaryHostConfig where
  toJSON ContainerSummaryHostConfig {..} =
   _omitNulls
      [ "NetworkMode" .= containerSummaryHostConfigNetworkMode
      ]


-- | Construct a value of type 'ContainerSummaryHostConfig' (by applying it's required fields, if any)
mkContainerSummaryHostConfig
  :: ContainerSummaryHostConfig
mkContainerSummaryHostConfig =
  ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode = Nothing
  }

-- ** ContainerSummaryNetworkSettings
-- | ContainerSummaryNetworkSettings
-- A summary of the container's network settings
data ContainerSummaryNetworkSettings = ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryNetworkSettings
instance A.FromJSON ContainerSummaryNetworkSettings where
  parseJSON = A.withObject "ContainerSummaryNetworkSettings" $ \o ->
    ContainerSummaryNetworkSettings
      <$> (o .:? "Networks")

-- | ToJSON ContainerSummaryNetworkSettings
instance A.ToJSON ContainerSummaryNetworkSettings where
  toJSON ContainerSummaryNetworkSettings {..} =
   _omitNulls
      [ "Networks" .= containerSummaryNetworkSettingsNetworks
      ]


-- | Construct a value of type 'ContainerSummaryNetworkSettings' (by applying it's required fields, if any)
mkContainerSummaryNetworkSettings
  :: ContainerSummaryNetworkSettings
mkContainerSummaryNetworkSettings =
  ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks = Nothing
  }

-- ** ContainerTopResponse
-- | ContainerTopResponse
-- ContainerTopResponse
-- 
-- OK response to ContainerTop operation
data ContainerTopResponse = ContainerTopResponse
  { containerTopResponseTitles :: !(Maybe [Text]) -- ^ "Titles" - The ps column titles
  , containerTopResponseProcesses :: !(Maybe [[Text]]) -- ^ "Processes" - Each process running in the container, where each is process is an array of values corresponding to the titles
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerTopResponse
instance A.FromJSON ContainerTopResponse where
  parseJSON = A.withObject "ContainerTopResponse" $ \o ->
    ContainerTopResponse
      <$> (o .:? "Titles")
      <*> (o .:? "Processes")

-- | ToJSON ContainerTopResponse
instance A.ToJSON ContainerTopResponse where
  toJSON ContainerTopResponse {..} =
   _omitNulls
      [ "Titles" .= containerTopResponseTitles
      , "Processes" .= containerTopResponseProcesses
      ]


-- | Construct a value of type 'ContainerTopResponse' (by applying it's required fields, if any)
mkContainerTopResponse
  :: ContainerTopResponse
mkContainerTopResponse =
  ContainerTopResponse
  { containerTopResponseTitles = Nothing
  , containerTopResponseProcesses = Nothing
  }

-- ** ContainerUpdateRequest
-- | ContainerUpdateRequest
data ContainerUpdateRequest = ContainerUpdateRequest
  { containerUpdateRequestCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , containerUpdateRequestMemory :: !(Maybe Integer) -- ^ "Memory" - Memory limit in bytes.
  , containerUpdateRequestCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , containerUpdateRequestBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , containerUpdateRequestBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDeviceInner]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , containerUpdateRequestBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , containerUpdateRequestBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , containerUpdateRequestBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , containerUpdateRequestBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , containerUpdateRequestCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , containerUpdateRequestCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , containerUpdateRequestCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , containerUpdateRequestCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , containerUpdateRequestCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , containerUpdateRequestCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , containerUpdateRequestDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , containerUpdateRequestDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , containerUpdateRequestDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , containerUpdateRequestKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , containerUpdateRequestMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , containerUpdateRequestMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , containerUpdateRequestMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , containerUpdateRequestNanoCpus :: !(Maybe Integer) -- ^ "NanoCpus" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , containerUpdateRequestOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , containerUpdateRequestPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , containerUpdateRequestUlimits :: !(Maybe [ResourcesUlimitsInner]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , containerUpdateRequestCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , containerUpdateRequestCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , containerUpdateRequestIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , containerUpdateRequestIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  , containerUpdateRequestRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerUpdateRequest
instance A.FromJSON ContainerUpdateRequest where
  parseJSON = A.withObject "ContainerUpdateRequest" $ \o ->
    ContainerUpdateRequest
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCpus")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")
      <*> (o .:? "RestartPolicy")

-- | ToJSON ContainerUpdateRequest
instance A.ToJSON ContainerUpdateRequest where
  toJSON ContainerUpdateRequest {..} =
   _omitNulls
      [ "CpuShares" .= containerUpdateRequestCpuShares
      , "Memory" .= containerUpdateRequestMemory
      , "CgroupParent" .= containerUpdateRequestCgroupParent
      , "BlkioWeight" .= containerUpdateRequestBlkioWeight
      , "BlkioWeightDevice" .= containerUpdateRequestBlkioWeightDevice
      , "BlkioDeviceReadBps" .= containerUpdateRequestBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= containerUpdateRequestBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= containerUpdateRequestBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= containerUpdateRequestBlkioDeviceWriteIOps
      , "CpuPeriod" .= containerUpdateRequestCpuPeriod
      , "CpuQuota" .= containerUpdateRequestCpuQuota
      , "CpuRealtimePeriod" .= containerUpdateRequestCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= containerUpdateRequestCpuRealtimeRuntime
      , "CpusetCpus" .= containerUpdateRequestCpusetCpus
      , "CpusetMems" .= containerUpdateRequestCpusetMems
      , "Devices" .= containerUpdateRequestDevices
      , "DeviceCgroupRules" .= containerUpdateRequestDeviceCgroupRules
      , "DiskQuota" .= containerUpdateRequestDiskQuota
      , "KernelMemory" .= containerUpdateRequestKernelMemory
      , "MemoryReservation" .= containerUpdateRequestMemoryReservation
      , "MemorySwap" .= containerUpdateRequestMemorySwap
      , "MemorySwappiness" .= containerUpdateRequestMemorySwappiness
      , "NanoCpus" .= containerUpdateRequestNanoCpus
      , "OomKillDisable" .= containerUpdateRequestOomKillDisable
      , "PidsLimit" .= containerUpdateRequestPidsLimit
      , "Ulimits" .= containerUpdateRequestUlimits
      , "CpuCount" .= containerUpdateRequestCpuCount
      , "CpuPercent" .= containerUpdateRequestCpuPercent
      , "IOMaximumIOps" .= containerUpdateRequestIoMaximumIOps
      , "IOMaximumBandwidth" .= containerUpdateRequestIoMaximumBandwidth
      , "RestartPolicy" .= containerUpdateRequestRestartPolicy
      ]


-- | Construct a value of type 'ContainerUpdateRequest' (by applying it's required fields, if any)
mkContainerUpdateRequest
  :: ContainerUpdateRequest
mkContainerUpdateRequest =
  ContainerUpdateRequest
  { containerUpdateRequestCpuShares = Nothing
  , containerUpdateRequestMemory = Nothing
  , containerUpdateRequestCgroupParent = Nothing
  , containerUpdateRequestBlkioWeight = Nothing
  , containerUpdateRequestBlkioWeightDevice = Nothing
  , containerUpdateRequestBlkioDeviceReadBps = Nothing
  , containerUpdateRequestBlkioDeviceWriteBps = Nothing
  , containerUpdateRequestBlkioDeviceReadIOps = Nothing
  , containerUpdateRequestBlkioDeviceWriteIOps = Nothing
  , containerUpdateRequestCpuPeriod = Nothing
  , containerUpdateRequestCpuQuota = Nothing
  , containerUpdateRequestCpuRealtimePeriod = Nothing
  , containerUpdateRequestCpuRealtimeRuntime = Nothing
  , containerUpdateRequestCpusetCpus = Nothing
  , containerUpdateRequestCpusetMems = Nothing
  , containerUpdateRequestDevices = Nothing
  , containerUpdateRequestDeviceCgroupRules = Nothing
  , containerUpdateRequestDiskQuota = Nothing
  , containerUpdateRequestKernelMemory = Nothing
  , containerUpdateRequestMemoryReservation = Nothing
  , containerUpdateRequestMemorySwap = Nothing
  , containerUpdateRequestMemorySwappiness = Nothing
  , containerUpdateRequestNanoCpus = Nothing
  , containerUpdateRequestOomKillDisable = Nothing
  , containerUpdateRequestPidsLimit = Nothing
  , containerUpdateRequestUlimits = Nothing
  , containerUpdateRequestCpuCount = Nothing
  , containerUpdateRequestCpuPercent = Nothing
  , containerUpdateRequestIoMaximumIOps = Nothing
  , containerUpdateRequestIoMaximumBandwidth = Nothing
  , containerUpdateRequestRestartPolicy = Nothing
  }

-- ** ContainerUpdateResponse
-- | ContainerUpdateResponse
-- ContainerUpdateResponse
-- 
-- OK response to ContainerUpdate operation
data ContainerUpdateResponse = ContainerUpdateResponse
  { containerUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerUpdateResponse
instance A.FromJSON ContainerUpdateResponse where
  parseJSON = A.withObject "ContainerUpdateResponse" $ \o ->
    ContainerUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ContainerUpdateResponse
instance A.ToJSON ContainerUpdateResponse where
  toJSON ContainerUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= containerUpdateResponseWarnings
      ]


-- | Construct a value of type 'ContainerUpdateResponse' (by applying it's required fields, if any)
mkContainerUpdateResponse
  :: ContainerUpdateResponse
mkContainerUpdateResponse =
  ContainerUpdateResponse
  { containerUpdateResponseWarnings = Nothing
  }

-- ** ContainerWaitResponse
-- | ContainerWaitResponse
-- ContainerWaitResponse
-- 
-- OK response to ContainerWait operation
data ContainerWaitResponse = ContainerWaitResponse
  { containerWaitResponseStatusCode :: !(Int) -- ^ /Required/ "StatusCode" - Exit code of the container
  , containerWaitResponseError :: !(Maybe ContainerWaitResponseError) -- ^ "Error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerWaitResponse
instance A.FromJSON ContainerWaitResponse where
  parseJSON = A.withObject "ContainerWaitResponse" $ \o ->
    ContainerWaitResponse
      <$> (o .:  "StatusCode")
      <*> (o .:? "Error")

-- | ToJSON ContainerWaitResponse
instance A.ToJSON ContainerWaitResponse where
  toJSON ContainerWaitResponse {..} =
   _omitNulls
      [ "StatusCode" .= containerWaitResponseStatusCode
      , "Error" .= containerWaitResponseError
      ]


-- | Construct a value of type 'ContainerWaitResponse' (by applying it's required fields, if any)
mkContainerWaitResponse
  :: Int -- ^ 'containerWaitResponseStatusCode': Exit code of the container
  -> ContainerWaitResponse
mkContainerWaitResponse containerWaitResponseStatusCode =
  ContainerWaitResponse
  { containerWaitResponseStatusCode
  , containerWaitResponseError = Nothing
  }

-- ** ContainerWaitResponseError
-- | ContainerWaitResponseError
-- container waiting error, if any
data ContainerWaitResponseError = ContainerWaitResponseError
  { containerWaitResponseErrorMessage :: !(Maybe Text) -- ^ "Message" - Details of an error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerWaitResponseError
instance A.FromJSON ContainerWaitResponseError where
  parseJSON = A.withObject "ContainerWaitResponseError" $ \o ->
    ContainerWaitResponseError
      <$> (o .:? "Message")

-- | ToJSON ContainerWaitResponseError
instance A.ToJSON ContainerWaitResponseError where
  toJSON ContainerWaitResponseError {..} =
   _omitNulls
      [ "Message" .= containerWaitResponseErrorMessage
      ]


-- | Construct a value of type 'ContainerWaitResponseError' (by applying it's required fields, if any)
mkContainerWaitResponseError
  :: ContainerWaitResponseError
mkContainerWaitResponseError =
  ContainerWaitResponseError
  { containerWaitResponseErrorMessage = Nothing
  }

-- ** CreateImageInfo
-- | CreateImageInfo
data CreateImageInfo = CreateImageInfo
  { createImageInfoId :: !(Maybe Text) -- ^ "id"
  , createImageInfoError :: !(Maybe Text) -- ^ "error"
  , createImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , createImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , createImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageInfo
instance A.FromJSON CreateImageInfo where
  parseJSON = A.withObject "CreateImageInfo" $ \o ->
    CreateImageInfo
      <$> (o .:? "id")
      <*> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON CreateImageInfo
instance A.ToJSON CreateImageInfo where
  toJSON CreateImageInfo {..} =
   _omitNulls
      [ "id" .= createImageInfoId
      , "error" .= createImageInfoError
      , "status" .= createImageInfoStatus
      , "progress" .= createImageInfoProgress
      , "progressDetail" .= createImageInfoProgressDetail
      ]


-- | Construct a value of type 'CreateImageInfo' (by applying it's required fields, if any)
mkCreateImageInfo
  :: CreateImageInfo
mkCreateImageInfo =
  CreateImageInfo
  { createImageInfoId = Nothing
  , createImageInfoError = Nothing
  , createImageInfoStatus = Nothing
  , createImageInfoProgress = Nothing
  , createImageInfoProgressDetail = Nothing
  }

-- ** DeviceMapping
-- | DeviceMapping
-- A device mapping between the host and container
data DeviceMapping = DeviceMapping
  { deviceMappingPathOnHost :: !(Maybe Text) -- ^ "PathOnHost"
  , deviceMappingPathInContainer :: !(Maybe Text) -- ^ "PathInContainer"
  , deviceMappingCgroupPermissions :: !(Maybe Text) -- ^ "CgroupPermissions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceMapping
instance A.FromJSON DeviceMapping where
  parseJSON = A.withObject "DeviceMapping" $ \o ->
    DeviceMapping
      <$> (o .:? "PathOnHost")
      <*> (o .:? "PathInContainer")
      <*> (o .:? "CgroupPermissions")

-- | ToJSON DeviceMapping
instance A.ToJSON DeviceMapping where
  toJSON DeviceMapping {..} =
   _omitNulls
      [ "PathOnHost" .= deviceMappingPathOnHost
      , "PathInContainer" .= deviceMappingPathInContainer
      , "CgroupPermissions" .= deviceMappingCgroupPermissions
      ]


-- | Construct a value of type 'DeviceMapping' (by applying it's required fields, if any)
mkDeviceMapping
  :: DeviceMapping
mkDeviceMapping =
  DeviceMapping
  { deviceMappingPathOnHost = Nothing
  , deviceMappingPathInContainer = Nothing
  , deviceMappingCgroupPermissions = Nothing
  }

-- ** DistributionInspectResponse
-- | DistributionInspectResponse
-- DistributionInspectResponse
-- 
data DistributionInspectResponse = DistributionInspectResponse
  { distributionInspectResponseDescriptor :: !(DistributionInspectResponseDescriptor) -- ^ /Required/ "Descriptor"
  , distributionInspectResponsePlatforms :: !([DistributionInspectResponsePlatformsInner]) -- ^ /Required/ "Platforms" - An array containing all platforms supported by the image
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DistributionInspectResponse
instance A.FromJSON DistributionInspectResponse where
  parseJSON = A.withObject "DistributionInspectResponse" $ \o ->
    DistributionInspectResponse
      <$> (o .:  "Descriptor")
      <*> (o .:  "Platforms")

-- | ToJSON DistributionInspectResponse
instance A.ToJSON DistributionInspectResponse where
  toJSON DistributionInspectResponse {..} =
   _omitNulls
      [ "Descriptor" .= distributionInspectResponseDescriptor
      , "Platforms" .= distributionInspectResponsePlatforms
      ]


-- | Construct a value of type 'DistributionInspectResponse' (by applying it's required fields, if any)
mkDistributionInspectResponse
  :: DistributionInspectResponseDescriptor -- ^ 'distributionInspectResponseDescriptor' 
  -> [DistributionInspectResponsePlatformsInner] -- ^ 'distributionInspectResponsePlatforms': An array containing all platforms supported by the image
  -> DistributionInspectResponse
mkDistributionInspectResponse distributionInspectResponseDescriptor distributionInspectResponsePlatforms =
  DistributionInspectResponse
  { distributionInspectResponseDescriptor
  , distributionInspectResponsePlatforms
  }

-- ** DistributionInspectResponseDescriptor
-- | DistributionInspectResponseDescriptor
-- A descriptor struct containing digest, media type, and size
data DistributionInspectResponseDescriptor = DistributionInspectResponseDescriptor
  { distributionInspectResponseDescriptorMediaType :: !(Maybe Text) -- ^ "MediaType"
  , distributionInspectResponseDescriptorSize :: !(Maybe Integer) -- ^ "Size"
  , distributionInspectResponseDescriptorDigest :: !(Maybe Text) -- ^ "Digest"
  , distributionInspectResponseDescriptorUrls :: !(Maybe [Text]) -- ^ "URLs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DistributionInspectResponseDescriptor
instance A.FromJSON DistributionInspectResponseDescriptor where
  parseJSON = A.withObject "DistributionInspectResponseDescriptor" $ \o ->
    DistributionInspectResponseDescriptor
      <$> (o .:? "MediaType")
      <*> (o .:? "Size")
      <*> (o .:? "Digest")
      <*> (o .:? "URLs")

-- | ToJSON DistributionInspectResponseDescriptor
instance A.ToJSON DistributionInspectResponseDescriptor where
  toJSON DistributionInspectResponseDescriptor {..} =
   _omitNulls
      [ "MediaType" .= distributionInspectResponseDescriptorMediaType
      , "Size" .= distributionInspectResponseDescriptorSize
      , "Digest" .= distributionInspectResponseDescriptorDigest
      , "URLs" .= distributionInspectResponseDescriptorUrls
      ]


-- | Construct a value of type 'DistributionInspectResponseDescriptor' (by applying it's required fields, if any)
mkDistributionInspectResponseDescriptor
  :: DistributionInspectResponseDescriptor
mkDistributionInspectResponseDescriptor =
  DistributionInspectResponseDescriptor
  { distributionInspectResponseDescriptorMediaType = Nothing
  , distributionInspectResponseDescriptorSize = Nothing
  , distributionInspectResponseDescriptorDigest = Nothing
  , distributionInspectResponseDescriptorUrls = Nothing
  }

-- ** DistributionInspectResponsePlatformsInner
-- | DistributionInspectResponsePlatformsInner
data DistributionInspectResponsePlatformsInner = DistributionInspectResponsePlatformsInner
  { distributionInspectResponsePlatformsInnerArchitecture :: !(Maybe Text) -- ^ "Architecture"
  , distributionInspectResponsePlatformsInnerOs :: !(Maybe Text) -- ^ "OS"
  , distributionInspectResponsePlatformsInnerOsVersion :: !(Maybe Text) -- ^ "OSVersion"
  , distributionInspectResponsePlatformsInnerOsFeatures :: !(Maybe [Text]) -- ^ "OSFeatures"
  , distributionInspectResponsePlatformsInnerVariant :: !(Maybe Text) -- ^ "Variant"
  , distributionInspectResponsePlatformsInnerFeatures :: !(Maybe [Text]) -- ^ "Features"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DistributionInspectResponsePlatformsInner
instance A.FromJSON DistributionInspectResponsePlatformsInner where
  parseJSON = A.withObject "DistributionInspectResponsePlatformsInner" $ \o ->
    DistributionInspectResponsePlatformsInner
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")
      <*> (o .:? "OSVersion")
      <*> (o .:? "OSFeatures")
      <*> (o .:? "Variant")
      <*> (o .:? "Features")

-- | ToJSON DistributionInspectResponsePlatformsInner
instance A.ToJSON DistributionInspectResponsePlatformsInner where
  toJSON DistributionInspectResponsePlatformsInner {..} =
   _omitNulls
      [ "Architecture" .= distributionInspectResponsePlatformsInnerArchitecture
      , "OS" .= distributionInspectResponsePlatformsInnerOs
      , "OSVersion" .= distributionInspectResponsePlatformsInnerOsVersion
      , "OSFeatures" .= distributionInspectResponsePlatformsInnerOsFeatures
      , "Variant" .= distributionInspectResponsePlatformsInnerVariant
      , "Features" .= distributionInspectResponsePlatformsInnerFeatures
      ]


-- | Construct a value of type 'DistributionInspectResponsePlatformsInner' (by applying it's required fields, if any)
mkDistributionInspectResponsePlatformsInner
  :: DistributionInspectResponsePlatformsInner
mkDistributionInspectResponsePlatformsInner =
  DistributionInspectResponsePlatformsInner
  { distributionInspectResponsePlatformsInnerArchitecture = Nothing
  , distributionInspectResponsePlatformsInnerOs = Nothing
  , distributionInspectResponsePlatformsInnerOsVersion = Nothing
  , distributionInspectResponsePlatformsInnerOsFeatures = Nothing
  , distributionInspectResponsePlatformsInnerVariant = Nothing
  , distributionInspectResponsePlatformsInnerFeatures = Nothing
  }

-- ** Driver
-- | Driver
-- Driver represents a driver (network, logging, secrets).
data Driver = Driver
  { driverName :: !(Text) -- ^ /Required/ "Name" - Name of the driver.
  , driverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Key/value map of driver-specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Driver
instance A.FromJSON Driver where
  parseJSON = A.withObject "Driver" $ \o ->
    Driver
      <$> (o .:  "Name")
      <*> (o .:? "Options")

-- | ToJSON Driver
instance A.ToJSON Driver where
  toJSON Driver {..} =
   _omitNulls
      [ "Name" .= driverName
      , "Options" .= driverOptions
      ]


-- | Construct a value of type 'Driver' (by applying it's required fields, if any)
mkDriver
  :: Text -- ^ 'driverName': Name of the driver.
  -> Driver
mkDriver driverName =
  Driver
  { driverName
  , driverOptions = Nothing
  }

-- ** EndpointIPAMConfig
-- | EndpointIPAMConfig
-- EndpointIPAMConfig represents an endpoint's IPAM configuration. 
data EndpointIPAMConfig = EndpointIPAMConfig
  { endpointIPAMConfigIpv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , endpointIPAMConfigIpv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  , endpointIPAMConfigLinkLocalIps :: !(Maybe [Text]) -- ^ "LinkLocalIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointIPAMConfig
instance A.FromJSON EndpointIPAMConfig where
  parseJSON = A.withObject "EndpointIPAMConfig" $ \o ->
    EndpointIPAMConfig
      <$> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")
      <*> (o .:? "LinkLocalIPs")

-- | ToJSON EndpointIPAMConfig
instance A.ToJSON EndpointIPAMConfig where
  toJSON EndpointIPAMConfig {..} =
   _omitNulls
      [ "IPv4Address" .= endpointIPAMConfigIpv4Address
      , "IPv6Address" .= endpointIPAMConfigIpv6Address
      , "LinkLocalIPs" .= endpointIPAMConfigLinkLocalIps
      ]


-- | Construct a value of type 'EndpointIPAMConfig' (by applying it's required fields, if any)
mkEndpointIPAMConfig
  :: EndpointIPAMConfig
mkEndpointIPAMConfig =
  EndpointIPAMConfig
  { endpointIPAMConfigIpv4Address = Nothing
  , endpointIPAMConfigIpv6Address = Nothing
  , endpointIPAMConfigLinkLocalIps = Nothing
  }

-- ** EndpointPortConfig
-- | EndpointPortConfig
data EndpointPortConfig = EndpointPortConfig
  { endpointPortConfigName :: !(Maybe Text) -- ^ "Name"
  , endpointPortConfigProtocol :: !(Maybe E'Type) -- ^ "Protocol"
  , endpointPortConfigTargetPort :: !(Maybe Int) -- ^ "TargetPort" - The port inside the container.
  , endpointPortConfigPublishedPort :: !(Maybe Int) -- ^ "PublishedPort" - The port on the swarm hosts.
  , endpointPortConfigPublishMode :: !(Maybe E'PublishMode) -- ^ "PublishMode" - The mode in which port is published.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  - \&quot;ingress\&quot; makes the target port accessible on on every node,   regardless of whether there is a task for the service running on   that node or not. - \&quot;host\&quot; bypasses the routing mesh and publish the port directly on   the swarm node where that service is running. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointPortConfig
instance A.FromJSON EndpointPortConfig where
  parseJSON = A.withObject "EndpointPortConfig" $ \o ->
    EndpointPortConfig
      <$> (o .:? "Name")
      <*> (o .:? "Protocol")
      <*> (o .:? "TargetPort")
      <*> (o .:? "PublishedPort")
      <*> (o .:? "PublishMode")

-- | ToJSON EndpointPortConfig
instance A.ToJSON EndpointPortConfig where
  toJSON EndpointPortConfig {..} =
   _omitNulls
      [ "Name" .= endpointPortConfigName
      , "Protocol" .= endpointPortConfigProtocol
      , "TargetPort" .= endpointPortConfigTargetPort
      , "PublishedPort" .= endpointPortConfigPublishedPort
      , "PublishMode" .= endpointPortConfigPublishMode
      ]


-- | Construct a value of type 'EndpointPortConfig' (by applying it's required fields, if any)
mkEndpointPortConfig
  :: EndpointPortConfig
mkEndpointPortConfig =
  EndpointPortConfig
  { endpointPortConfigName = Nothing
  , endpointPortConfigProtocol = Nothing
  , endpointPortConfigTargetPort = Nothing
  , endpointPortConfigPublishedPort = Nothing
  , endpointPortConfigPublishMode = Nothing
  }

-- ** EndpointSettings
-- | EndpointSettings
-- Configuration for a network endpoint.
data EndpointSettings = EndpointSettings
  { endpointSettingsIpamConfig :: !(Maybe EndpointIPAMConfig) -- ^ "IPAMConfig"
  , endpointSettingsLinks :: !(Maybe [Text]) -- ^ "Links"
  , endpointSettingsAliases :: !(Maybe [Text]) -- ^ "Aliases"
  , endpointSettingsNetworkId :: !(Maybe Text) -- ^ "NetworkID" - Unique ID of the network. 
  , endpointSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID" - Unique ID for the service endpoint in a Sandbox. 
  , endpointSettingsGateway :: !(Maybe Text) -- ^ "Gateway" - Gateway address for this network. 
  , endpointSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress" - IPv4 address. 
  , endpointSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen" - Mask length of the IPv4 address. 
  , endpointSettingsIpv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway" - IPv6 gateway address. 
  , endpointSettingsGlobalIpv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address" - Global IPv6 address. 
  , endpointSettingsGlobalIpv6PrefixLen :: !(Maybe Integer) -- ^ "GlobalIPv6PrefixLen" - Mask length of the global IPv6 address. 
  , endpointSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address for the endpoint on this network. 
  , endpointSettingsDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - DriverOpts is a mapping of driver options and values. These options are passed directly to the driver and are driver specific. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettings
instance A.FromJSON EndpointSettings where
  parseJSON = A.withObject "EndpointSettings" $ \o ->
    EndpointSettings
      <$> (o .:? "IPAMConfig")
      <*> (o .:? "Links")
      <*> (o .:? "Aliases")
      <*> (o .:? "NetworkID")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "MacAddress")
      <*> (o .:? "DriverOpts")

-- | ToJSON EndpointSettings
instance A.ToJSON EndpointSettings where
  toJSON EndpointSettings {..} =
   _omitNulls
      [ "IPAMConfig" .= endpointSettingsIpamConfig
      , "Links" .= endpointSettingsLinks
      , "Aliases" .= endpointSettingsAliases
      , "NetworkID" .= endpointSettingsNetworkId
      , "EndpointID" .= endpointSettingsEndpointId
      , "Gateway" .= endpointSettingsGateway
      , "IPAddress" .= endpointSettingsIpAddress
      , "IPPrefixLen" .= endpointSettingsIpPrefixLen
      , "IPv6Gateway" .= endpointSettingsIpv6Gateway
      , "GlobalIPv6Address" .= endpointSettingsGlobalIpv6Address
      , "GlobalIPv6PrefixLen" .= endpointSettingsGlobalIpv6PrefixLen
      , "MacAddress" .= endpointSettingsMacAddress
      , "DriverOpts" .= endpointSettingsDriverOpts
      ]


-- | Construct a value of type 'EndpointSettings' (by applying it's required fields, if any)
mkEndpointSettings
  :: EndpointSettings
mkEndpointSettings =
  EndpointSettings
  { endpointSettingsIpamConfig = Nothing
  , endpointSettingsLinks = Nothing
  , endpointSettingsAliases = Nothing
  , endpointSettingsNetworkId = Nothing
  , endpointSettingsEndpointId = Nothing
  , endpointSettingsGateway = Nothing
  , endpointSettingsIpAddress = Nothing
  , endpointSettingsIpPrefixLen = Nothing
  , endpointSettingsIpv6Gateway = Nothing
  , endpointSettingsGlobalIpv6Address = Nothing
  , endpointSettingsGlobalIpv6PrefixLen = Nothing
  , endpointSettingsMacAddress = Nothing
  , endpointSettingsDriverOpts = Nothing
  }

-- ** EndpointSpec
-- | EndpointSpec
-- Properties that can be configured to access and load balance a service.
data EndpointSpec = EndpointSpec
  { endpointSpecMode :: !(Maybe E'Mode) -- ^ "Mode" - The mode of resolution to use for internal load balancing between tasks.
  , endpointSpecPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports" - List of exposed ports that this service is accessible on from the outside. Ports can only be provided if &#x60;vip&#x60; resolution mode is used.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSpec
instance A.FromJSON EndpointSpec where
  parseJSON = A.withObject "EndpointSpec" $ \o ->
    EndpointSpec
      <$> (o .:? "Mode")
      <*> (o .:? "Ports")

-- | ToJSON EndpointSpec
instance A.ToJSON EndpointSpec where
  toJSON EndpointSpec {..} =
   _omitNulls
      [ "Mode" .= endpointSpecMode
      , "Ports" .= endpointSpecPorts
      ]


-- | Construct a value of type 'EndpointSpec' (by applying it's required fields, if any)
mkEndpointSpec
  :: EndpointSpec
mkEndpointSpec =
  EndpointSpec
  { endpointSpecMode = Nothing
  , endpointSpecPorts = Nothing
  }

-- ** EngineDescription
-- | EngineDescription
-- EngineDescription provides information about an engine.
data EngineDescription = EngineDescription
  { engineDescriptionEngineVersion :: !(Maybe Text) -- ^ "EngineVersion"
  , engineDescriptionLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  , engineDescriptionPlugins :: !(Maybe [EngineDescriptionPluginsInner]) -- ^ "Plugins"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EngineDescription
instance A.FromJSON EngineDescription where
  parseJSON = A.withObject "EngineDescription" $ \o ->
    EngineDescription
      <$> (o .:? "EngineVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "Plugins")

-- | ToJSON EngineDescription
instance A.ToJSON EngineDescription where
  toJSON EngineDescription {..} =
   _omitNulls
      [ "EngineVersion" .= engineDescriptionEngineVersion
      , "Labels" .= engineDescriptionLabels
      , "Plugins" .= engineDescriptionPlugins
      ]


-- | Construct a value of type 'EngineDescription' (by applying it's required fields, if any)
mkEngineDescription
  :: EngineDescription
mkEngineDescription =
  EngineDescription
  { engineDescriptionEngineVersion = Nothing
  , engineDescriptionLabels = Nothing
  , engineDescriptionPlugins = Nothing
  }

-- ** EngineDescriptionPluginsInner
-- | EngineDescriptionPluginsInner
data EngineDescriptionPluginsInner = EngineDescriptionPluginsInner
  { engineDescriptionPluginsInnerType :: !(Maybe Text) -- ^ "Type"
  , engineDescriptionPluginsInnerName :: !(Maybe Text) -- ^ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EngineDescriptionPluginsInner
instance A.FromJSON EngineDescriptionPluginsInner where
  parseJSON = A.withObject "EngineDescriptionPluginsInner" $ \o ->
    EngineDescriptionPluginsInner
      <$> (o .:? "Type")
      <*> (o .:? "Name")

-- | ToJSON EngineDescriptionPluginsInner
instance A.ToJSON EngineDescriptionPluginsInner where
  toJSON EngineDescriptionPluginsInner {..} =
   _omitNulls
      [ "Type" .= engineDescriptionPluginsInnerType
      , "Name" .= engineDescriptionPluginsInnerName
      ]


-- | Construct a value of type 'EngineDescriptionPluginsInner' (by applying it's required fields, if any)
mkEngineDescriptionPluginsInner
  :: EngineDescriptionPluginsInner
mkEngineDescriptionPluginsInner =
  EngineDescriptionPluginsInner
  { engineDescriptionPluginsInnerType = Nothing
  , engineDescriptionPluginsInnerName = Nothing
  }

-- ** ErrorDetail
-- | ErrorDetail
data ErrorDetail = ErrorDetail
  { errorDetailCode :: !(Maybe Int) -- ^ "code"
  , errorDetailMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetail
instance A.FromJSON ErrorDetail where
  parseJSON = A.withObject "ErrorDetail" $ \o ->
    ErrorDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ErrorDetail
instance A.ToJSON ErrorDetail where
  toJSON ErrorDetail {..} =
   _omitNulls
      [ "code" .= errorDetailCode
      , "message" .= errorDetailMessage
      ]


-- | Construct a value of type 'ErrorDetail' (by applying it's required fields, if any)
mkErrorDetail
  :: ErrorDetail
mkErrorDetail =
  ErrorDetail
  { errorDetailCode = Nothing
  , errorDetailMessage = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
-- Represents an error.
data ErrorResponse = ErrorResponse
  { errorResponseMessage :: !(Text) -- ^ /Required/ "message" - The error message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "message")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "message" .= errorResponseMessage
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseMessage': The error message.
  -> ErrorResponse
mkErrorResponse errorResponseMessage =
  ErrorResponse
  { errorResponseMessage
  }

-- ** ExecInspectResponse
-- | ExecInspectResponse
-- ExecInspectResponse
-- 
data ExecInspectResponse = ExecInspectResponse
  { execInspectResponseCanRemove :: !(Maybe Bool) -- ^ "CanRemove"
  , execInspectResponseDetachKeys :: !(Maybe Text) -- ^ "DetachKeys"
  , execInspectResponseId :: !(Maybe Text) -- ^ "ID"
  , execInspectResponseRunning :: !(Maybe Bool) -- ^ "Running"
  , execInspectResponseExitCode :: !(Maybe Int) -- ^ "ExitCode"
  , execInspectResponseProcessConfig :: !(Maybe ProcessConfig) -- ^ "ProcessConfig"
  , execInspectResponseOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin"
  , execInspectResponseOpenStderr :: !(Maybe Bool) -- ^ "OpenStderr"
  , execInspectResponseOpenStdout :: !(Maybe Bool) -- ^ "OpenStdout"
  , execInspectResponseContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , execInspectResponsePid :: !(Maybe Int) -- ^ "Pid" - The system process ID for the exec process.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecInspectResponse
instance A.FromJSON ExecInspectResponse where
  parseJSON = A.withObject "ExecInspectResponse" $ \o ->
    ExecInspectResponse
      <$> (o .:? "CanRemove")
      <*> (o .:? "DetachKeys")
      <*> (o .:? "ID")
      <*> (o .:? "Running")
      <*> (o .:? "ExitCode")
      <*> (o .:? "ProcessConfig")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "OpenStderr")
      <*> (o .:? "OpenStdout")
      <*> (o .:? "ContainerID")
      <*> (o .:? "Pid")

-- | ToJSON ExecInspectResponse
instance A.ToJSON ExecInspectResponse where
  toJSON ExecInspectResponse {..} =
   _omitNulls
      [ "CanRemove" .= execInspectResponseCanRemove
      , "DetachKeys" .= execInspectResponseDetachKeys
      , "ID" .= execInspectResponseId
      , "Running" .= execInspectResponseRunning
      , "ExitCode" .= execInspectResponseExitCode
      , "ProcessConfig" .= execInspectResponseProcessConfig
      , "OpenStdin" .= execInspectResponseOpenStdin
      , "OpenStderr" .= execInspectResponseOpenStderr
      , "OpenStdout" .= execInspectResponseOpenStdout
      , "ContainerID" .= execInspectResponseContainerId
      , "Pid" .= execInspectResponsePid
      ]


-- | Construct a value of type 'ExecInspectResponse' (by applying it's required fields, if any)
mkExecInspectResponse
  :: ExecInspectResponse
mkExecInspectResponse =
  ExecInspectResponse
  { execInspectResponseCanRemove = Nothing
  , execInspectResponseDetachKeys = Nothing
  , execInspectResponseId = Nothing
  , execInspectResponseRunning = Nothing
  , execInspectResponseExitCode = Nothing
  , execInspectResponseProcessConfig = Nothing
  , execInspectResponseOpenStdin = Nothing
  , execInspectResponseOpenStderr = Nothing
  , execInspectResponseOpenStdout = Nothing
  , execInspectResponseContainerId = Nothing
  , execInspectResponsePid = Nothing
  }

-- ** ExecStartRequest
-- | ExecStartRequest
data ExecStartRequest = ExecStartRequest
  { execStartRequestDetach :: !(Maybe Bool) -- ^ "Detach" - Detach from the command.
  , execStartRequestTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecStartRequest
instance A.FromJSON ExecStartRequest where
  parseJSON = A.withObject "ExecStartRequest" $ \o ->
    ExecStartRequest
      <$> (o .:? "Detach")
      <*> (o .:? "Tty")

-- | ToJSON ExecStartRequest
instance A.ToJSON ExecStartRequest where
  toJSON ExecStartRequest {..} =
   _omitNulls
      [ "Detach" .= execStartRequestDetach
      , "Tty" .= execStartRequestTty
      ]


-- | Construct a value of type 'ExecStartRequest' (by applying it's required fields, if any)
mkExecStartRequest
  :: ExecStartRequest
mkExecStartRequest =
  ExecStartRequest
  { execStartRequestDetach = Nothing
  , execStartRequestTty = Nothing
  }

-- ** GenericResourcesInner
-- | GenericResourcesInner
data GenericResourcesInner = GenericResourcesInner
  { genericResourcesInnerNamedResourceSpec :: !(Maybe GenericResourcesInnerNamedResourceSpec) -- ^ "NamedResourceSpec"
  , genericResourcesInnerDiscreteResourceSpec :: !(Maybe GenericResourcesInnerDiscreteResourceSpec) -- ^ "DiscreteResourceSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResourcesInner
instance A.FromJSON GenericResourcesInner where
  parseJSON = A.withObject "GenericResourcesInner" $ \o ->
    GenericResourcesInner
      <$> (o .:? "NamedResourceSpec")
      <*> (o .:? "DiscreteResourceSpec")

-- | ToJSON GenericResourcesInner
instance A.ToJSON GenericResourcesInner where
  toJSON GenericResourcesInner {..} =
   _omitNulls
      [ "NamedResourceSpec" .= genericResourcesInnerNamedResourceSpec
      , "DiscreteResourceSpec" .= genericResourcesInnerDiscreteResourceSpec
      ]


-- | Construct a value of type 'GenericResourcesInner' (by applying it's required fields, if any)
mkGenericResourcesInner
  :: GenericResourcesInner
mkGenericResourcesInner =
  GenericResourcesInner
  { genericResourcesInnerNamedResourceSpec = Nothing
  , genericResourcesInnerDiscreteResourceSpec = Nothing
  }

-- ** GenericResourcesInnerDiscreteResourceSpec
-- | GenericResourcesInnerDiscreteResourceSpec
data GenericResourcesInnerDiscreteResourceSpec = GenericResourcesInnerDiscreteResourceSpec
  { genericResourcesInnerDiscreteResourceSpecKind :: !(Maybe Text) -- ^ "Kind"
  , genericResourcesInnerDiscreteResourceSpecValue :: !(Maybe Integer) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResourcesInnerDiscreteResourceSpec
instance A.FromJSON GenericResourcesInnerDiscreteResourceSpec where
  parseJSON = A.withObject "GenericResourcesInnerDiscreteResourceSpec" $ \o ->
    GenericResourcesInnerDiscreteResourceSpec
      <$> (o .:? "Kind")
      <*> (o .:? "Value")

-- | ToJSON GenericResourcesInnerDiscreteResourceSpec
instance A.ToJSON GenericResourcesInnerDiscreteResourceSpec where
  toJSON GenericResourcesInnerDiscreteResourceSpec {..} =
   _omitNulls
      [ "Kind" .= genericResourcesInnerDiscreteResourceSpecKind
      , "Value" .= genericResourcesInnerDiscreteResourceSpecValue
      ]


-- | Construct a value of type 'GenericResourcesInnerDiscreteResourceSpec' (by applying it's required fields, if any)
mkGenericResourcesInnerDiscreteResourceSpec
  :: GenericResourcesInnerDiscreteResourceSpec
mkGenericResourcesInnerDiscreteResourceSpec =
  GenericResourcesInnerDiscreteResourceSpec
  { genericResourcesInnerDiscreteResourceSpecKind = Nothing
  , genericResourcesInnerDiscreteResourceSpecValue = Nothing
  }

-- ** GenericResourcesInnerNamedResourceSpec
-- | GenericResourcesInnerNamedResourceSpec
data GenericResourcesInnerNamedResourceSpec = GenericResourcesInnerNamedResourceSpec
  { genericResourcesInnerNamedResourceSpecKind :: !(Maybe Text) -- ^ "Kind"
  , genericResourcesInnerNamedResourceSpecValue :: !(Maybe Text) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResourcesInnerNamedResourceSpec
instance A.FromJSON GenericResourcesInnerNamedResourceSpec where
  parseJSON = A.withObject "GenericResourcesInnerNamedResourceSpec" $ \o ->
    GenericResourcesInnerNamedResourceSpec
      <$> (o .:? "Kind")
      <*> (o .:? "Value")

-- | ToJSON GenericResourcesInnerNamedResourceSpec
instance A.ToJSON GenericResourcesInnerNamedResourceSpec where
  toJSON GenericResourcesInnerNamedResourceSpec {..} =
   _omitNulls
      [ "Kind" .= genericResourcesInnerNamedResourceSpecKind
      , "Value" .= genericResourcesInnerNamedResourceSpecValue
      ]


-- | Construct a value of type 'GenericResourcesInnerNamedResourceSpec' (by applying it's required fields, if any)
mkGenericResourcesInnerNamedResourceSpec
  :: GenericResourcesInnerNamedResourceSpec
mkGenericResourcesInnerNamedResourceSpec =
  GenericResourcesInnerNamedResourceSpec
  { genericResourcesInnerNamedResourceSpecKind = Nothing
  , genericResourcesInnerNamedResourceSpecValue = Nothing
  }

-- ** GraphDriverData
-- | GraphDriverData
-- Information about a container's graph driver.
data GraphDriverData = GraphDriverData
  { graphDriverDataName :: !(Text) -- ^ /Required/ "Name"
  , graphDriverDataData :: !((Map.Map String Text)) -- ^ /Required/ "Data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GraphDriverData
instance A.FromJSON GraphDriverData where
  parseJSON = A.withObject "GraphDriverData" $ \o ->
    GraphDriverData
      <$> (o .:  "Name")
      <*> (o .:  "Data")

-- | ToJSON GraphDriverData
instance A.ToJSON GraphDriverData where
  toJSON GraphDriverData {..} =
   _omitNulls
      [ "Name" .= graphDriverDataName
      , "Data" .= graphDriverDataData
      ]


-- | Construct a value of type 'GraphDriverData' (by applying it's required fields, if any)
mkGraphDriverData
  :: Text -- ^ 'graphDriverDataName' 
  -> (Map.Map String Text) -- ^ 'graphDriverDataData' 
  -> GraphDriverData
mkGraphDriverData graphDriverDataName graphDriverDataData =
  GraphDriverData
  { graphDriverDataName
  , graphDriverDataData
  }

-- ** HealthConfig
-- | HealthConfig
-- A test to perform to check that the container is healthy.
data HealthConfig = HealthConfig
  { healthConfigTest :: !(Maybe [Text]) -- ^ "Test" - The test to perform. Possible values are:  - &#x60;[]&#x60; inherit healthcheck from image or parent image - &#x60;[\&quot;NONE\&quot;]&#x60; disable healthcheck - &#x60;[\&quot;CMD\&quot;, args...]&#x60; exec arguments directly - &#x60;[\&quot;CMD-SHELL\&quot;, command]&#x60; run command with system&#39;s default shell 
  , healthConfigInterval :: !(Maybe Int) -- ^ "Interval" - The time to wait between checks in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  , healthConfigTimeout :: !(Maybe Int) -- ^ "Timeout" - The time to wait before considering the check to have hung. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  , healthConfigRetries :: !(Maybe Int) -- ^ "Retries" - The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.
  , healthConfigStartPeriod :: !(Maybe Int) -- ^ "StartPeriod" - Start period for the container to initialize before starting health-retries countdown in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HealthConfig
instance A.FromJSON HealthConfig where
  parseJSON = A.withObject "HealthConfig" $ \o ->
    HealthConfig
      <$> (o .:? "Test")
      <*> (o .:? "Interval")
      <*> (o .:? "Timeout")
      <*> (o .:? "Retries")
      <*> (o .:? "StartPeriod")

-- | ToJSON HealthConfig
instance A.ToJSON HealthConfig where
  toJSON HealthConfig {..} =
   _omitNulls
      [ "Test" .= healthConfigTest
      , "Interval" .= healthConfigInterval
      , "Timeout" .= healthConfigTimeout
      , "Retries" .= healthConfigRetries
      , "StartPeriod" .= healthConfigStartPeriod
      ]


-- | Construct a value of type 'HealthConfig' (by applying it's required fields, if any)
mkHealthConfig
  :: HealthConfig
mkHealthConfig =
  HealthConfig
  { healthConfigTest = Nothing
  , healthConfigInterval = Nothing
  , healthConfigTimeout = Nothing
  , healthConfigRetries = Nothing
  , healthConfigStartPeriod = Nothing
  }

-- ** HistoryResponseItem
-- | HistoryResponseItem
-- HistoryResponseItem
-- 
-- individual image layer information in response to ImageHistory operation
data HistoryResponseItem = HistoryResponseItem
  { historyResponseItemId :: !(Text) -- ^ /Required/ "Id"
  , historyResponseItemCreated :: !(Integer) -- ^ /Required/ "Created"
  , historyResponseItemCreatedBy :: !(Text) -- ^ /Required/ "CreatedBy"
  , historyResponseItemTags :: !([Text]) -- ^ /Required/ "Tags"
  , historyResponseItemSize :: !(Integer) -- ^ /Required/ "Size"
  , historyResponseItemComment :: !(Text) -- ^ /Required/ "Comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistoryResponseItem
instance A.FromJSON HistoryResponseItem where
  parseJSON = A.withObject "HistoryResponseItem" $ \o ->
    HistoryResponseItem
      <$> (o .:  "Id")
      <*> (o .:  "Created")
      <*> (o .:  "CreatedBy")
      <*> (o .:  "Tags")
      <*> (o .:  "Size")
      <*> (o .:  "Comment")

-- | ToJSON HistoryResponseItem
instance A.ToJSON HistoryResponseItem where
  toJSON HistoryResponseItem {..} =
   _omitNulls
      [ "Id" .= historyResponseItemId
      , "Created" .= historyResponseItemCreated
      , "CreatedBy" .= historyResponseItemCreatedBy
      , "Tags" .= historyResponseItemTags
      , "Size" .= historyResponseItemSize
      , "Comment" .= historyResponseItemComment
      ]


-- | Construct a value of type 'HistoryResponseItem' (by applying it's required fields, if any)
mkHistoryResponseItem
  :: Text -- ^ 'historyResponseItemId' 
  -> Integer -- ^ 'historyResponseItemCreated' 
  -> Text -- ^ 'historyResponseItemCreatedBy' 
  -> [Text] -- ^ 'historyResponseItemTags' 
  -> Integer -- ^ 'historyResponseItemSize' 
  -> Text -- ^ 'historyResponseItemComment' 
  -> HistoryResponseItem
mkHistoryResponseItem historyResponseItemId historyResponseItemCreated historyResponseItemCreatedBy historyResponseItemTags historyResponseItemSize historyResponseItemComment =
  HistoryResponseItem
  { historyResponseItemId
  , historyResponseItemCreated
  , historyResponseItemCreatedBy
  , historyResponseItemTags
  , historyResponseItemSize
  , historyResponseItemComment
  }

-- ** HostConfig
-- | HostConfig
-- Container configuration that depends on the host we are running on
data HostConfig = HostConfig
  { hostConfigCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , hostConfigMemory :: !(Maybe Integer) -- ^ "Memory" - Memory limit in bytes.
  , hostConfigCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , hostConfigBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , hostConfigBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDeviceInner]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , hostConfigBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , hostConfigCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , hostConfigCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , hostConfigCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , hostConfigCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , hostConfigCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , hostConfigDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , hostConfigDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , hostConfigDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , hostConfigKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , hostConfigMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , hostConfigMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , hostConfigMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , hostConfigNanoCpus :: !(Maybe Integer) -- ^ "NanoCpus" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , hostConfigOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , hostConfigPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , hostConfigUlimits :: !(Maybe [ResourcesUlimitsInner]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , hostConfigCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , hostConfigIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  , hostConfigBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest&#x60; to bind-mount a host path into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;host-src:container-dest:ro&#x60; to make the bind mount read-only inside the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest&#x60; to bind-mount a volume managed by a volume driver into the container. &#x60;container-dest&#x60; must be an _absolute_ path. - &#x60;volume-name:container-dest:ro&#x60; to mount the volume read-only inside the container.  &#x60;container-dest&#x60; must be an _absolute_ path. 
  , hostConfigContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigLogConfig :: !(Maybe HostConfigAllOfLogConfig) -- ^ "LogConfig"
  , hostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to.
  , hostConfigPortBindings :: !(Maybe (Map.Map String [PortBinding])) -- ^ "PortBindings" - PortMap describes the mapping of container ports to host ports, using the container&#39;s port-number and protocol as key in the format &#x60;&lt;port&gt;/&lt;protocol&gt;&#x60;, for example, &#x60;80/udp&#x60;.  If a container&#39;s port is mapped for both &#x60;tcp&#x60; and &#x60;udp&#x60;, two separate entries are added to the mapping table. 
  , hostConfigRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set.
  , hostConfigVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;.
  , hostConfigMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container.
  , hostConfigCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container.
  , hostConfigCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container.
  , hostConfigDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as.
  , hostConfigIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC sharing mode for the container. Possible values are:  - &#x60;\&quot;none\&quot;&#x60;: own private IPC namespace, with /dev/shm not mounted - &#x60;\&quot;private\&quot;&#x60;: own private IPC namespace - &#x60;\&quot;shareable\&quot;&#x60;: own private IPC namespace, with a possibility to share it with other containers - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: join another (shareable) container&#39;s IPC namespace - &#x60;\&quot;host\&quot;&#x60;: use the host system&#39;s IPC namespace  If not specified, daemon default is used, which can either be &#x60;\&quot;private\&quot;&#x60; or &#x60;\&quot;shareable\&quot;&#x60;, depending on daemon version and configuration. 
  , hostConfigCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;.
  , hostConfigOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences.
  , hostConfigPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates an ephemeral host port for all of a container&#39;s exposed ports.  Ports are de-allocated when the container stops and allocated when the container starts. The allocated port might be changed when restarting the container.  The port is selected from the ephemeral port range that depends on the kernel. For example, on Linux the range is defined by &#x60;/proc/sys/net/ipv4/ip_local_port_range&#x60;. 
  , hostConfigReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux.
  , hostConfigStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: &#x60;{ \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; }&#x60;. 
  , hostConfigUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
  , hostConfigShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB.
  , hostConfigSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example: &#x60;{\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;}&#x60; 
  , hostConfigRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only)
  , hostConfigIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfig
instance A.FromJSON HostConfig where
  parseJSON = A.withObject "HostConfig" $ \o ->
    HostConfig
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCpus")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")
      <*> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")

-- | ToJSON HostConfig
instance A.ToJSON HostConfig where
  toJSON HostConfig {..} =
   _omitNulls
      [ "CpuShares" .= hostConfigCpuShares
      , "Memory" .= hostConfigMemory
      , "CgroupParent" .= hostConfigCgroupParent
      , "BlkioWeight" .= hostConfigBlkioWeight
      , "BlkioWeightDevice" .= hostConfigBlkioWeightDevice
      , "BlkioDeviceReadBps" .= hostConfigBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= hostConfigBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= hostConfigBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= hostConfigBlkioDeviceWriteIOps
      , "CpuPeriod" .= hostConfigCpuPeriod
      , "CpuQuota" .= hostConfigCpuQuota
      , "CpuRealtimePeriod" .= hostConfigCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= hostConfigCpuRealtimeRuntime
      , "CpusetCpus" .= hostConfigCpusetCpus
      , "CpusetMems" .= hostConfigCpusetMems
      , "Devices" .= hostConfigDevices
      , "DeviceCgroupRules" .= hostConfigDeviceCgroupRules
      , "DiskQuota" .= hostConfigDiskQuota
      , "KernelMemory" .= hostConfigKernelMemory
      , "MemoryReservation" .= hostConfigMemoryReservation
      , "MemorySwap" .= hostConfigMemorySwap
      , "MemorySwappiness" .= hostConfigMemorySwappiness
      , "NanoCpus" .= hostConfigNanoCpus
      , "OomKillDisable" .= hostConfigOomKillDisable
      , "PidsLimit" .= hostConfigPidsLimit
      , "Ulimits" .= hostConfigUlimits
      , "CpuCount" .= hostConfigCpuCount
      , "CpuPercent" .= hostConfigCpuPercent
      , "IOMaximumIOps" .= hostConfigIoMaximumIOps
      , "IOMaximumBandwidth" .= hostConfigIoMaximumBandwidth
      , "Binds" .= hostConfigBinds
      , "ContainerIDFile" .= hostConfigContainerIdFile
      , "LogConfig" .= hostConfigLogConfig
      , "NetworkMode" .= hostConfigNetworkMode
      , "PortBindings" .= hostConfigPortBindings
      , "RestartPolicy" .= hostConfigRestartPolicy
      , "AutoRemove" .= hostConfigAutoRemove
      , "VolumeDriver" .= hostConfigVolumeDriver
      , "VolumesFrom" .= hostConfigVolumesFrom
      , "Mounts" .= hostConfigMounts
      , "CapAdd" .= hostConfigCapAdd
      , "CapDrop" .= hostConfigCapDrop
      , "Dns" .= hostConfigDns
      , "DnsOptions" .= hostConfigDnsOptions
      , "DnsSearch" .= hostConfigDnsSearch
      , "ExtraHosts" .= hostConfigExtraHosts
      , "GroupAdd" .= hostConfigGroupAdd
      , "IpcMode" .= hostConfigIpcMode
      , "Cgroup" .= hostConfigCgroup
      , "Links" .= hostConfigLinks
      , "OomScoreAdj" .= hostConfigOomScoreAdj
      , "PidMode" .= hostConfigPidMode
      , "Privileged" .= hostConfigPrivileged
      , "PublishAllPorts" .= hostConfigPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigReadonlyRootfs
      , "SecurityOpt" .= hostConfigSecurityOpt
      , "StorageOpt" .= hostConfigStorageOpt
      , "Tmpfs" .= hostConfigTmpfs
      , "UTSMode" .= hostConfigUtsMode
      , "UsernsMode" .= hostConfigUsernsMode
      , "ShmSize" .= hostConfigShmSize
      , "Sysctls" .= hostConfigSysctls
      , "Runtime" .= hostConfigRuntime
      , "ConsoleSize" .= hostConfigConsoleSize
      , "Isolation" .= hostConfigIsolation
      ]


-- | Construct a value of type 'HostConfig' (by applying it's required fields, if any)
mkHostConfig
  :: HostConfig
mkHostConfig =
  HostConfig
  { hostConfigCpuShares = Nothing
  , hostConfigMemory = Nothing
  , hostConfigCgroupParent = Nothing
  , hostConfigBlkioWeight = Nothing
  , hostConfigBlkioWeightDevice = Nothing
  , hostConfigBlkioDeviceReadBps = Nothing
  , hostConfigBlkioDeviceWriteBps = Nothing
  , hostConfigBlkioDeviceReadIOps = Nothing
  , hostConfigBlkioDeviceWriteIOps = Nothing
  , hostConfigCpuPeriod = Nothing
  , hostConfigCpuQuota = Nothing
  , hostConfigCpuRealtimePeriod = Nothing
  , hostConfigCpuRealtimeRuntime = Nothing
  , hostConfigCpusetCpus = Nothing
  , hostConfigCpusetMems = Nothing
  , hostConfigDevices = Nothing
  , hostConfigDeviceCgroupRules = Nothing
  , hostConfigDiskQuota = Nothing
  , hostConfigKernelMemory = Nothing
  , hostConfigMemoryReservation = Nothing
  , hostConfigMemorySwap = Nothing
  , hostConfigMemorySwappiness = Nothing
  , hostConfigNanoCpus = Nothing
  , hostConfigOomKillDisable = Nothing
  , hostConfigPidsLimit = Nothing
  , hostConfigUlimits = Nothing
  , hostConfigCpuCount = Nothing
  , hostConfigCpuPercent = Nothing
  , hostConfigIoMaximumIOps = Nothing
  , hostConfigIoMaximumBandwidth = Nothing
  , hostConfigBinds = Nothing
  , hostConfigContainerIdFile = Nothing
  , hostConfigLogConfig = Nothing
  , hostConfigNetworkMode = Nothing
  , hostConfigPortBindings = Nothing
  , hostConfigRestartPolicy = Nothing
  , hostConfigAutoRemove = Nothing
  , hostConfigVolumeDriver = Nothing
  , hostConfigVolumesFrom = Nothing
  , hostConfigMounts = Nothing
  , hostConfigCapAdd = Nothing
  , hostConfigCapDrop = Nothing
  , hostConfigDns = Nothing
  , hostConfigDnsOptions = Nothing
  , hostConfigDnsSearch = Nothing
  , hostConfigExtraHosts = Nothing
  , hostConfigGroupAdd = Nothing
  , hostConfigIpcMode = Nothing
  , hostConfigCgroup = Nothing
  , hostConfigLinks = Nothing
  , hostConfigOomScoreAdj = Nothing
  , hostConfigPidMode = Nothing
  , hostConfigPrivileged = Nothing
  , hostConfigPublishAllPorts = Nothing
  , hostConfigReadonlyRootfs = Nothing
  , hostConfigSecurityOpt = Nothing
  , hostConfigStorageOpt = Nothing
  , hostConfigTmpfs = Nothing
  , hostConfigUtsMode = Nothing
  , hostConfigUsernsMode = Nothing
  , hostConfigShmSize = Nothing
  , hostConfigSysctls = Nothing
  , hostConfigRuntime = Nothing
  , hostConfigConsoleSize = Nothing
  , hostConfigIsolation = Nothing
  }

-- ** HostConfigAllOfLogConfig
-- | HostConfigAllOfLogConfig
-- The logging configuration for this container
data HostConfigAllOfLogConfig = HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType :: !(Maybe E'Type4) -- ^ "Type"
  , hostConfigAllOfLogConfigConfig :: !(Maybe (Map.Map String Text)) -- ^ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOfLogConfig
instance A.FromJSON HostConfigAllOfLogConfig where
  parseJSON = A.withObject "HostConfigAllOfLogConfig" $ \o ->
    HostConfigAllOfLogConfig
      <$> (o .:? "Type")
      <*> (o .:? "Config")

-- | ToJSON HostConfigAllOfLogConfig
instance A.ToJSON HostConfigAllOfLogConfig where
  toJSON HostConfigAllOfLogConfig {..} =
   _omitNulls
      [ "Type" .= hostConfigAllOfLogConfigType
      , "Config" .= hostConfigAllOfLogConfigConfig
      ]


-- | Construct a value of type 'HostConfigAllOfLogConfig' (by applying it's required fields, if any)
mkHostConfigAllOfLogConfig
  :: HostConfigAllOfLogConfig
mkHostConfigAllOfLogConfig =
  HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType = Nothing
  , hostConfigAllOfLogConfigConfig = Nothing
  }

-- ** IPAM
-- | IPAM
data IPAM = IPAM
  { iPAMDriver :: !(Maybe Text) -- ^ "Driver" - Name of the IPAM driver to use.
  , iPAMConfig :: !(Maybe [(Map.Map String Text)]) -- ^ "Config" - List of IPAM configuration options, specified as a map: &#x60;{\&quot;Subnet\&quot;: &lt;CIDR&gt;, \&quot;IPRange\&quot;: &lt;CIDR&gt;, \&quot;Gateway\&quot;: &lt;IP address&gt;, \&quot;AuxAddress\&quot;: &lt;device_name:IP address&gt;}&#x60;
  , iPAMOptions :: !(Maybe [(Map.Map String Text)]) -- ^ "Options" - Driver-specific options, specified as a map.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IPAM
instance A.FromJSON IPAM where
  parseJSON = A.withObject "IPAM" $ \o ->
    IPAM
      <$> (o .:? "Driver")
      <*> (o .:? "Config")
      <*> (o .:? "Options")

-- | ToJSON IPAM
instance A.ToJSON IPAM where
  toJSON IPAM {..} =
   _omitNulls
      [ "Driver" .= iPAMDriver
      , "Config" .= iPAMConfig
      , "Options" .= iPAMOptions
      ]


-- | Construct a value of type 'IPAM' (by applying it's required fields, if any)
mkIPAM
  :: IPAM
mkIPAM =
  IPAM
  { iPAMDriver = Nothing
  , iPAMConfig = Nothing
  , iPAMOptions = Nothing
  }

-- ** IdResponse
-- | IdResponse
-- Response to an API call that returns just an Id
data IdResponse = IdResponse
  { idResponseId :: !(Text) -- ^ /Required/ "Id" - The id of the newly created object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdResponse
instance A.FromJSON IdResponse where
  parseJSON = A.withObject "IdResponse" $ \o ->
    IdResponse
      <$> (o .:  "Id")

-- | ToJSON IdResponse
instance A.ToJSON IdResponse where
  toJSON IdResponse {..} =
   _omitNulls
      [ "Id" .= idResponseId
      ]


-- | Construct a value of type 'IdResponse' (by applying it's required fields, if any)
mkIdResponse
  :: Text -- ^ 'idResponseId': The id of the newly created object.
  -> IdResponse
mkIdResponse idResponseId =
  IdResponse
  { idResponseId
  }

-- ** Image
-- | Image
data Image = Image
  { imageId :: !(Text) -- ^ /Required/ "Id"
  , imageRepoTags :: !(Maybe [Text]) -- ^ "RepoTags"
  , imageRepoDigests :: !(Maybe [Text]) -- ^ "RepoDigests"
  , imageParent :: !(Text) -- ^ /Required/ "Parent"
  , imageComment :: !(Text) -- ^ /Required/ "Comment"
  , imageCreated :: !(Text) -- ^ /Required/ "Created"
  , imageContainer :: !(Text) -- ^ /Required/ "Container"
  , imageContainerConfig :: !(Maybe ContainerConfig) -- ^ "ContainerConfig"
  , imageDockerVersion :: !(Text) -- ^ /Required/ "DockerVersion"
  , imageAuthor :: !(Text) -- ^ /Required/ "Author"
  , imageConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , imageArchitecture :: !(Text) -- ^ /Required/ "Architecture"
  , imageOs :: !(Text) -- ^ /Required/ "Os"
  , imageOsVersion :: !(Maybe Text) -- ^ "OsVersion"
  , imageSize :: !(Integer) -- ^ /Required/ "Size"
  , imageVirtualSize :: !(Integer) -- ^ /Required/ "VirtualSize"
  , imageGraphDriver :: !(GraphDriverData) -- ^ /Required/ "GraphDriver"
  , imageRootFs :: !(ImageRootFS) -- ^ /Required/ "RootFS"
  , imageMetadata :: !(Maybe ImageMetadata) -- ^ "Metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Image
instance A.FromJSON Image where
  parseJSON = A.withObject "Image" $ \o ->
    Image
      <$> (o .:  "Id")
      <*> (o .:? "RepoTags")
      <*> (o .:? "RepoDigests")
      <*> (o .:  "Parent")
      <*> (o .:  "Comment")
      <*> (o .:  "Created")
      <*> (o .:  "Container")
      <*> (o .:? "ContainerConfig")
      <*> (o .:  "DockerVersion")
      <*> (o .:  "Author")
      <*> (o .:? "Config")
      <*> (o .:  "Architecture")
      <*> (o .:  "Os")
      <*> (o .:? "OsVersion")
      <*> (o .:  "Size")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "GraphDriver")
      <*> (o .:  "RootFS")
      <*> (o .:? "Metadata")

-- | ToJSON Image
instance A.ToJSON Image where
  toJSON Image {..} =
   _omitNulls
      [ "Id" .= imageId
      , "RepoTags" .= imageRepoTags
      , "RepoDigests" .= imageRepoDigests
      , "Parent" .= imageParent
      , "Comment" .= imageComment
      , "Created" .= imageCreated
      , "Container" .= imageContainer
      , "ContainerConfig" .= imageContainerConfig
      , "DockerVersion" .= imageDockerVersion
      , "Author" .= imageAuthor
      , "Config" .= imageConfig
      , "Architecture" .= imageArchitecture
      , "Os" .= imageOs
      , "OsVersion" .= imageOsVersion
      , "Size" .= imageSize
      , "VirtualSize" .= imageVirtualSize
      , "GraphDriver" .= imageGraphDriver
      , "RootFS" .= imageRootFs
      , "Metadata" .= imageMetadata
      ]


-- | Construct a value of type 'Image' (by applying it's required fields, if any)
mkImage
  :: Text -- ^ 'imageId' 
  -> Text -- ^ 'imageParent' 
  -> Text -- ^ 'imageComment' 
  -> Text -- ^ 'imageCreated' 
  -> Text -- ^ 'imageContainer' 
  -> Text -- ^ 'imageDockerVersion' 
  -> Text -- ^ 'imageAuthor' 
  -> Text -- ^ 'imageArchitecture' 
  -> Text -- ^ 'imageOs' 
  -> Integer -- ^ 'imageSize' 
  -> Integer -- ^ 'imageVirtualSize' 
  -> GraphDriverData -- ^ 'imageGraphDriver' 
  -> ImageRootFS -- ^ 'imageRootFs' 
  -> Image
mkImage imageId imageParent imageComment imageCreated imageContainer imageDockerVersion imageAuthor imageArchitecture imageOs imageSize imageVirtualSize imageGraphDriver imageRootFs =
  Image
  { imageId
  , imageRepoTags = Nothing
  , imageRepoDigests = Nothing
  , imageParent
  , imageComment
  , imageCreated
  , imageContainer
  , imageContainerConfig = Nothing
  , imageDockerVersion
  , imageAuthor
  , imageConfig = Nothing
  , imageArchitecture
  , imageOs
  , imageOsVersion = Nothing
  , imageSize
  , imageVirtualSize
  , imageGraphDriver
  , imageRootFs
  , imageMetadata = Nothing
  }

-- ** ImageDeleteResponseItem
-- | ImageDeleteResponseItem
data ImageDeleteResponseItem = ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged :: !(Maybe Text) -- ^ "Untagged" - The image ID of an image that was untagged
  , imageDeleteResponseItemDeleted :: !(Maybe Text) -- ^ "Deleted" - The image ID of an image that was deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageDeleteResponseItem
instance A.FromJSON ImageDeleteResponseItem where
  parseJSON = A.withObject "ImageDeleteResponseItem" $ \o ->
    ImageDeleteResponseItem
      <$> (o .:? "Untagged")
      <*> (o .:? "Deleted")

-- | ToJSON ImageDeleteResponseItem
instance A.ToJSON ImageDeleteResponseItem where
  toJSON ImageDeleteResponseItem {..} =
   _omitNulls
      [ "Untagged" .= imageDeleteResponseItemUntagged
      , "Deleted" .= imageDeleteResponseItemDeleted
      ]


-- | Construct a value of type 'ImageDeleteResponseItem' (by applying it's required fields, if any)
mkImageDeleteResponseItem
  :: ImageDeleteResponseItem
mkImageDeleteResponseItem =
  ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged = Nothing
  , imageDeleteResponseItemDeleted = Nothing
  }

-- ** ImageID
-- | ImageID
-- Image ID or Digest
data ImageID = ImageID
  { imageIDId :: !(Maybe Text) -- ^ "ID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageID
instance A.FromJSON ImageID where
  parseJSON = A.withObject "ImageID" $ \o ->
    ImageID
      <$> (o .:? "ID")

-- | ToJSON ImageID
instance A.ToJSON ImageID where
  toJSON ImageID {..} =
   _omitNulls
      [ "ID" .= imageIDId
      ]


-- | Construct a value of type 'ImageID' (by applying it's required fields, if any)
mkImageID
  :: ImageID
mkImageID =
  ImageID
  { imageIDId = Nothing
  }

-- ** ImageMetadata
-- | ImageMetadata
data ImageMetadata = ImageMetadata
  { imageMetadataLastTagTime :: !(Maybe Text) -- ^ "LastTagTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageMetadata
instance A.FromJSON ImageMetadata where
  parseJSON = A.withObject "ImageMetadata" $ \o ->
    ImageMetadata
      <$> (o .:? "LastTagTime")

-- | ToJSON ImageMetadata
instance A.ToJSON ImageMetadata where
  toJSON ImageMetadata {..} =
   _omitNulls
      [ "LastTagTime" .= imageMetadataLastTagTime
      ]


-- | Construct a value of type 'ImageMetadata' (by applying it's required fields, if any)
mkImageMetadata
  :: ImageMetadata
mkImageMetadata =
  ImageMetadata
  { imageMetadataLastTagTime = Nothing
  }

-- ** ImagePruneResponse
-- | ImagePruneResponse
-- ImagePruneResponse
-- 
data ImagePruneResponse = ImagePruneResponse
  { imagePruneResponseImagesDeleted :: !(Maybe [ImageDeleteResponseItem]) -- ^ "ImagesDeleted" - Images that were deleted
  , imagePruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImagePruneResponse
instance A.FromJSON ImagePruneResponse where
  parseJSON = A.withObject "ImagePruneResponse" $ \o ->
    ImagePruneResponse
      <$> (o .:? "ImagesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON ImagePruneResponse
instance A.ToJSON ImagePruneResponse where
  toJSON ImagePruneResponse {..} =
   _omitNulls
      [ "ImagesDeleted" .= imagePruneResponseImagesDeleted
      , "SpaceReclaimed" .= imagePruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'ImagePruneResponse' (by applying it's required fields, if any)
mkImagePruneResponse
  :: ImagePruneResponse
mkImagePruneResponse =
  ImagePruneResponse
  { imagePruneResponseImagesDeleted = Nothing
  , imagePruneResponseSpaceReclaimed = Nothing
  }

-- ** ImageRootFS
-- | ImageRootFS
data ImageRootFS = ImageRootFS
  { imageRootFSType :: !(Text) -- ^ /Required/ "Type"
  , imageRootFSLayers :: !(Maybe [Text]) -- ^ "Layers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageRootFS
instance A.FromJSON ImageRootFS where
  parseJSON = A.withObject "ImageRootFS" $ \o ->
    ImageRootFS
      <$> (o .:  "Type")
      <*> (o .:? "Layers")

-- | ToJSON ImageRootFS
instance A.ToJSON ImageRootFS where
  toJSON ImageRootFS {..} =
   _omitNulls
      [ "Type" .= imageRootFSType
      , "Layers" .= imageRootFSLayers
      ]


-- | Construct a value of type 'ImageRootFS' (by applying it's required fields, if any)
mkImageRootFS
  :: Text -- ^ 'imageRootFSType' 
  -> ImageRootFS
mkImageRootFS imageRootFSType =
  ImageRootFS
  { imageRootFSType
  , imageRootFSLayers = Nothing
  }

-- ** ImageSearchResponseItem
-- | ImageSearchResponseItem
-- ImageSearchResponseItem
-- 
data ImageSearchResponseItem = ImageSearchResponseItem
  { imageSearchResponseItemDescription :: !(Maybe Text) -- ^ "description"
  , imageSearchResponseItemIsOfficial :: !(Maybe Bool) -- ^ "is_official"
  , imageSearchResponseItemIsAutomated :: !(Maybe Bool) -- ^ "is_automated"
  , imageSearchResponseItemName :: !(Maybe Text) -- ^ "name"
  , imageSearchResponseItemStarCount :: !(Maybe Int) -- ^ "star_count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSearchResponseItem
instance A.FromJSON ImageSearchResponseItem where
  parseJSON = A.withObject "ImageSearchResponseItem" $ \o ->
    ImageSearchResponseItem
      <$> (o .:? "description")
      <*> (o .:? "is_official")
      <*> (o .:? "is_automated")
      <*> (o .:? "name")
      <*> (o .:? "star_count")

-- | ToJSON ImageSearchResponseItem
instance A.ToJSON ImageSearchResponseItem where
  toJSON ImageSearchResponseItem {..} =
   _omitNulls
      [ "description" .= imageSearchResponseItemDescription
      , "is_official" .= imageSearchResponseItemIsOfficial
      , "is_automated" .= imageSearchResponseItemIsAutomated
      , "name" .= imageSearchResponseItemName
      , "star_count" .= imageSearchResponseItemStarCount
      ]


-- | Construct a value of type 'ImageSearchResponseItem' (by applying it's required fields, if any)
mkImageSearchResponseItem
  :: ImageSearchResponseItem
mkImageSearchResponseItem =
  ImageSearchResponseItem
  { imageSearchResponseItemDescription = Nothing
  , imageSearchResponseItemIsOfficial = Nothing
  , imageSearchResponseItemIsAutomated = Nothing
  , imageSearchResponseItemName = Nothing
  , imageSearchResponseItemStarCount = Nothing
  }

-- ** ImageSummary
-- | ImageSummary
data ImageSummary = ImageSummary
  { imageSummaryId :: !(Text) -- ^ /Required/ "Id"
  , imageSummaryParentId :: !(Text) -- ^ /Required/ "ParentId"
  , imageSummaryRepoTags :: !([Text]) -- ^ /Required/ "RepoTags"
  , imageSummaryRepoDigests :: !([Text]) -- ^ /Required/ "RepoDigests"
  , imageSummaryCreated :: !(Int) -- ^ /Required/ "Created"
  , imageSummarySize :: !(Int) -- ^ /Required/ "Size"
  , imageSummarySharedSize :: !(Int) -- ^ /Required/ "SharedSize"
  , imageSummaryVirtualSize :: !(Int) -- ^ /Required/ "VirtualSize"
  , imageSummaryLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels"
  , imageSummaryContainers :: !(Int) -- ^ /Required/ "Containers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSummary
instance A.FromJSON ImageSummary where
  parseJSON = A.withObject "ImageSummary" $ \o ->
    ImageSummary
      <$> (o .:  "Id")
      <*> (o .:  "ParentId")
      <*> (o .:  "RepoTags")
      <*> (o .:  "RepoDigests")
      <*> (o .:  "Created")
      <*> (o .:  "Size")
      <*> (o .:  "SharedSize")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "Labels")
      <*> (o .:  "Containers")

-- | ToJSON ImageSummary
instance A.ToJSON ImageSummary where
  toJSON ImageSummary {..} =
   _omitNulls
      [ "Id" .= imageSummaryId
      , "ParentId" .= imageSummaryParentId
      , "RepoTags" .= imageSummaryRepoTags
      , "RepoDigests" .= imageSummaryRepoDigests
      , "Created" .= imageSummaryCreated
      , "Size" .= imageSummarySize
      , "SharedSize" .= imageSummarySharedSize
      , "VirtualSize" .= imageSummaryVirtualSize
      , "Labels" .= imageSummaryLabels
      , "Containers" .= imageSummaryContainers
      ]


-- | Construct a value of type 'ImageSummary' (by applying it's required fields, if any)
mkImageSummary
  :: Text -- ^ 'imageSummaryId' 
  -> Text -- ^ 'imageSummaryParentId' 
  -> [Text] -- ^ 'imageSummaryRepoTags' 
  -> [Text] -- ^ 'imageSummaryRepoDigests' 
  -> Int -- ^ 'imageSummaryCreated' 
  -> Int -- ^ 'imageSummarySize' 
  -> Int -- ^ 'imageSummarySharedSize' 
  -> Int -- ^ 'imageSummaryVirtualSize' 
  -> (Map.Map String Text) -- ^ 'imageSummaryLabels' 
  -> Int -- ^ 'imageSummaryContainers' 
  -> ImageSummary
mkImageSummary imageSummaryId imageSummaryParentId imageSummaryRepoTags imageSummaryRepoDigests imageSummaryCreated imageSummarySize imageSummarySharedSize imageSummaryVirtualSize imageSummaryLabels imageSummaryContainers =
  ImageSummary
  { imageSummaryId
  , imageSummaryParentId
  , imageSummaryRepoTags
  , imageSummaryRepoDigests
  , imageSummaryCreated
  , imageSummarySize
  , imageSummarySharedSize
  , imageSummaryVirtualSize
  , imageSummaryLabels
  , imageSummaryContainers
  }

-- ** IndexInfo
-- | IndexInfo
-- IndexInfo contains information about a registry.
data IndexInfo = IndexInfo
  { indexInfoName :: !(Maybe Text) -- ^ "Name" - Name of the registry, such as \&quot;docker.io\&quot;. 
  , indexInfoMirrors :: !(Maybe [Text]) -- ^ "Mirrors" - List of mirrors, expressed as URIs. 
  , indexInfoSecure :: !(Maybe Bool) -- ^ "Secure" - Indicates if the registry is part of the list of insecure registries.  If &#x60;false&#x60;, the registry is insecure. Insecure registries accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from unknown CAs) communication.  &gt; **Warning**: Insecure registries can be useful when running a local &gt; registry. However, because its use creates security vulnerabilities &gt; it should ONLY be enabled for testing purposes. For increased &gt; security, users should add their CA to their system&#39;s list of &gt; trusted CAs instead of enabling this option. 
  , indexInfoOfficial :: !(Maybe Bool) -- ^ "Official" - Indicates whether this is an official registry (i.e., Docker Hub / docker.io) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexInfo
instance A.FromJSON IndexInfo where
  parseJSON = A.withObject "IndexInfo" $ \o ->
    IndexInfo
      <$> (o .:? "Name")
      <*> (o .:? "Mirrors")
      <*> (o .:? "Secure")
      <*> (o .:? "Official")

-- | ToJSON IndexInfo
instance A.ToJSON IndexInfo where
  toJSON IndexInfo {..} =
   _omitNulls
      [ "Name" .= indexInfoName
      , "Mirrors" .= indexInfoMirrors
      , "Secure" .= indexInfoSecure
      , "Official" .= indexInfoOfficial
      ]


-- | Construct a value of type 'IndexInfo' (by applying it's required fields, if any)
mkIndexInfo
  :: IndexInfo
mkIndexInfo =
  IndexInfo
  { indexInfoName = Nothing
  , indexInfoMirrors = Nothing
  , indexInfoSecure = Nothing
  , indexInfoOfficial = Nothing
  }

-- ** JoinTokens
-- | JoinTokens
-- JoinTokens contains the tokens workers and managers need to join the swarm. 
data JoinTokens = JoinTokens
  { joinTokensWorker :: !(Maybe Text) -- ^ "Worker" - The token workers can use to join the swarm. 
  , joinTokensManager :: !(Maybe Text) -- ^ "Manager" - The token managers can use to join the swarm. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JoinTokens
instance A.FromJSON JoinTokens where
  parseJSON = A.withObject "JoinTokens" $ \o ->
    JoinTokens
      <$> (o .:? "Worker")
      <*> (o .:? "Manager")

-- | ToJSON JoinTokens
instance A.ToJSON JoinTokens where
  toJSON JoinTokens {..} =
   _omitNulls
      [ "Worker" .= joinTokensWorker
      , "Manager" .= joinTokensManager
      ]


-- | Construct a value of type 'JoinTokens' (by applying it's required fields, if any)
mkJoinTokens
  :: JoinTokens
mkJoinTokens =
  JoinTokens
  { joinTokensWorker = Nothing
  , joinTokensManager = Nothing
  }

-- ** ManagerStatus
-- | ManagerStatus
-- ManagerStatus represents the status of a manager.  It provides the current status of a node's manager component, if the node is a manager. 
data ManagerStatus = ManagerStatus
  { managerStatusLeader :: !(Maybe Bool) -- ^ "Leader"
  , managerStatusReachability :: !(Maybe Reachability) -- ^ "Reachability"
  , managerStatusAddr :: !(Maybe Text) -- ^ "Addr" - The IP address and port at which the manager is reachable. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ManagerStatus
instance A.FromJSON ManagerStatus where
  parseJSON = A.withObject "ManagerStatus" $ \o ->
    ManagerStatus
      <$> (o .:? "Leader")
      <*> (o .:? "Reachability")
      <*> (o .:? "Addr")

-- | ToJSON ManagerStatus
instance A.ToJSON ManagerStatus where
  toJSON ManagerStatus {..} =
   _omitNulls
      [ "Leader" .= managerStatusLeader
      , "Reachability" .= managerStatusReachability
      , "Addr" .= managerStatusAddr
      ]


-- | Construct a value of type 'ManagerStatus' (by applying it's required fields, if any)
mkManagerStatus
  :: ManagerStatus
mkManagerStatus =
  ManagerStatus
  { managerStatusLeader = Nothing
  , managerStatusReachability = Nothing
  , managerStatusAddr = Nothing
  }

-- ** Mount
-- | Mount
data Mount = Mount
  { mountTarget :: !(Maybe Text) -- ^ "Target" - Container path.
  , mountSource :: !(Maybe Text) -- ^ "Source" - Mount source (e.g. a volume name, a host path).
  , mountType :: !(Maybe E'Type3) -- ^ "Type" - The mount type. Available types:  - &#x60;bind&#x60; Mounts a file or directory from the host into the container. Must exist prior to creating the container. - &#x60;volume&#x60; Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - &#x60;tmpfs&#x60; Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
  , mountReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Whether the mount should be read-only.
  , mountConsistency :: !(Maybe Text) -- ^ "Consistency" - The consistency requirement for the mount: &#x60;default&#x60;, &#x60;consistent&#x60;, &#x60;cached&#x60;, or &#x60;delegated&#x60;.
  , mountBindOptions :: !(Maybe MountBindOptions) -- ^ "BindOptions"
  , mountVolumeOptions :: !(Maybe MountVolumeOptions) -- ^ "VolumeOptions"
  , mountTmpfsOptions :: !(Maybe MountTmpfsOptions) -- ^ "TmpfsOptions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mount
instance A.FromJSON Mount where
  parseJSON = A.withObject "Mount" $ \o ->
    Mount
      <$> (o .:? "Target")
      <*> (o .:? "Source")
      <*> (o .:? "Type")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Consistency")
      <*> (o .:? "BindOptions")
      <*> (o .:? "VolumeOptions")
      <*> (o .:? "TmpfsOptions")

-- | ToJSON Mount
instance A.ToJSON Mount where
  toJSON Mount {..} =
   _omitNulls
      [ "Target" .= mountTarget
      , "Source" .= mountSource
      , "Type" .= mountType
      , "ReadOnly" .= mountReadOnly
      , "Consistency" .= mountConsistency
      , "BindOptions" .= mountBindOptions
      , "VolumeOptions" .= mountVolumeOptions
      , "TmpfsOptions" .= mountTmpfsOptions
      ]


-- | Construct a value of type 'Mount' (by applying it's required fields, if any)
mkMount
  :: Mount
mkMount =
  Mount
  { mountTarget = Nothing
  , mountSource = Nothing
  , mountType = Nothing
  , mountReadOnly = Nothing
  , mountConsistency = Nothing
  , mountBindOptions = Nothing
  , mountVolumeOptions = Nothing
  , mountTmpfsOptions = Nothing
  }

-- ** MountBindOptions
-- | MountBindOptions
-- Optional configuration for the `bind` type.
data MountBindOptions = MountBindOptions
  { mountBindOptionsPropagation :: !(Maybe E'Propagation) -- ^ "Propagation" - A propagation mode with the value &#x60;[r]private&#x60;, &#x60;[r]shared&#x60;, or &#x60;[r]slave&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountBindOptions
instance A.FromJSON MountBindOptions where
  parseJSON = A.withObject "MountBindOptions" $ \o ->
    MountBindOptions
      <$> (o .:? "Propagation")

-- | ToJSON MountBindOptions
instance A.ToJSON MountBindOptions where
  toJSON MountBindOptions {..} =
   _omitNulls
      [ "Propagation" .= mountBindOptionsPropagation
      ]


-- | Construct a value of type 'MountBindOptions' (by applying it's required fields, if any)
mkMountBindOptions
  :: MountBindOptions
mkMountBindOptions =
  MountBindOptions
  { mountBindOptionsPropagation = Nothing
  }

-- ** MountPoint
-- | MountPoint
-- MountPoint represents a mount point configuration inside the container. This is used for reporting the mountpoints in use by a container. 
data MountPoint = MountPoint
  { mountPointType :: !(Maybe E'Type2) -- ^ "Type" - The mount type:  - &#x60;bind&#x60; a mount of a file or directory from the host into the container. - &#x60;volume&#x60; a docker volume with the given &#x60;Name&#x60;. - &#x60;tmpfs&#x60; a &#x60;tmpfs&#x60;. - &#x60;npipe&#x60; a named pipe from the host into the container. 
  , mountPointName :: !(Maybe Text) -- ^ "Name" - Name is the name reference to the underlying data defined by &#x60;Source&#x60; e.g., the volume name. 
  , mountPointSource :: !(Maybe Text) -- ^ "Source" - Source location of the mount.  For volumes, this contains the storage location of the volume (within &#x60;/var/lib/docker/volumes/&#x60;). For bind-mounts, and &#x60;npipe&#x60;, this contains the source (host) part of the bind-mount. For &#x60;tmpfs&#x60; mount points, this field is empty. 
  , mountPointDestination :: !(Maybe Text) -- ^ "Destination" - Destination is the path relative to the container root (&#x60;/&#x60;) where the &#x60;Source&#x60; is mounted inside the container. 
  , mountPointDriver :: !(Maybe Text) -- ^ "Driver" - Driver is the volume driver used to create the volume (if it is a volume). 
  , mountPointMode :: !(Maybe Text) -- ^ "Mode" - Mode is a comma separated list of options supplied by the user when creating the bind/volume mount.  The default is platform-specific (&#x60;\&quot;z\&quot;&#x60; on Linux, empty on Windows). 
  , mountPointRw :: !(Maybe Bool) -- ^ "RW" - Whether the mount is mounted writable (read-write). 
  , mountPointPropagation :: !(Maybe Text) -- ^ "Propagation" - Propagation describes how mounts are propagated from the host into the mount point, and vice-versa. Refer to the [Linux kernel documentation](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) for details. This field is not used on Windows. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountPoint
instance A.FromJSON MountPoint where
  parseJSON = A.withObject "MountPoint" $ \o ->
    MountPoint
      <$> (o .:? "Type")
      <*> (o .:? "Name")
      <*> (o .:? "Source")
      <*> (o .:? "Destination")
      <*> (o .:? "Driver")
      <*> (o .:? "Mode")
      <*> (o .:? "RW")
      <*> (o .:? "Propagation")

-- | ToJSON MountPoint
instance A.ToJSON MountPoint where
  toJSON MountPoint {..} =
   _omitNulls
      [ "Type" .= mountPointType
      , "Name" .= mountPointName
      , "Source" .= mountPointSource
      , "Destination" .= mountPointDestination
      , "Driver" .= mountPointDriver
      , "Mode" .= mountPointMode
      , "RW" .= mountPointRw
      , "Propagation" .= mountPointPropagation
      ]


-- | Construct a value of type 'MountPoint' (by applying it's required fields, if any)
mkMountPoint
  :: MountPoint
mkMountPoint =
  MountPoint
  { mountPointType = Nothing
  , mountPointName = Nothing
  , mountPointSource = Nothing
  , mountPointDestination = Nothing
  , mountPointDriver = Nothing
  , mountPointMode = Nothing
  , mountPointRw = Nothing
  , mountPointPropagation = Nothing
  }

-- ** MountTmpfsOptions
-- | MountTmpfsOptions
-- Optional configuration for the `tmpfs` type.
data MountTmpfsOptions = MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes :: !(Maybe Integer) -- ^ "SizeBytes" - The size for the tmpfs mount in bytes.
  , mountTmpfsOptionsMode :: !(Maybe Int) -- ^ "Mode" - The permission mode for the tmpfs mount in an integer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountTmpfsOptions
instance A.FromJSON MountTmpfsOptions where
  parseJSON = A.withObject "MountTmpfsOptions" $ \o ->
    MountTmpfsOptions
      <$> (o .:? "SizeBytes")
      <*> (o .:? "Mode")

-- | ToJSON MountTmpfsOptions
instance A.ToJSON MountTmpfsOptions where
  toJSON MountTmpfsOptions {..} =
   _omitNulls
      [ "SizeBytes" .= mountTmpfsOptionsSizeBytes
      , "Mode" .= mountTmpfsOptionsMode
      ]


-- | Construct a value of type 'MountTmpfsOptions' (by applying it's required fields, if any)
mkMountTmpfsOptions
  :: MountTmpfsOptions
mkMountTmpfsOptions =
  MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes = Nothing
  , mountTmpfsOptionsMode = Nothing
  }

-- ** MountVolumeOptions
-- | MountVolumeOptions
-- Optional configuration for the `volume` type.
data MountVolumeOptions = MountVolumeOptions
  { mountVolumeOptionsNoCopy :: !(Maybe Bool) -- ^ "NoCopy" - Populate volume with data from the target.
  , mountVolumeOptionsLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , mountVolumeOptionsDriverConfig :: !(Maybe MountVolumeOptionsDriverConfig) -- ^ "DriverConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptions
instance A.FromJSON MountVolumeOptions where
  parseJSON = A.withObject "MountVolumeOptions" $ \o ->
    MountVolumeOptions
      <$> (o .:? "NoCopy")
      <*> (o .:? "Labels")
      <*> (o .:? "DriverConfig")

-- | ToJSON MountVolumeOptions
instance A.ToJSON MountVolumeOptions where
  toJSON MountVolumeOptions {..} =
   _omitNulls
      [ "NoCopy" .= mountVolumeOptionsNoCopy
      , "Labels" .= mountVolumeOptionsLabels
      , "DriverConfig" .= mountVolumeOptionsDriverConfig
      ]


-- | Construct a value of type 'MountVolumeOptions' (by applying it's required fields, if any)
mkMountVolumeOptions
  :: MountVolumeOptions
mkMountVolumeOptions =
  MountVolumeOptions
  { mountVolumeOptionsNoCopy = Nothing
  , mountVolumeOptionsLabels = Nothing
  , mountVolumeOptionsDriverConfig = Nothing
  }

-- ** MountVolumeOptionsDriverConfig
-- | MountVolumeOptionsDriverConfig
-- Map of driver specific options
data MountVolumeOptionsDriverConfig = MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName :: !(Maybe Text) -- ^ "Name" - Name of the driver to use to create the volume.
  , mountVolumeOptionsDriverConfigOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - key/value map of driver specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptionsDriverConfig
instance A.FromJSON MountVolumeOptionsDriverConfig where
  parseJSON = A.withObject "MountVolumeOptionsDriverConfig" $ \o ->
    MountVolumeOptionsDriverConfig
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON MountVolumeOptionsDriverConfig
instance A.ToJSON MountVolumeOptionsDriverConfig where
  toJSON MountVolumeOptionsDriverConfig {..} =
   _omitNulls
      [ "Name" .= mountVolumeOptionsDriverConfigName
      , "Options" .= mountVolumeOptionsDriverConfigOptions
      ]


-- | Construct a value of type 'MountVolumeOptionsDriverConfig' (by applying it's required fields, if any)
mkMountVolumeOptionsDriverConfig
  :: MountVolumeOptionsDriverConfig
mkMountVolumeOptionsDriverConfig =
  MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName = Nothing
  , mountVolumeOptionsDriverConfigOptions = Nothing
  }

-- ** Network
-- | Network
data Network = Network
  { networkName :: !(Maybe Text) -- ^ "Name"
  , networkId :: !(Maybe Text) -- ^ "Id"
  , networkCreated :: !(Maybe Text) -- ^ "Created"
  , networkScope :: !(Maybe Text) -- ^ "Scope"
  , networkDriver :: !(Maybe Text) -- ^ "Driver"
  , networkEnableIpv6 :: !(Maybe Bool) -- ^ "EnableIPv6"
  , networkIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkInternal :: !(Maybe Bool) -- ^ "Internal"
  , networkAttachable :: !(Maybe Bool) -- ^ "Attachable"
  , networkIngress :: !(Maybe Bool) -- ^ "Ingress"
  , networkContainers :: !(Maybe (Map.Map String NetworkContainer)) -- ^ "Containers"
  , networkOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  , networkLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Network
instance A.FromJSON Network where
  parseJSON = A.withObject "Network" $ \o ->
    Network
      <$> (o .:? "Name")
      <*> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Scope")
      <*> (o .:? "Driver")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "IPAM")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "Containers")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON Network
instance A.ToJSON Network where
  toJSON Network {..} =
   _omitNulls
      [ "Name" .= networkName
      , "Id" .= networkId
      , "Created" .= networkCreated
      , "Scope" .= networkScope
      , "Driver" .= networkDriver
      , "EnableIPv6" .= networkEnableIpv6
      , "IPAM" .= networkIpam
      , "Internal" .= networkInternal
      , "Attachable" .= networkAttachable
      , "Ingress" .= networkIngress
      , "Containers" .= networkContainers
      , "Options" .= networkOptions
      , "Labels" .= networkLabels
      ]


-- | Construct a value of type 'Network' (by applying it's required fields, if any)
mkNetwork
  :: Network
mkNetwork =
  Network
  { networkName = Nothing
  , networkId = Nothing
  , networkCreated = Nothing
  , networkScope = Nothing
  , networkDriver = Nothing
  , networkEnableIpv6 = Nothing
  , networkIpam = Nothing
  , networkInternal = Nothing
  , networkAttachable = Nothing
  , networkIngress = Nothing
  , networkContainers = Nothing
  , networkOptions = Nothing
  , networkLabels = Nothing
  }

-- ** NetworkConnectRequest
-- | NetworkConnectRequest
data NetworkConnectRequest = NetworkConnectRequest
  { networkConnectRequestContainer :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to connect to the network.
  , networkConnectRequestEndpointConfig :: !(Maybe EndpointSettings) -- ^ "EndpointConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkConnectRequest
instance A.FromJSON NetworkConnectRequest where
  parseJSON = A.withObject "NetworkConnectRequest" $ \o ->
    NetworkConnectRequest
      <$> (o .:? "Container")
      <*> (o .:? "EndpointConfig")

-- | ToJSON NetworkConnectRequest
instance A.ToJSON NetworkConnectRequest where
  toJSON NetworkConnectRequest {..} =
   _omitNulls
      [ "Container" .= networkConnectRequestContainer
      , "EndpointConfig" .= networkConnectRequestEndpointConfig
      ]


-- | Construct a value of type 'NetworkConnectRequest' (by applying it's required fields, if any)
mkNetworkConnectRequest
  :: NetworkConnectRequest
mkNetworkConnectRequest =
  NetworkConnectRequest
  { networkConnectRequestContainer = Nothing
  , networkConnectRequestEndpointConfig = Nothing
  }

-- ** NetworkContainer
-- | NetworkContainer
data NetworkContainer = NetworkContainer
  { networkContainerName :: !(Maybe Text) -- ^ "Name"
  , networkContainerEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , networkContainerMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  , networkContainerIpv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , networkContainerIpv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkContainer
instance A.FromJSON NetworkContainer where
  parseJSON = A.withObject "NetworkContainer" $ \o ->
    NetworkContainer
      <$> (o .:? "Name")
      <*> (o .:? "EndpointID")
      <*> (o .:? "MacAddress")
      <*> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")

-- | ToJSON NetworkContainer
instance A.ToJSON NetworkContainer where
  toJSON NetworkContainer {..} =
   _omitNulls
      [ "Name" .= networkContainerName
      , "EndpointID" .= networkContainerEndpointId
      , "MacAddress" .= networkContainerMacAddress
      , "IPv4Address" .= networkContainerIpv4Address
      , "IPv6Address" .= networkContainerIpv6Address
      ]


-- | Construct a value of type 'NetworkContainer' (by applying it's required fields, if any)
mkNetworkContainer
  :: NetworkContainer
mkNetworkContainer =
  NetworkContainer
  { networkContainerName = Nothing
  , networkContainerEndpointId = Nothing
  , networkContainerMacAddress = Nothing
  , networkContainerIpv4Address = Nothing
  , networkContainerIpv6Address = Nothing
  }

-- ** NetworkCreateRequest
-- | NetworkCreateRequest
data NetworkCreateRequest = NetworkCreateRequest
  { networkCreateRequestName :: !(Text) -- ^ /Required/ "Name" - The network&#39;s name.
  , networkCreateRequestCheckDuplicate :: !(Maybe Bool) -- ^ "CheckDuplicate" - Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions.
  , networkCreateRequestDriver :: !(Maybe Text) -- ^ "Driver" - Name of the network driver plugin to use.
  , networkCreateRequestInternal :: !(Maybe Bool) -- ^ "Internal" - Restrict external access to the network.
  , networkCreateRequestAttachable :: !(Maybe Bool) -- ^ "Attachable" - Globally scoped network is manually attachable by regular containers from workers in swarm mode.
  , networkCreateRequestIngress :: !(Maybe Bool) -- ^ "Ingress" - Ingress network is the network which provides the routing-mesh in swarm mode.
  , networkCreateRequestIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkCreateRequestEnableIpv6 :: !(Maybe Bool) -- ^ "EnableIPv6" - Enable IPv6 on the network.
  , networkCreateRequestOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Network specific options to be used by the drivers.
  , networkCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkCreateRequest
instance A.FromJSON NetworkCreateRequest where
  parseJSON = A.withObject "NetworkCreateRequest" $ \o ->
    NetworkCreateRequest
      <$> (o .:  "Name")
      <*> (o .:? "CheckDuplicate")
      <*> (o .:? "Driver")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "IPAM")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON NetworkCreateRequest
instance A.ToJSON NetworkCreateRequest where
  toJSON NetworkCreateRequest {..} =
   _omitNulls
      [ "Name" .= networkCreateRequestName
      , "CheckDuplicate" .= networkCreateRequestCheckDuplicate
      , "Driver" .= networkCreateRequestDriver
      , "Internal" .= networkCreateRequestInternal
      , "Attachable" .= networkCreateRequestAttachable
      , "Ingress" .= networkCreateRequestIngress
      , "IPAM" .= networkCreateRequestIpam
      , "EnableIPv6" .= networkCreateRequestEnableIpv6
      , "Options" .= networkCreateRequestOptions
      , "Labels" .= networkCreateRequestLabels
      ]


-- | Construct a value of type 'NetworkCreateRequest' (by applying it's required fields, if any)
mkNetworkCreateRequest
  :: Text -- ^ 'networkCreateRequestName': The network's name.
  -> NetworkCreateRequest
mkNetworkCreateRequest networkCreateRequestName =
  NetworkCreateRequest
  { networkCreateRequestName
  , networkCreateRequestCheckDuplicate = Nothing
  , networkCreateRequestDriver = Nothing
  , networkCreateRequestInternal = Nothing
  , networkCreateRequestAttachable = Nothing
  , networkCreateRequestIngress = Nothing
  , networkCreateRequestIpam = Nothing
  , networkCreateRequestEnableIpv6 = Nothing
  , networkCreateRequestOptions = Nothing
  , networkCreateRequestLabels = Nothing
  }

-- ** NetworkCreateResponse
-- | NetworkCreateResponse
-- NetworkCreateResponse
-- 
data NetworkCreateResponse = NetworkCreateResponse
  { networkCreateResponseId :: !(Maybe Text) -- ^ "Id" - The ID of the created network.
  , networkCreateResponseWarning :: !(Maybe Text) -- ^ "Warning"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkCreateResponse
instance A.FromJSON NetworkCreateResponse where
  parseJSON = A.withObject "NetworkCreateResponse" $ \o ->
    NetworkCreateResponse
      <$> (o .:? "Id")
      <*> (o .:? "Warning")

-- | ToJSON NetworkCreateResponse
instance A.ToJSON NetworkCreateResponse where
  toJSON NetworkCreateResponse {..} =
   _omitNulls
      [ "Id" .= networkCreateResponseId
      , "Warning" .= networkCreateResponseWarning
      ]


-- | Construct a value of type 'NetworkCreateResponse' (by applying it's required fields, if any)
mkNetworkCreateResponse
  :: NetworkCreateResponse
mkNetworkCreateResponse =
  NetworkCreateResponse
  { networkCreateResponseId = Nothing
  , networkCreateResponseWarning = Nothing
  }

-- ** NetworkDisconnectRequest
-- | NetworkDisconnectRequest
data NetworkDisconnectRequest = NetworkDisconnectRequest
  { networkDisconnectRequestContainer :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to disconnect from the network.
  , networkDisconnectRequestForce :: !(Maybe Bool) -- ^ "Force" - Force the container to disconnect from the network.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkDisconnectRequest
instance A.FromJSON NetworkDisconnectRequest where
  parseJSON = A.withObject "NetworkDisconnectRequest" $ \o ->
    NetworkDisconnectRequest
      <$> (o .:? "Container")
      <*> (o .:? "Force")

-- | ToJSON NetworkDisconnectRequest
instance A.ToJSON NetworkDisconnectRequest where
  toJSON NetworkDisconnectRequest {..} =
   _omitNulls
      [ "Container" .= networkDisconnectRequestContainer
      , "Force" .= networkDisconnectRequestForce
      ]


-- | Construct a value of type 'NetworkDisconnectRequest' (by applying it's required fields, if any)
mkNetworkDisconnectRequest
  :: NetworkDisconnectRequest
mkNetworkDisconnectRequest =
  NetworkDisconnectRequest
  { networkDisconnectRequestContainer = Nothing
  , networkDisconnectRequestForce = Nothing
  }

-- ** NetworkPruneResponse
-- | NetworkPruneResponse
-- NetworkPruneResponse
-- 
data NetworkPruneResponse = NetworkPruneResponse
  { networkPruneResponseNetworksDeleted :: !(Maybe [Text]) -- ^ "NetworksDeleted" - Networks that were deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkPruneResponse
instance A.FromJSON NetworkPruneResponse where
  parseJSON = A.withObject "NetworkPruneResponse" $ \o ->
    NetworkPruneResponse
      <$> (o .:? "NetworksDeleted")

-- | ToJSON NetworkPruneResponse
instance A.ToJSON NetworkPruneResponse where
  toJSON NetworkPruneResponse {..} =
   _omitNulls
      [ "NetworksDeleted" .= networkPruneResponseNetworksDeleted
      ]


-- | Construct a value of type 'NetworkPruneResponse' (by applying it's required fields, if any)
mkNetworkPruneResponse
  :: NetworkPruneResponse
mkNetworkPruneResponse =
  NetworkPruneResponse
  { networkPruneResponseNetworksDeleted = Nothing
  }

-- ** NetworkSettings
-- | NetworkSettings
-- NetworkSettings exposes the network settings in the API
data NetworkSettings = NetworkSettings
  { networkSettingsBridge :: !(Maybe Text) -- ^ "Bridge" - Name of the network&#39;s bridge (for example, &#x60;docker0&#x60;).
  , networkSettingsSandboxId :: !(Maybe Text) -- ^ "SandboxID" - SandboxID uniquely represents a container&#39;s network stack.
  , networkSettingsHairpinMode :: !(Maybe Bool) -- ^ "HairpinMode" - Indicates if hairpin NAT should be enabled on the virtual interface. 
  , networkSettingsLinkLocalIpv6Address :: !(Maybe Text) -- ^ "LinkLocalIPv6Address" - IPv6 unicast address using the link-local prefix.
  , networkSettingsLinkLocalIpv6PrefixLen :: !(Maybe Int) -- ^ "LinkLocalIPv6PrefixLen" - Prefix length of the IPv6 unicast address.
  , networkSettingsPorts :: !(Maybe (Map.Map String [PortBinding])) -- ^ "Ports" - PortMap describes the mapping of container ports to host ports, using the container&#39;s port-number and protocol as key in the format &#x60;&lt;port&gt;/&lt;protocol&gt;&#x60;, for example, &#x60;80/udp&#x60;.  If a container&#39;s port is mapped for both &#x60;tcp&#x60; and &#x60;udp&#x60;, two separate entries are added to the mapping table. 
  , networkSettingsSandboxKey :: !(Maybe Text) -- ^ "SandboxKey" - SandboxKey identifies the sandbox
  , networkSettingsSecondaryIpAddresses :: !(Maybe [Address]) -- ^ "SecondaryIPAddresses" - 
  , networkSettingsSecondaryIpv6Addresses :: !(Maybe [Address]) -- ^ "SecondaryIPv6Addresses" - 
  , networkSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID" - EndpointID uniquely represents a service endpoint in a Sandbox.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGateway :: !(Maybe Text) -- ^ "Gateway" - Gateway address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGlobalIpv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address" - Global IPv6 address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGlobalIpv6PrefixLen :: !(Maybe Int) -- ^ "GlobalIPv6PrefixLen" - Mask length of the global IPv6 address.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress" - IPv4 address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen" - Mask length of the IPv4 address.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway" - IPv6 gateway address for this network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address for the container on the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks" - Information about all networks that the container is connected to. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkSettings
instance A.FromJSON NetworkSettings where
  parseJSON = A.withObject "NetworkSettings" $ \o ->
    NetworkSettings
      <$> (o .:? "Bridge")
      <*> (o .:? "SandboxID")
      <*> (o .:? "HairpinMode")
      <*> (o .:? "LinkLocalIPv6Address")
      <*> (o .:? "LinkLocalIPv6PrefixLen")
      <*> (o .:? "Ports")
      <*> (o .:? "SandboxKey")
      <*> (o .:? "SecondaryIPAddresses")
      <*> (o .:? "SecondaryIPv6Addresses")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "MacAddress")
      <*> (o .:? "Networks")

-- | ToJSON NetworkSettings
instance A.ToJSON NetworkSettings where
  toJSON NetworkSettings {..} =
   _omitNulls
      [ "Bridge" .= networkSettingsBridge
      , "SandboxID" .= networkSettingsSandboxId
      , "HairpinMode" .= networkSettingsHairpinMode
      , "LinkLocalIPv6Address" .= networkSettingsLinkLocalIpv6Address
      , "LinkLocalIPv6PrefixLen" .= networkSettingsLinkLocalIpv6PrefixLen
      , "Ports" .= networkSettingsPorts
      , "SandboxKey" .= networkSettingsSandboxKey
      , "SecondaryIPAddresses" .= networkSettingsSecondaryIpAddresses
      , "SecondaryIPv6Addresses" .= networkSettingsSecondaryIpv6Addresses
      , "EndpointID" .= networkSettingsEndpointId
      , "Gateway" .= networkSettingsGateway
      , "GlobalIPv6Address" .= networkSettingsGlobalIpv6Address
      , "GlobalIPv6PrefixLen" .= networkSettingsGlobalIpv6PrefixLen
      , "IPAddress" .= networkSettingsIpAddress
      , "IPPrefixLen" .= networkSettingsIpPrefixLen
      , "IPv6Gateway" .= networkSettingsIpv6Gateway
      , "MacAddress" .= networkSettingsMacAddress
      , "Networks" .= networkSettingsNetworks
      ]


-- | Construct a value of type 'NetworkSettings' (by applying it's required fields, if any)
mkNetworkSettings
  :: NetworkSettings
mkNetworkSettings =
  NetworkSettings
  { networkSettingsBridge = Nothing
  , networkSettingsSandboxId = Nothing
  , networkSettingsHairpinMode = Nothing
  , networkSettingsLinkLocalIpv6Address = Nothing
  , networkSettingsLinkLocalIpv6PrefixLen = Nothing
  , networkSettingsPorts = Nothing
  , networkSettingsSandboxKey = Nothing
  , networkSettingsSecondaryIpAddresses = Nothing
  , networkSettingsSecondaryIpv6Addresses = Nothing
  , networkSettingsEndpointId = Nothing
  , networkSettingsGateway = Nothing
  , networkSettingsGlobalIpv6Address = Nothing
  , networkSettingsGlobalIpv6PrefixLen = Nothing
  , networkSettingsIpAddress = Nothing
  , networkSettingsIpPrefixLen = Nothing
  , networkSettingsIpv6Gateway = Nothing
  , networkSettingsMacAddress = Nothing
  , networkSettingsNetworks = Nothing
  }

-- ** Node
-- | Node
data Node = Node
  { nodeId :: !(Maybe Text) -- ^ "ID"
  , nodeVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , nodeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the node was added to the swarm in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , nodeUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the node was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , nodeSpec :: !(Maybe NodeSpec) -- ^ "Spec"
  , nodeDescription :: !(Maybe NodeDescription) -- ^ "Description"
  , nodeStatus :: !(Maybe NodeStatus) -- ^ "Status"
  , nodeManagerStatus :: !(Maybe ManagerStatus) -- ^ "ManagerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Node
instance A.FromJSON Node where
  parseJSON = A.withObject "Node" $ \o ->
    Node
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Description")
      <*> (o .:? "Status")
      <*> (o .:? "ManagerStatus")

-- | ToJSON Node
instance A.ToJSON Node where
  toJSON Node {..} =
   _omitNulls
      [ "ID" .= nodeId
      , "Version" .= nodeVersion
      , "CreatedAt" .= nodeCreatedAt
      , "UpdatedAt" .= nodeUpdatedAt
      , "Spec" .= nodeSpec
      , "Description" .= nodeDescription
      , "Status" .= nodeStatus
      , "ManagerStatus" .= nodeManagerStatus
      ]


-- | Construct a value of type 'Node' (by applying it's required fields, if any)
mkNode
  :: Node
mkNode =
  Node
  { nodeId = Nothing
  , nodeVersion = Nothing
  , nodeCreatedAt = Nothing
  , nodeUpdatedAt = Nothing
  , nodeSpec = Nothing
  , nodeDescription = Nothing
  , nodeStatus = Nothing
  , nodeManagerStatus = Nothing
  }

-- ** NodeDescription
-- | NodeDescription
-- NodeDescription encapsulates the properties of the Node as reported by the agent. 
data NodeDescription = NodeDescription
  { nodeDescriptionHostname :: !(Maybe Text) -- ^ "Hostname"
  , nodeDescriptionPlatform :: !(Maybe Platform) -- ^ "Platform"
  , nodeDescriptionResources :: !(Maybe ResourceObject) -- ^ "Resources"
  , nodeDescriptionEngine :: !(Maybe EngineDescription) -- ^ "Engine"
  , nodeDescriptionTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescription
instance A.FromJSON NodeDescription where
  parseJSON = A.withObject "NodeDescription" $ \o ->
    NodeDescription
      <$> (o .:? "Hostname")
      <*> (o .:? "Platform")
      <*> (o .:? "Resources")
      <*> (o .:? "Engine")
      <*> (o .:? "TLSInfo")

-- | ToJSON NodeDescription
instance A.ToJSON NodeDescription where
  toJSON NodeDescription {..} =
   _omitNulls
      [ "Hostname" .= nodeDescriptionHostname
      , "Platform" .= nodeDescriptionPlatform
      , "Resources" .= nodeDescriptionResources
      , "Engine" .= nodeDescriptionEngine
      , "TLSInfo" .= nodeDescriptionTlsInfo
      ]


-- | Construct a value of type 'NodeDescription' (by applying it's required fields, if any)
mkNodeDescription
  :: NodeDescription
mkNodeDescription =
  NodeDescription
  { nodeDescriptionHostname = Nothing
  , nodeDescriptionPlatform = Nothing
  , nodeDescriptionResources = Nothing
  , nodeDescriptionEngine = Nothing
  , nodeDescriptionTlsInfo = Nothing
  }

-- ** NodeSpec
-- | NodeSpec
data NodeSpec = NodeSpec
  { nodeSpecName :: !(Maybe Text) -- ^ "Name" - Name for the node.
  , nodeSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , nodeSpecRole :: !(Maybe E'Role) -- ^ "Role" - Role of the node.
  , nodeSpecAvailability :: !(Maybe E'Availability) -- ^ "Availability" - Availability of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeSpec
instance A.FromJSON NodeSpec where
  parseJSON = A.withObject "NodeSpec" $ \o ->
    NodeSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Role")
      <*> (o .:? "Availability")

-- | ToJSON NodeSpec
instance A.ToJSON NodeSpec where
  toJSON NodeSpec {..} =
   _omitNulls
      [ "Name" .= nodeSpecName
      , "Labels" .= nodeSpecLabels
      , "Role" .= nodeSpecRole
      , "Availability" .= nodeSpecAvailability
      ]


-- | Construct a value of type 'NodeSpec' (by applying it's required fields, if any)
mkNodeSpec
  :: NodeSpec
mkNodeSpec =
  NodeSpec
  { nodeSpecName = Nothing
  , nodeSpecLabels = Nothing
  , nodeSpecRole = Nothing
  , nodeSpecAvailability = Nothing
  }

-- ** NodeStatus
-- | NodeStatus
-- NodeStatus represents the status of a node.  It provides the current status of the node, as seen by the manager. 
data NodeStatus = NodeStatus
  { nodeStatusState :: !(Maybe NodeState) -- ^ "State"
  , nodeStatusMessage :: !(Maybe Text) -- ^ "Message"
  , nodeStatusAddr :: !(Maybe Text) -- ^ "Addr" - IP address of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeStatus
instance A.FromJSON NodeStatus where
  parseJSON = A.withObject "NodeStatus" $ \o ->
    NodeStatus
      <$> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Addr")

-- | ToJSON NodeStatus
instance A.ToJSON NodeStatus where
  toJSON NodeStatus {..} =
   _omitNulls
      [ "State" .= nodeStatusState
      , "Message" .= nodeStatusMessage
      , "Addr" .= nodeStatusAddr
      ]


-- | Construct a value of type 'NodeStatus' (by applying it's required fields, if any)
mkNodeStatus
  :: NodeStatus
mkNodeStatus =
  NodeStatus
  { nodeStatusState = Nothing
  , nodeStatusMessage = Nothing
  , nodeStatusAddr = Nothing
  }

-- ** ObjectVersion
-- | ObjectVersion
-- The version number of the object such as node, service, etc. This is needed to avoid conflicting writes. The client must send the version number along with the modified specification when updating these objects. This approach ensures safe concurrency and determinism in that the change on the object may not be applied if the version number has changed from the last read. In other words, if two update requests specify the same base version, only one of the requests can succeed. As a result, two separate update requests that happen at the same time will not unintentionally overwrite each other. 
data ObjectVersion = ObjectVersion
  { objectVersionIndex :: !(Maybe Int) -- ^ "Index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ObjectVersion
instance A.FromJSON ObjectVersion where
  parseJSON = A.withObject "ObjectVersion" $ \o ->
    ObjectVersion
      <$> (o .:? "Index")

-- | ToJSON ObjectVersion
instance A.ToJSON ObjectVersion where
  toJSON ObjectVersion {..} =
   _omitNulls
      [ "Index" .= objectVersionIndex
      ]


-- | Construct a value of type 'ObjectVersion' (by applying it's required fields, if any)
mkObjectVersion
  :: ObjectVersion
mkObjectVersion =
  ObjectVersion
  { objectVersionIndex = Nothing
  }

-- ** PeerNode
-- | PeerNode
-- Represents a peer-node in the swarm
data PeerNode = PeerNode
  { peerNodeNodeId :: !(Maybe Text) -- ^ "NodeID" - Unique identifier of for this node in the swarm.
  , peerNodeAddr :: !(Maybe Text) -- ^ "Addr" - IP address and ports at which this node can be reached. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PeerNode
instance A.FromJSON PeerNode where
  parseJSON = A.withObject "PeerNode" $ \o ->
    PeerNode
      <$> (o .:? "NodeID")
      <*> (o .:? "Addr")

-- | ToJSON PeerNode
instance A.ToJSON PeerNode where
  toJSON PeerNode {..} =
   _omitNulls
      [ "NodeID" .= peerNodeNodeId
      , "Addr" .= peerNodeAddr
      ]


-- | Construct a value of type 'PeerNode' (by applying it's required fields, if any)
mkPeerNode
  :: PeerNode
mkPeerNode =
  PeerNode
  { peerNodeNodeId = Nothing
  , peerNodeAddr = Nothing
  }

-- ** Platform
-- | Platform
-- Platform represents the platform (Arch/OS). 
data Platform = Platform
  { platformArchitecture :: !(Maybe Text) -- ^ "Architecture" - Architecture represents the hardware architecture (for example, &#x60;x86_64&#x60;). 
  , platformOs :: !(Maybe Text) -- ^ "OS" - OS represents the Operating System (for example, &#x60;linux&#x60; or &#x60;windows&#x60;). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Platform
instance A.FromJSON Platform where
  parseJSON = A.withObject "Platform" $ \o ->
    Platform
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")

-- | ToJSON Platform
instance A.ToJSON Platform where
  toJSON Platform {..} =
   _omitNulls
      [ "Architecture" .= platformArchitecture
      , "OS" .= platformOs
      ]


-- | Construct a value of type 'Platform' (by applying it's required fields, if any)
mkPlatform
  :: Platform
mkPlatform =
  Platform
  { platformArchitecture = Nothing
  , platformOs = Nothing
  }

-- ** Plugin
-- | Plugin
-- A plugin for the Engine API
data Plugin = Plugin
  { pluginId :: !(Maybe Text) -- ^ "Id"
  , pluginName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnabled :: !(Bool) -- ^ /Required/ "Enabled" - True if the plugin is running. False if the plugin is not running, only installed.
  , pluginSettings :: !(PluginSettings) -- ^ /Required/ "Settings"
  , pluginPluginReference :: !(Maybe Text) -- ^ "PluginReference" - plugin remote reference used to push/pull the plugin
  , pluginConfig :: !(PluginConfig) -- ^ /Required/ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Plugin
instance A.FromJSON Plugin where
  parseJSON = A.withObject "Plugin" $ \o ->
    Plugin
      <$> (o .:? "Id")
      <*> (o .:  "Name")
      <*> (o .:  "Enabled")
      <*> (o .:  "Settings")
      <*> (o .:? "PluginReference")
      <*> (o .:  "Config")

-- | ToJSON Plugin
instance A.ToJSON Plugin where
  toJSON Plugin {..} =
   _omitNulls
      [ "Id" .= pluginId
      , "Name" .= pluginName
      , "Enabled" .= pluginEnabled
      , "Settings" .= pluginSettings
      , "PluginReference" .= pluginPluginReference
      , "Config" .= pluginConfig
      ]


-- | Construct a value of type 'Plugin' (by applying it's required fields, if any)
mkPlugin
  :: Text -- ^ 'pluginName' 
  -> Bool -- ^ 'pluginEnabled': True if the plugin is running. False if the plugin is not running, only installed.
  -> PluginSettings -- ^ 'pluginSettings' 
  -> PluginConfig -- ^ 'pluginConfig' 
  -> Plugin
mkPlugin pluginName pluginEnabled pluginSettings pluginConfig =
  Plugin
  { pluginId = Nothing
  , pluginName
  , pluginEnabled
  , pluginSettings
  , pluginPluginReference = Nothing
  , pluginConfig
  }

-- ** PluginConfig
-- | PluginConfig
-- The config of a plugin.
data PluginConfig = PluginConfig
  { pluginConfigDockerVersion :: !(Maybe Text) -- ^ "DockerVersion" - Docker Version used to create the plugin
  , pluginConfigDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigDocumentation :: !(Text) -- ^ /Required/ "Documentation"
  , pluginConfigInterface :: !(PluginConfigInterface) -- ^ /Required/ "Interface"
  , pluginConfigEntrypoint :: !([Text]) -- ^ /Required/ "Entrypoint"
  , pluginConfigWorkDir :: !(Text) -- ^ /Required/ "WorkDir"
  , pluginConfigUser :: !(Maybe PluginConfigUser) -- ^ "User"
  , pluginConfigNetwork :: !(PluginConfigNetwork) -- ^ /Required/ "Network"
  , pluginConfigLinux :: !(PluginConfigLinux) -- ^ /Required/ "Linux"
  , pluginConfigPropagatedMount :: !(Text) -- ^ /Required/ "PropagatedMount"
  , pluginConfigIpcHost :: !(Bool) -- ^ /Required/ "IpcHost"
  , pluginConfigPidHost :: !(Bool) -- ^ /Required/ "PidHost"
  , pluginConfigMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginConfigEnv :: !([PluginEnv]) -- ^ /Required/ "Env"
  , pluginConfigArgs :: !(PluginConfigArgs) -- ^ /Required/ "Args"
  , pluginConfigRootfs :: !(Maybe PluginConfigRootfs) -- ^ "rootfs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfig
instance A.FromJSON PluginConfig where
  parseJSON = A.withObject "PluginConfig" $ \o ->
    PluginConfig
      <$> (o .:? "DockerVersion")
      <*> (o .:  "Description")
      <*> (o .:  "Documentation")
      <*> (o .:  "Interface")
      <*> (o .:  "Entrypoint")
      <*> (o .:  "WorkDir")
      <*> (o .:? "User")
      <*> (o .:  "Network")
      <*> (o .:  "Linux")
      <*> (o .:  "PropagatedMount")
      <*> (o .:  "IpcHost")
      <*> (o .:  "PidHost")
      <*> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:? "rootfs")

-- | ToJSON PluginConfig
instance A.ToJSON PluginConfig where
  toJSON PluginConfig {..} =
   _omitNulls
      [ "DockerVersion" .= pluginConfigDockerVersion
      , "Description" .= pluginConfigDescription
      , "Documentation" .= pluginConfigDocumentation
      , "Interface" .= pluginConfigInterface
      , "Entrypoint" .= pluginConfigEntrypoint
      , "WorkDir" .= pluginConfigWorkDir
      , "User" .= pluginConfigUser
      , "Network" .= pluginConfigNetwork
      , "Linux" .= pluginConfigLinux
      , "PropagatedMount" .= pluginConfigPropagatedMount
      , "IpcHost" .= pluginConfigIpcHost
      , "PidHost" .= pluginConfigPidHost
      , "Mounts" .= pluginConfigMounts
      , "Env" .= pluginConfigEnv
      , "Args" .= pluginConfigArgs
      , "rootfs" .= pluginConfigRootfs
      ]


-- | Construct a value of type 'PluginConfig' (by applying it's required fields, if any)
mkPluginConfig
  :: Text -- ^ 'pluginConfigDescription' 
  -> Text -- ^ 'pluginConfigDocumentation' 
  -> PluginConfigInterface -- ^ 'pluginConfigInterface' 
  -> [Text] -- ^ 'pluginConfigEntrypoint' 
  -> Text -- ^ 'pluginConfigWorkDir' 
  -> PluginConfigNetwork -- ^ 'pluginConfigNetwork' 
  -> PluginConfigLinux -- ^ 'pluginConfigLinux' 
  -> Text -- ^ 'pluginConfigPropagatedMount' 
  -> Bool -- ^ 'pluginConfigIpcHost' 
  -> Bool -- ^ 'pluginConfigPidHost' 
  -> [PluginMount] -- ^ 'pluginConfigMounts' 
  -> [PluginEnv] -- ^ 'pluginConfigEnv' 
  -> PluginConfigArgs -- ^ 'pluginConfigArgs' 
  -> PluginConfig
mkPluginConfig pluginConfigDescription pluginConfigDocumentation pluginConfigInterface pluginConfigEntrypoint pluginConfigWorkDir pluginConfigNetwork pluginConfigLinux pluginConfigPropagatedMount pluginConfigIpcHost pluginConfigPidHost pluginConfigMounts pluginConfigEnv pluginConfigArgs =
  PluginConfig
  { pluginConfigDockerVersion = Nothing
  , pluginConfigDescription
  , pluginConfigDocumentation
  , pluginConfigInterface
  , pluginConfigEntrypoint
  , pluginConfigWorkDir
  , pluginConfigUser = Nothing
  , pluginConfigNetwork
  , pluginConfigLinux
  , pluginConfigPropagatedMount
  , pluginConfigIpcHost
  , pluginConfigPidHost
  , pluginConfigMounts
  , pluginConfigEnv
  , pluginConfigArgs
  , pluginConfigRootfs = Nothing
  }

-- ** PluginConfigArgs
-- | PluginConfigArgs
data PluginConfigArgs = PluginConfigArgs
  { pluginConfigArgsName :: !(Text) -- ^ /Required/ "Name"
  , pluginConfigArgsDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigArgsSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginConfigArgsValue :: !([Text]) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigArgs
instance A.FromJSON PluginConfigArgs where
  parseJSON = A.withObject "PluginConfigArgs" $ \o ->
    PluginConfigArgs
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginConfigArgs
instance A.ToJSON PluginConfigArgs where
  toJSON PluginConfigArgs {..} =
   _omitNulls
      [ "Name" .= pluginConfigArgsName
      , "Description" .= pluginConfigArgsDescription
      , "Settable" .= pluginConfigArgsSettable
      , "Value" .= pluginConfigArgsValue
      ]


-- | Construct a value of type 'PluginConfigArgs' (by applying it's required fields, if any)
mkPluginConfigArgs
  :: Text -- ^ 'pluginConfigArgsName' 
  -> Text -- ^ 'pluginConfigArgsDescription' 
  -> [Text] -- ^ 'pluginConfigArgsSettable' 
  -> [Text] -- ^ 'pluginConfigArgsValue' 
  -> PluginConfigArgs
mkPluginConfigArgs pluginConfigArgsName pluginConfigArgsDescription pluginConfigArgsSettable pluginConfigArgsValue =
  PluginConfigArgs
  { pluginConfigArgsName
  , pluginConfigArgsDescription
  , pluginConfigArgsSettable
  , pluginConfigArgsValue
  }

-- ** PluginConfigInterface
-- | PluginConfigInterface
-- The interface between Docker and the plugin
data PluginConfigInterface = PluginConfigInterface
  { pluginConfigInterfaceTypes :: !([PluginInterfaceType]) -- ^ /Required/ "Types"
  , pluginConfigInterfaceSocket :: !(Text) -- ^ /Required/ "Socket"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigInterface
instance A.FromJSON PluginConfigInterface where
  parseJSON = A.withObject "PluginConfigInterface" $ \o ->
    PluginConfigInterface
      <$> (o .:  "Types")
      <*> (o .:  "Socket")

-- | ToJSON PluginConfigInterface
instance A.ToJSON PluginConfigInterface where
  toJSON PluginConfigInterface {..} =
   _omitNulls
      [ "Types" .= pluginConfigInterfaceTypes
      , "Socket" .= pluginConfigInterfaceSocket
      ]


-- | Construct a value of type 'PluginConfigInterface' (by applying it's required fields, if any)
mkPluginConfigInterface
  :: [PluginInterfaceType] -- ^ 'pluginConfigInterfaceTypes' 
  -> Text -- ^ 'pluginConfigInterfaceSocket' 
  -> PluginConfigInterface
mkPluginConfigInterface pluginConfigInterfaceTypes pluginConfigInterfaceSocket =
  PluginConfigInterface
  { pluginConfigInterfaceTypes
  , pluginConfigInterfaceSocket
  }

-- ** PluginConfigLinux
-- | PluginConfigLinux
data PluginConfigLinux = PluginConfigLinux
  { pluginConfigLinuxCapabilities :: !([Text]) -- ^ /Required/ "Capabilities"
  , pluginConfigLinuxAllowAllDevices :: !(Bool) -- ^ /Required/ "AllowAllDevices"
  , pluginConfigLinuxDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigLinux
instance A.FromJSON PluginConfigLinux where
  parseJSON = A.withObject "PluginConfigLinux" $ \o ->
    PluginConfigLinux
      <$> (o .:  "Capabilities")
      <*> (o .:  "AllowAllDevices")
      <*> (o .:  "Devices")

-- | ToJSON PluginConfigLinux
instance A.ToJSON PluginConfigLinux where
  toJSON PluginConfigLinux {..} =
   _omitNulls
      [ "Capabilities" .= pluginConfigLinuxCapabilities
      , "AllowAllDevices" .= pluginConfigLinuxAllowAllDevices
      , "Devices" .= pluginConfigLinuxDevices
      ]


-- | Construct a value of type 'PluginConfigLinux' (by applying it's required fields, if any)
mkPluginConfigLinux
  :: [Text] -- ^ 'pluginConfigLinuxCapabilities' 
  -> Bool -- ^ 'pluginConfigLinuxAllowAllDevices' 
  -> [PluginDevice] -- ^ 'pluginConfigLinuxDevices' 
  -> PluginConfigLinux
mkPluginConfigLinux pluginConfigLinuxCapabilities pluginConfigLinuxAllowAllDevices pluginConfigLinuxDevices =
  PluginConfigLinux
  { pluginConfigLinuxCapabilities
  , pluginConfigLinuxAllowAllDevices
  , pluginConfigLinuxDevices
  }

-- ** PluginConfigNetwork
-- | PluginConfigNetwork
data PluginConfigNetwork = PluginConfigNetwork
  { pluginConfigNetworkType :: !(Text) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigNetwork
instance A.FromJSON PluginConfigNetwork where
  parseJSON = A.withObject "PluginConfigNetwork" $ \o ->
    PluginConfigNetwork
      <$> (o .:  "Type")

-- | ToJSON PluginConfigNetwork
instance A.ToJSON PluginConfigNetwork where
  toJSON PluginConfigNetwork {..} =
   _omitNulls
      [ "Type" .= pluginConfigNetworkType
      ]


-- | Construct a value of type 'PluginConfigNetwork' (by applying it's required fields, if any)
mkPluginConfigNetwork
  :: Text -- ^ 'pluginConfigNetworkType' 
  -> PluginConfigNetwork
mkPluginConfigNetwork pluginConfigNetworkType =
  PluginConfigNetwork
  { pluginConfigNetworkType
  }

-- ** PluginConfigRootfs
-- | PluginConfigRootfs
data PluginConfigRootfs = PluginConfigRootfs
  { pluginConfigRootfsType :: !(Maybe Text) -- ^ "type"
  , pluginConfigRootfsDiffIds :: !(Maybe [Text]) -- ^ "diff_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigRootfs
instance A.FromJSON PluginConfigRootfs where
  parseJSON = A.withObject "PluginConfigRootfs" $ \o ->
    PluginConfigRootfs
      <$> (o .:? "type")
      <*> (o .:? "diff_ids")

-- | ToJSON PluginConfigRootfs
instance A.ToJSON PluginConfigRootfs where
  toJSON PluginConfigRootfs {..} =
   _omitNulls
      [ "type" .= pluginConfigRootfsType
      , "diff_ids" .= pluginConfigRootfsDiffIds
      ]


-- | Construct a value of type 'PluginConfigRootfs' (by applying it's required fields, if any)
mkPluginConfigRootfs
  :: PluginConfigRootfs
mkPluginConfigRootfs =
  PluginConfigRootfs
  { pluginConfigRootfsType = Nothing
  , pluginConfigRootfsDiffIds = Nothing
  }

-- ** PluginConfigUser
-- | PluginConfigUser
data PluginConfigUser = PluginConfigUser
  { pluginConfigUserUid :: !(Maybe Int) -- ^ "UID"
  , pluginConfigUserGid :: !(Maybe Int) -- ^ "GID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigUser
instance A.FromJSON PluginConfigUser where
  parseJSON = A.withObject "PluginConfigUser" $ \o ->
    PluginConfigUser
      <$> (o .:? "UID")
      <*> (o .:? "GID")

-- | ToJSON PluginConfigUser
instance A.ToJSON PluginConfigUser where
  toJSON PluginConfigUser {..} =
   _omitNulls
      [ "UID" .= pluginConfigUserUid
      , "GID" .= pluginConfigUserGid
      ]


-- | Construct a value of type 'PluginConfigUser' (by applying it's required fields, if any)
mkPluginConfigUser
  :: PluginConfigUser
mkPluginConfigUser =
  PluginConfigUser
  { pluginConfigUserUid = Nothing
  , pluginConfigUserGid = Nothing
  }

-- ** PluginDevice
-- | PluginDevice
data PluginDevice = PluginDevice
  { pluginDeviceName :: !(Text) -- ^ /Required/ "Name"
  , pluginDeviceDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginDeviceSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginDevicePath :: !(Text) -- ^ /Required/ "Path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginDevice
instance A.FromJSON PluginDevice where
  parseJSON = A.withObject "PluginDevice" $ \o ->
    PluginDevice
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Path")

-- | ToJSON PluginDevice
instance A.ToJSON PluginDevice where
  toJSON PluginDevice {..} =
   _omitNulls
      [ "Name" .= pluginDeviceName
      , "Description" .= pluginDeviceDescription
      , "Settable" .= pluginDeviceSettable
      , "Path" .= pluginDevicePath
      ]


-- | Construct a value of type 'PluginDevice' (by applying it's required fields, if any)
mkPluginDevice
  :: Text -- ^ 'pluginDeviceName' 
  -> Text -- ^ 'pluginDeviceDescription' 
  -> [Text] -- ^ 'pluginDeviceSettable' 
  -> Text -- ^ 'pluginDevicePath' 
  -> PluginDevice
mkPluginDevice pluginDeviceName pluginDeviceDescription pluginDeviceSettable pluginDevicePath =
  PluginDevice
  { pluginDeviceName
  , pluginDeviceDescription
  , pluginDeviceSettable
  , pluginDevicePath
  }

-- ** PluginEnv
-- | PluginEnv
data PluginEnv = PluginEnv
  { pluginEnvName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnvDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginEnvSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginEnvValue :: !(Text) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginEnv
instance A.FromJSON PluginEnv where
  parseJSON = A.withObject "PluginEnv" $ \o ->
    PluginEnv
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginEnv
instance A.ToJSON PluginEnv where
  toJSON PluginEnv {..} =
   _omitNulls
      [ "Name" .= pluginEnvName
      , "Description" .= pluginEnvDescription
      , "Settable" .= pluginEnvSettable
      , "Value" .= pluginEnvValue
      ]


-- | Construct a value of type 'PluginEnv' (by applying it's required fields, if any)
mkPluginEnv
  :: Text -- ^ 'pluginEnvName' 
  -> Text -- ^ 'pluginEnvDescription' 
  -> [Text] -- ^ 'pluginEnvSettable' 
  -> Text -- ^ 'pluginEnvValue' 
  -> PluginEnv
mkPluginEnv pluginEnvName pluginEnvDescription pluginEnvSettable pluginEnvValue =
  PluginEnv
  { pluginEnvName
  , pluginEnvDescription
  , pluginEnvSettable
  , pluginEnvValue
  }

-- ** PluginInterfaceType
-- | PluginInterfaceType
data PluginInterfaceType = PluginInterfaceType
  { pluginInterfaceTypePrefix :: !(Text) -- ^ /Required/ "Prefix"
  , pluginInterfaceTypeCapability :: !(Text) -- ^ /Required/ "Capability"
  , pluginInterfaceTypeVersion :: !(Text) -- ^ /Required/ "Version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginInterfaceType
instance A.FromJSON PluginInterfaceType where
  parseJSON = A.withObject "PluginInterfaceType" $ \o ->
    PluginInterfaceType
      <$> (o .:  "Prefix")
      <*> (o .:  "Capability")
      <*> (o .:  "Version")

-- | ToJSON PluginInterfaceType
instance A.ToJSON PluginInterfaceType where
  toJSON PluginInterfaceType {..} =
   _omitNulls
      [ "Prefix" .= pluginInterfaceTypePrefix
      , "Capability" .= pluginInterfaceTypeCapability
      , "Version" .= pluginInterfaceTypeVersion
      ]


-- | Construct a value of type 'PluginInterfaceType' (by applying it's required fields, if any)
mkPluginInterfaceType
  :: Text -- ^ 'pluginInterfaceTypePrefix' 
  -> Text -- ^ 'pluginInterfaceTypeCapability' 
  -> Text -- ^ 'pluginInterfaceTypeVersion' 
  -> PluginInterfaceType
mkPluginInterfaceType pluginInterfaceTypePrefix pluginInterfaceTypeCapability pluginInterfaceTypeVersion =
  PluginInterfaceType
  { pluginInterfaceTypePrefix
  , pluginInterfaceTypeCapability
  , pluginInterfaceTypeVersion
  }

-- ** PluginMount
-- | PluginMount
data PluginMount = PluginMount
  { pluginMountName :: !(Text) -- ^ /Required/ "Name"
  , pluginMountDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginMountSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginMountSource :: !(Text) -- ^ /Required/ "Source"
  , pluginMountDestination :: !(Text) -- ^ /Required/ "Destination"
  , pluginMountType :: !(Text) -- ^ /Required/ "Type"
  , pluginMountOptions :: !([Text]) -- ^ /Required/ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginMount
instance A.FromJSON PluginMount where
  parseJSON = A.withObject "PluginMount" $ \o ->
    PluginMount
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Source")
      <*> (o .:  "Destination")
      <*> (o .:  "Type")
      <*> (o .:  "Options")

-- | ToJSON PluginMount
instance A.ToJSON PluginMount where
  toJSON PluginMount {..} =
   _omitNulls
      [ "Name" .= pluginMountName
      , "Description" .= pluginMountDescription
      , "Settable" .= pluginMountSettable
      , "Source" .= pluginMountSource
      , "Destination" .= pluginMountDestination
      , "Type" .= pluginMountType
      , "Options" .= pluginMountOptions
      ]


-- | Construct a value of type 'PluginMount' (by applying it's required fields, if any)
mkPluginMount
  :: Text -- ^ 'pluginMountName' 
  -> Text -- ^ 'pluginMountDescription' 
  -> [Text] -- ^ 'pluginMountSettable' 
  -> Text -- ^ 'pluginMountSource' 
  -> Text -- ^ 'pluginMountDestination' 
  -> Text -- ^ 'pluginMountType' 
  -> [Text] -- ^ 'pluginMountOptions' 
  -> PluginMount
mkPluginMount pluginMountName pluginMountDescription pluginMountSettable pluginMountSource pluginMountDestination pluginMountType pluginMountOptions =
  PluginMount
  { pluginMountName
  , pluginMountDescription
  , pluginMountSettable
  , pluginMountSource
  , pluginMountDestination
  , pluginMountType
  , pluginMountOptions
  }

-- ** PluginPrivilegeItem
-- | PluginPrivilegeItem
-- PluginPrivilegeItem
-- 
-- Describes a permission the user has to accept upon installing the plugin.
data PluginPrivilegeItem = PluginPrivilegeItem
  { pluginPrivilegeItemName :: !(Maybe Text) -- ^ "Name"
  , pluginPrivilegeItemDescription :: !(Maybe Text) -- ^ "Description"
  , pluginPrivilegeItemValue :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginPrivilegeItem
instance A.FromJSON PluginPrivilegeItem where
  parseJSON = A.withObject "PluginPrivilegeItem" $ \o ->
    PluginPrivilegeItem
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON PluginPrivilegeItem
instance A.ToJSON PluginPrivilegeItem where
  toJSON PluginPrivilegeItem {..} =
   _omitNulls
      [ "Name" .= pluginPrivilegeItemName
      , "Description" .= pluginPrivilegeItemDescription
      , "Value" .= pluginPrivilegeItemValue
      ]


-- | Construct a value of type 'PluginPrivilegeItem' (by applying it's required fields, if any)
mkPluginPrivilegeItem
  :: PluginPrivilegeItem
mkPluginPrivilegeItem =
  PluginPrivilegeItem
  { pluginPrivilegeItemName = Nothing
  , pluginPrivilegeItemDescription = Nothing
  , pluginPrivilegeItemValue = Nothing
  }

-- ** PluginPullRequestInner
-- | PluginPullRequestInner
-- Describes a permission accepted by the user upon installing the plugin.
data PluginPullRequestInner = PluginPullRequestInner
  { pluginPullRequestInnerName :: !(Maybe Text) -- ^ "Name"
  , pluginPullRequestInnerDescription :: !(Maybe Text) -- ^ "Description"
  , pluginPullRequestInnerValue :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginPullRequestInner
instance A.FromJSON PluginPullRequestInner where
  parseJSON = A.withObject "PluginPullRequestInner" $ \o ->
    PluginPullRequestInner
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON PluginPullRequestInner
instance A.ToJSON PluginPullRequestInner where
  toJSON PluginPullRequestInner {..} =
   _omitNulls
      [ "Name" .= pluginPullRequestInnerName
      , "Description" .= pluginPullRequestInnerDescription
      , "Value" .= pluginPullRequestInnerValue
      ]


-- | Construct a value of type 'PluginPullRequestInner' (by applying it's required fields, if any)
mkPluginPullRequestInner
  :: PluginPullRequestInner
mkPluginPullRequestInner =
  PluginPullRequestInner
  { pluginPullRequestInnerName = Nothing
  , pluginPullRequestInnerDescription = Nothing
  , pluginPullRequestInnerValue = Nothing
  }

-- ** PluginSettings
-- | PluginSettings
-- Settings that can be modified by users.
data PluginSettings = PluginSettings
  { pluginSettingsMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginSettingsEnv :: !([Text]) -- ^ /Required/ "Env"
  , pluginSettingsArgs :: !([Text]) -- ^ /Required/ "Args"
  , pluginSettingsDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginSettings
instance A.FromJSON PluginSettings where
  parseJSON = A.withObject "PluginSettings" $ \o ->
    PluginSettings
      <$> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:  "Devices")

-- | ToJSON PluginSettings
instance A.ToJSON PluginSettings where
  toJSON PluginSettings {..} =
   _omitNulls
      [ "Mounts" .= pluginSettingsMounts
      , "Env" .= pluginSettingsEnv
      , "Args" .= pluginSettingsArgs
      , "Devices" .= pluginSettingsDevices
      ]


-- | Construct a value of type 'PluginSettings' (by applying it's required fields, if any)
mkPluginSettings
  :: [PluginMount] -- ^ 'pluginSettingsMounts' 
  -> [Text] -- ^ 'pluginSettingsEnv' 
  -> [Text] -- ^ 'pluginSettingsArgs' 
  -> [PluginDevice] -- ^ 'pluginSettingsDevices' 
  -> PluginSettings
mkPluginSettings pluginSettingsMounts pluginSettingsEnv pluginSettingsArgs pluginSettingsDevices =
  PluginSettings
  { pluginSettingsMounts
  , pluginSettingsEnv
  , pluginSettingsArgs
  , pluginSettingsDevices
  }

-- ** PluginsInfo
-- | PluginsInfo
-- Available plugins per type.  <p><br /></p>  > **Note**: Only unmanaged (V1) plugins are included in this list. > V1 plugins are \"lazily\" loaded, and are not returned in this list > if there is no resource using the plugin. 
data PluginsInfo = PluginsInfo
  { pluginsInfoVolume :: !(Maybe [Text]) -- ^ "Volume" - Names of available volume-drivers, and network-driver plugins.
  , pluginsInfoNetwork :: !(Maybe [Text]) -- ^ "Network" - Names of available network-drivers, and network-driver plugins.
  , pluginsInfoAuthorization :: !(Maybe [Text]) -- ^ "Authorization" - Names of available authorization plugins.
  , pluginsInfoLog :: !(Maybe [Text]) -- ^ "Log" - Names of available logging-drivers, and logging-driver plugins.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginsInfo
instance A.FromJSON PluginsInfo where
  parseJSON = A.withObject "PluginsInfo" $ \o ->
    PluginsInfo
      <$> (o .:? "Volume")
      <*> (o .:? "Network")
      <*> (o .:? "Authorization")
      <*> (o .:? "Log")

-- | ToJSON PluginsInfo
instance A.ToJSON PluginsInfo where
  toJSON PluginsInfo {..} =
   _omitNulls
      [ "Volume" .= pluginsInfoVolume
      , "Network" .= pluginsInfoNetwork
      , "Authorization" .= pluginsInfoAuthorization
      , "Log" .= pluginsInfoLog
      ]


-- | Construct a value of type 'PluginsInfo' (by applying it's required fields, if any)
mkPluginsInfo
  :: PluginsInfo
mkPluginsInfo =
  PluginsInfo
  { pluginsInfoVolume = Nothing
  , pluginsInfoNetwork = Nothing
  , pluginsInfoAuthorization = Nothing
  , pluginsInfoLog = Nothing
  }

-- ** Port
-- | Port
-- An open port on a container
data Port = Port
  { portIp :: !(Maybe Text) -- ^ "IP"
  , portPrivatePort :: !(Int) -- ^ /Required/ "PrivatePort" - Port on the container
  , portPublicPort :: !(Maybe Int) -- ^ "PublicPort" - Port exposed on the host
  , portType :: !(E'Type) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Port
instance A.FromJSON Port where
  parseJSON = A.withObject "Port" $ \o ->
    Port
      <$> (o .:? "IP")
      <*> (o .:  "PrivatePort")
      <*> (o .:? "PublicPort")
      <*> (o .:  "Type")

-- | ToJSON Port
instance A.ToJSON Port where
  toJSON Port {..} =
   _omitNulls
      [ "IP" .= portIp
      , "PrivatePort" .= portPrivatePort
      , "PublicPort" .= portPublicPort
      , "Type" .= portType
      ]


-- | Construct a value of type 'Port' (by applying it's required fields, if any)
mkPort
  :: Int -- ^ 'portPrivatePort': Port on the container
  -> E'Type -- ^ 'portType' 
  -> Port
mkPort portPrivatePort portType =
  Port
  { portIp = Nothing
  , portPrivatePort
  , portPublicPort = Nothing
  , portType
  }

-- ** PortBinding
-- | PortBinding
-- PortBinding represents a binding between a host IP address and a host port. 
data PortBinding = PortBinding
  { portBindingHostIp :: !(Maybe Text) -- ^ "HostIp" - Host IP address that the container&#39;s port is mapped to.
  , portBindingHostPort :: !(Maybe Text) -- ^ "HostPort" - Host port number that the container&#39;s port is mapped to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortBinding
instance A.FromJSON PortBinding where
  parseJSON = A.withObject "PortBinding" $ \o ->
    PortBinding
      <$> (o .:? "HostIp")
      <*> (o .:? "HostPort")

-- | ToJSON PortBinding
instance A.ToJSON PortBinding where
  toJSON PortBinding {..} =
   _omitNulls
      [ "HostIp" .= portBindingHostIp
      , "HostPort" .= portBindingHostPort
      ]


-- | Construct a value of type 'PortBinding' (by applying it's required fields, if any)
mkPortBinding
  :: PortBinding
mkPortBinding =
  PortBinding
  { portBindingHostIp = Nothing
  , portBindingHostPort = Nothing
  }

-- ** ProcessConfig
-- | ProcessConfig
data ProcessConfig = ProcessConfig
  { processConfigPrivileged :: !(Maybe Bool) -- ^ "privileged"
  , processConfigUser :: !(Maybe Text) -- ^ "user"
  , processConfigTty :: !(Maybe Bool) -- ^ "tty"
  , processConfigEntrypoint :: !(Maybe Text) -- ^ "entrypoint"
  , processConfigArguments :: !(Maybe [Text]) -- ^ "arguments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessConfig
instance A.FromJSON ProcessConfig where
  parseJSON = A.withObject "ProcessConfig" $ \o ->
    ProcessConfig
      <$> (o .:? "privileged")
      <*> (o .:? "user")
      <*> (o .:? "tty")
      <*> (o .:? "entrypoint")
      <*> (o .:? "arguments")

-- | ToJSON ProcessConfig
instance A.ToJSON ProcessConfig where
  toJSON ProcessConfig {..} =
   _omitNulls
      [ "privileged" .= processConfigPrivileged
      , "user" .= processConfigUser
      , "tty" .= processConfigTty
      , "entrypoint" .= processConfigEntrypoint
      , "arguments" .= processConfigArguments
      ]


-- | Construct a value of type 'ProcessConfig' (by applying it's required fields, if any)
mkProcessConfig
  :: ProcessConfig
mkProcessConfig =
  ProcessConfig
  { processConfigPrivileged = Nothing
  , processConfigUser = Nothing
  , processConfigTty = Nothing
  , processConfigEntrypoint = Nothing
  , processConfigArguments = Nothing
  }

-- ** ProgressDetail
-- | ProgressDetail
data ProgressDetail = ProgressDetail
  { progressDetailCurrent :: !(Maybe Int) -- ^ "current"
  , progressDetailTotal :: !(Maybe Int) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgressDetail
instance A.FromJSON ProgressDetail where
  parseJSON = A.withObject "ProgressDetail" $ \o ->
    ProgressDetail
      <$> (o .:? "current")
      <*> (o .:? "total")

-- | ToJSON ProgressDetail
instance A.ToJSON ProgressDetail where
  toJSON ProgressDetail {..} =
   _omitNulls
      [ "current" .= progressDetailCurrent
      , "total" .= progressDetailTotal
      ]


-- | Construct a value of type 'ProgressDetail' (by applying it's required fields, if any)
mkProgressDetail
  :: ProgressDetail
mkProgressDetail =
  ProgressDetail
  { progressDetailCurrent = Nothing
  , progressDetailTotal = Nothing
  }

-- ** PushImageInfo
-- | PushImageInfo
data PushImageInfo = PushImageInfo
  { pushImageInfoError :: !(Maybe Text) -- ^ "error"
  , pushImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , pushImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , pushImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushImageInfo
instance A.FromJSON PushImageInfo where
  parseJSON = A.withObject "PushImageInfo" $ \o ->
    PushImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON PushImageInfo
instance A.ToJSON PushImageInfo where
  toJSON PushImageInfo {..} =
   _omitNulls
      [ "error" .= pushImageInfoError
      , "status" .= pushImageInfoStatus
      , "progress" .= pushImageInfoProgress
      , "progressDetail" .= pushImageInfoProgressDetail
      ]


-- | Construct a value of type 'PushImageInfo' (by applying it's required fields, if any)
mkPushImageInfo
  :: PushImageInfo
mkPushImageInfo =
  PushImageInfo
  { pushImageInfoError = Nothing
  , pushImageInfoStatus = Nothing
  , pushImageInfoProgress = Nothing
  , pushImageInfoProgressDetail = Nothing
  }

-- ** RegistryServiceConfig
-- | RegistryServiceConfig
-- RegistryServiceConfig stores daemon registry services configuration. 
data RegistryServiceConfig = RegistryServiceConfig
  { registryServiceConfigAllowNondistributableArtifactsCidrs :: !(Maybe [Text]) -- ^ "AllowNondistributableArtifactsCIDRs" - List of IP ranges to which nondistributable artifacts can be pushed, using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).  Some images (for example, Windows base images) contain artifacts whose distribution is restricted by license. When these images are pushed to a registry, restricted artifacts are not included.  This configuration override this behavior, and enables the daemon to push nondistributable artifacts to all registries whose resolved IP address is within the subnet described by the CIDR syntax.  This option is useful when pushing images containing nondistributable artifacts to a registry on an air-gapped network so hosts on that network can pull the images without connecting to another server.  &gt; **Warning**: Nondistributable artifacts typically have restrictions &gt; on how and where they can be distributed and shared. Only use this &gt; feature to push artifacts to private registries and ensure that you &gt; are in compliance with any terms that cover redistributing &gt; nondistributable artifacts. 
  , registryServiceConfigAllowNondistributableArtifactsHostnames :: !(Maybe [Text]) -- ^ "AllowNondistributableArtifactsHostnames" - List of registry hostnames to which nondistributable artifacts can be pushed, using the format &#x60;&lt;hostname&gt;[:&lt;port&gt;]&#x60; or &#x60;&lt;IP address&gt;[:&lt;port&gt;]&#x60;.  Some images (for example, Windows base images) contain artifacts whose distribution is restricted by license. When these images are pushed to a registry, restricted artifacts are not included.  This configuration override this behavior for the specified registries.  This option is useful when pushing images containing nondistributable artifacts to a registry on an air-gapped network so hosts on that network can pull the images without connecting to another server.  &gt; **Warning**: Nondistributable artifacts typically have restrictions &gt; on how and where they can be distributed and shared. Only use this &gt; feature to push artifacts to private registries and ensure that you &gt; are in compliance with any terms that cover redistributing &gt; nondistributable artifacts. 
  , registryServiceConfigInsecureRegistryCidrs :: !(Maybe [Text]) -- ^ "InsecureRegistryCIDRs" - List of IP ranges of insecure registries, using the CIDR syntax ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from unknown CAs) communication.  By default, local registries (&#x60;127.0.0.0/8&#x60;) are configured as insecure. All other registries are secure. Communicating with an insecure registry is not possible if the daemon assumes that registry is secure.  This configuration override this behavior, insecure communication with registries whose resolved IP address is within the subnet described by the CIDR syntax.  Registries can also be marked insecure by hostname. Those registries are listed under &#x60;IndexConfigs&#x60; and have their &#x60;Secure&#x60; field set to &#x60;false&#x60;.  &gt; **Warning**: Using this option can be useful when running a local &gt; registry, but introduces security vulnerabilities. This option &gt; should therefore ONLY be used for testing purposes. For increased &gt; security, users should add their CA to their system&#39;s list of trusted &gt; CAs instead of enabling this option. 
  , registryServiceConfigIndexConfigs :: !(Maybe (Map.Map String IndexInfo)) -- ^ "IndexConfigs"
  , registryServiceConfigMirrors :: !(Maybe [Text]) -- ^ "Mirrors" - List of registry URLs that act as a mirror for the official (&#x60;docker.io&#x60;) registry. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegistryServiceConfig
instance A.FromJSON RegistryServiceConfig where
  parseJSON = A.withObject "RegistryServiceConfig" $ \o ->
    RegistryServiceConfig
      <$> (o .:? "AllowNondistributableArtifactsCIDRs")
      <*> (o .:? "AllowNondistributableArtifactsHostnames")
      <*> (o .:? "InsecureRegistryCIDRs")
      <*> (o .:? "IndexConfigs")
      <*> (o .:? "Mirrors")

-- | ToJSON RegistryServiceConfig
instance A.ToJSON RegistryServiceConfig where
  toJSON RegistryServiceConfig {..} =
   _omitNulls
      [ "AllowNondistributableArtifactsCIDRs" .= registryServiceConfigAllowNondistributableArtifactsCidrs
      , "AllowNondistributableArtifactsHostnames" .= registryServiceConfigAllowNondistributableArtifactsHostnames
      , "InsecureRegistryCIDRs" .= registryServiceConfigInsecureRegistryCidrs
      , "IndexConfigs" .= registryServiceConfigIndexConfigs
      , "Mirrors" .= registryServiceConfigMirrors
      ]


-- | Construct a value of type 'RegistryServiceConfig' (by applying it's required fields, if any)
mkRegistryServiceConfig
  :: RegistryServiceConfig
mkRegistryServiceConfig =
  RegistryServiceConfig
  { registryServiceConfigAllowNondistributableArtifactsCidrs = Nothing
  , registryServiceConfigAllowNondistributableArtifactsHostnames = Nothing
  , registryServiceConfigInsecureRegistryCidrs = Nothing
  , registryServiceConfigIndexConfigs = Nothing
  , registryServiceConfigMirrors = Nothing
  }

-- ** ResourceObject
-- | ResourceObject
-- An object describing the resources which can be advertised by a node and requested by a task
data ResourceObject = ResourceObject
  { resourceObjectNanoCpus :: !(Maybe Integer) -- ^ "NanoCPUs"
  , resourceObjectMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes"
  , resourceObjectGenericResources :: !(Maybe [GenericResourcesInner]) -- ^ "GenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceObject
instance A.FromJSON ResourceObject where
  parseJSON = A.withObject "ResourceObject" $ \o ->
    ResourceObject
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")
      <*> (o .:? "GenericResources")

-- | ToJSON ResourceObject
instance A.ToJSON ResourceObject where
  toJSON ResourceObject {..} =
   _omitNulls
      [ "NanoCPUs" .= resourceObjectNanoCpus
      , "MemoryBytes" .= resourceObjectMemoryBytes
      , "GenericResources" .= resourceObjectGenericResources
      ]


-- | Construct a value of type 'ResourceObject' (by applying it's required fields, if any)
mkResourceObject
  :: ResourceObject
mkResourceObject =
  ResourceObject
  { resourceObjectNanoCpus = Nothing
  , resourceObjectMemoryBytes = Nothing
  , resourceObjectGenericResources = Nothing
  }

-- ** Resources
-- | Resources
-- A container's resources (cgroups config, ulimits, etc)
data Resources = Resources
  { resourcesCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers.
  , resourcesMemory :: !(Maybe Integer) -- ^ "Memory" - Memory limit in bytes.
  , resourcesCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist.
  , resourcesBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , resourcesBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDeviceInner]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}]&#x60;. 
  , resourcesBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form &#x60;[{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}]&#x60;. 
  , resourcesCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , resourcesCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period.
  , resourcesCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
  , resourcesCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;)
  , resourcesCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
  , resourcesDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , resourcesDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , resourcesDiskQuota :: !(Maybe Integer) -- ^ "DiskQuota" - Disk limit (in bytes).
  , resourcesKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.
  , resourcesMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , resourcesMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap.
  , resourcesMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100.
  , resourcesNanoCpus :: !(Maybe Integer) -- ^ "NanoCpus" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , resourcesOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , resourcesPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s pids limit. Set -1 for unlimited.
  , resourcesUlimits :: !(Maybe [ResourcesUlimitsInner]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  , resourcesCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , resourcesIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Resources
instance A.FromJSON Resources where
  parseJSON = A.withObject "Resources" $ \o ->
    Resources
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DiskQuota")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCpus")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")

-- | ToJSON Resources
instance A.ToJSON Resources where
  toJSON Resources {..} =
   _omitNulls
      [ "CpuShares" .= resourcesCpuShares
      , "Memory" .= resourcesMemory
      , "CgroupParent" .= resourcesCgroupParent
      , "BlkioWeight" .= resourcesBlkioWeight
      , "BlkioWeightDevice" .= resourcesBlkioWeightDevice
      , "BlkioDeviceReadBps" .= resourcesBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= resourcesBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= resourcesBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= resourcesBlkioDeviceWriteIOps
      , "CpuPeriod" .= resourcesCpuPeriod
      , "CpuQuota" .= resourcesCpuQuota
      , "CpuRealtimePeriod" .= resourcesCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= resourcesCpuRealtimeRuntime
      , "CpusetCpus" .= resourcesCpusetCpus
      , "CpusetMems" .= resourcesCpusetMems
      , "Devices" .= resourcesDevices
      , "DeviceCgroupRules" .= resourcesDeviceCgroupRules
      , "DiskQuota" .= resourcesDiskQuota
      , "KernelMemory" .= resourcesKernelMemory
      , "MemoryReservation" .= resourcesMemoryReservation
      , "MemorySwap" .= resourcesMemorySwap
      , "MemorySwappiness" .= resourcesMemorySwappiness
      , "NanoCpus" .= resourcesNanoCpus
      , "OomKillDisable" .= resourcesOomKillDisable
      , "PidsLimit" .= resourcesPidsLimit
      , "Ulimits" .= resourcesUlimits
      , "CpuCount" .= resourcesCpuCount
      , "CpuPercent" .= resourcesCpuPercent
      , "IOMaximumIOps" .= resourcesIoMaximumIOps
      , "IOMaximumBandwidth" .= resourcesIoMaximumBandwidth
      ]


-- | Construct a value of type 'Resources' (by applying it's required fields, if any)
mkResources
  :: Resources
mkResources =
  Resources
  { resourcesCpuShares = Nothing
  , resourcesMemory = Nothing
  , resourcesCgroupParent = Nothing
  , resourcesBlkioWeight = Nothing
  , resourcesBlkioWeightDevice = Nothing
  , resourcesBlkioDeviceReadBps = Nothing
  , resourcesBlkioDeviceWriteBps = Nothing
  , resourcesBlkioDeviceReadIOps = Nothing
  , resourcesBlkioDeviceWriteIOps = Nothing
  , resourcesCpuPeriod = Nothing
  , resourcesCpuQuota = Nothing
  , resourcesCpuRealtimePeriod = Nothing
  , resourcesCpuRealtimeRuntime = Nothing
  , resourcesCpusetCpus = Nothing
  , resourcesCpusetMems = Nothing
  , resourcesDevices = Nothing
  , resourcesDeviceCgroupRules = Nothing
  , resourcesDiskQuota = Nothing
  , resourcesKernelMemory = Nothing
  , resourcesMemoryReservation = Nothing
  , resourcesMemorySwap = Nothing
  , resourcesMemorySwappiness = Nothing
  , resourcesNanoCpus = Nothing
  , resourcesOomKillDisable = Nothing
  , resourcesPidsLimit = Nothing
  , resourcesUlimits = Nothing
  , resourcesCpuCount = Nothing
  , resourcesCpuPercent = Nothing
  , resourcesIoMaximumIOps = Nothing
  , resourcesIoMaximumBandwidth = Nothing
  }

-- ** ResourcesBlkioWeightDeviceInner
-- | ResourcesBlkioWeightDeviceInner
data ResourcesBlkioWeightDeviceInner = ResourcesBlkioWeightDeviceInner
  { resourcesBlkioWeightDeviceInnerPath :: !(Maybe Text) -- ^ "Path"
  , resourcesBlkioWeightDeviceInnerWeight :: !(Maybe Int) -- ^ "Weight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesBlkioWeightDeviceInner
instance A.FromJSON ResourcesBlkioWeightDeviceInner where
  parseJSON = A.withObject "ResourcesBlkioWeightDeviceInner" $ \o ->
    ResourcesBlkioWeightDeviceInner
      <$> (o .:? "Path")
      <*> (o .:? "Weight")

-- | ToJSON ResourcesBlkioWeightDeviceInner
instance A.ToJSON ResourcesBlkioWeightDeviceInner where
  toJSON ResourcesBlkioWeightDeviceInner {..} =
   _omitNulls
      [ "Path" .= resourcesBlkioWeightDeviceInnerPath
      , "Weight" .= resourcesBlkioWeightDeviceInnerWeight
      ]


-- | Construct a value of type 'ResourcesBlkioWeightDeviceInner' (by applying it's required fields, if any)
mkResourcesBlkioWeightDeviceInner
  :: ResourcesBlkioWeightDeviceInner
mkResourcesBlkioWeightDeviceInner =
  ResourcesBlkioWeightDeviceInner
  { resourcesBlkioWeightDeviceInnerPath = Nothing
  , resourcesBlkioWeightDeviceInnerWeight = Nothing
  }

-- ** ResourcesUlimitsInner
-- | ResourcesUlimitsInner
data ResourcesUlimitsInner = ResourcesUlimitsInner
  { resourcesUlimitsInnerName :: !(Maybe Text) -- ^ "Name" - Name of ulimit
  , resourcesUlimitsInnerSoft :: !(Maybe Int) -- ^ "Soft" - Soft limit
  , resourcesUlimitsInnerHard :: !(Maybe Int) -- ^ "Hard" - Hard limit
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesUlimitsInner
instance A.FromJSON ResourcesUlimitsInner where
  parseJSON = A.withObject "ResourcesUlimitsInner" $ \o ->
    ResourcesUlimitsInner
      <$> (o .:? "Name")
      <*> (o .:? "Soft")
      <*> (o .:? "Hard")

-- | ToJSON ResourcesUlimitsInner
instance A.ToJSON ResourcesUlimitsInner where
  toJSON ResourcesUlimitsInner {..} =
   _omitNulls
      [ "Name" .= resourcesUlimitsInnerName
      , "Soft" .= resourcesUlimitsInnerSoft
      , "Hard" .= resourcesUlimitsInnerHard
      ]


-- | Construct a value of type 'ResourcesUlimitsInner' (by applying it's required fields, if any)
mkResourcesUlimitsInner
  :: ResourcesUlimitsInner
mkResourcesUlimitsInner =
  ResourcesUlimitsInner
  { resourcesUlimitsInnerName = Nothing
  , resourcesUlimitsInnerSoft = Nothing
  , resourcesUlimitsInnerHard = Nothing
  }

-- ** RestartPolicy
-- | RestartPolicy
-- The behavior to apply when the container exits. The default is not to restart.  An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server. 
data RestartPolicy = RestartPolicy
  { restartPolicyName :: !(Maybe E'Name) -- ^ "Name" - - Empty string means not to restart - &#x60;always&#x60; Always restart - &#x60;unless-stopped&#x60; Restart always except when the user has manually stopped the container - &#x60;on-failure&#x60; Restart only when the container exit code is non-zero 
  , restartPolicyMaximumRetryCount :: !(Maybe Int) -- ^ "MaximumRetryCount" - If &#x60;on-failure&#x60; is used, the number of times to retry before giving up
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RestartPolicy
instance A.FromJSON RestartPolicy where
  parseJSON = A.withObject "RestartPolicy" $ \o ->
    RestartPolicy
      <$> (o .:? "Name")
      <*> (o .:? "MaximumRetryCount")

-- | ToJSON RestartPolicy
instance A.ToJSON RestartPolicy where
  toJSON RestartPolicy {..} =
   _omitNulls
      [ "Name" .= restartPolicyName
      , "MaximumRetryCount" .= restartPolicyMaximumRetryCount
      ]


-- | Construct a value of type 'RestartPolicy' (by applying it's required fields, if any)
mkRestartPolicy
  :: RestartPolicy
mkRestartPolicy =
  RestartPolicy
  { restartPolicyName = Nothing
  , restartPolicyMaximumRetryCount = Nothing
  }

-- ** Runtime
-- | Runtime
-- Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec) runtime.  The runtime is invoked by the daemon via the `containerd` daemon. OCI runtimes act as an interface to the Linux kernel namespaces, cgroups, and SELinux. 
data Runtime = Runtime
  { runtimePath :: !(Maybe Text) -- ^ "path" - Name and, optional, path, of the OCI executable binary.  If the path is omitted, the daemon searches the host&#39;s &#x60;$PATH&#x60; for the binary and uses the first result. 
  , runtimeRuntimeArgs :: !(Maybe [Text]) -- ^ "runtimeArgs" - List of command-line arguments to pass to the runtime when invoked. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Runtime
instance A.FromJSON Runtime where
  parseJSON = A.withObject "Runtime" $ \o ->
    Runtime
      <$> (o .:? "path")
      <*> (o .:? "runtimeArgs")

-- | ToJSON Runtime
instance A.ToJSON Runtime where
  toJSON Runtime {..} =
   _omitNulls
      [ "path" .= runtimePath
      , "runtimeArgs" .= runtimeRuntimeArgs
      ]


-- | Construct a value of type 'Runtime' (by applying it's required fields, if any)
mkRuntime
  :: Runtime
mkRuntime =
  Runtime
  { runtimePath = Nothing
  , runtimeRuntimeArgs = Nothing
  }

-- ** Secret
-- | Secret
data Secret = Secret
  { secretId :: !(Maybe Text) -- ^ "ID"
  , secretVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , secretCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , secretUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , secretSpec :: !(Maybe SecretSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Secret
instance A.FromJSON Secret where
  parseJSON = A.withObject "Secret" $ \o ->
    Secret
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Secret
instance A.ToJSON Secret where
  toJSON Secret {..} =
   _omitNulls
      [ "ID" .= secretId
      , "Version" .= secretVersion
      , "CreatedAt" .= secretCreatedAt
      , "UpdatedAt" .= secretUpdatedAt
      , "Spec" .= secretSpec
      ]


-- | Construct a value of type 'Secret' (by applying it's required fields, if any)
mkSecret
  :: Secret
mkSecret =
  Secret
  { secretId = Nothing
  , secretVersion = Nothing
  , secretCreatedAt = Nothing
  , secretUpdatedAt = Nothing
  , secretSpec = Nothing
  }

-- ** SecretCreateRequest
-- | SecretCreateRequest
data SecretCreateRequest = SecretCreateRequest
  { secretCreateRequestName :: !(Maybe Text) -- ^ "Name" - User-defined name of the secret.
  , secretCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , secretCreateRequestData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2)) data to store as secret.  This field is only used to _create_ a secret, and is not returned by other endpoints. 
  , secretCreateRequestDriver :: !(Maybe Driver) -- ^ "Driver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecretCreateRequest
instance A.FromJSON SecretCreateRequest where
  parseJSON = A.withObject "SecretCreateRequest" $ \o ->
    SecretCreateRequest
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")
      <*> (o .:? "Driver")

-- | ToJSON SecretCreateRequest
instance A.ToJSON SecretCreateRequest where
  toJSON SecretCreateRequest {..} =
   _omitNulls
      [ "Name" .= secretCreateRequestName
      , "Labels" .= secretCreateRequestLabels
      , "Data" .= secretCreateRequestData
      , "Driver" .= secretCreateRequestDriver
      ]


-- | Construct a value of type 'SecretCreateRequest' (by applying it's required fields, if any)
mkSecretCreateRequest
  :: SecretCreateRequest
mkSecretCreateRequest =
  SecretCreateRequest
  { secretCreateRequestName = Nothing
  , secretCreateRequestLabels = Nothing
  , secretCreateRequestData = Nothing
  , secretCreateRequestDriver = Nothing
  }

-- ** SecretSpec
-- | SecretSpec
data SecretSpec = SecretSpec
  { secretSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the secret.
  , secretSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , secretSpecData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2)) data to store as secret.  This field is only used to _create_ a secret, and is not returned by other endpoints. 
  , secretSpecDriver :: !(Maybe Driver) -- ^ "Driver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecretSpec
instance A.FromJSON SecretSpec where
  parseJSON = A.withObject "SecretSpec" $ \o ->
    SecretSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")
      <*> (o .:? "Driver")

-- | ToJSON SecretSpec
instance A.ToJSON SecretSpec where
  toJSON SecretSpec {..} =
   _omitNulls
      [ "Name" .= secretSpecName
      , "Labels" .= secretSpecLabels
      , "Data" .= secretSpecData
      , "Driver" .= secretSpecDriver
      ]


-- | Construct a value of type 'SecretSpec' (by applying it's required fields, if any)
mkSecretSpec
  :: SecretSpec
mkSecretSpec =
  SecretSpec
  { secretSpecName = Nothing
  , secretSpecLabels = Nothing
  , secretSpecData = Nothing
  , secretSpecDriver = Nothing
  }

-- ** Service
-- | Service
data Service = Service
  { serviceId :: !(Maybe Text) -- ^ "ID"
  , serviceVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , serviceCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , serviceUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , serviceSpec :: !(Maybe ServiceSpec) -- ^ "Spec"
  , serviceEndpoint :: !(Maybe ServiceEndpoint) -- ^ "Endpoint"
  , serviceUpdateStatus :: !(Maybe ServiceUpdateStatus) -- ^ "UpdateStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Service
instance A.FromJSON Service where
  parseJSON = A.withObject "Service" $ \o ->
    Service
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Endpoint")
      <*> (o .:? "UpdateStatus")

-- | ToJSON Service
instance A.ToJSON Service where
  toJSON Service {..} =
   _omitNulls
      [ "ID" .= serviceId
      , "Version" .= serviceVersion
      , "CreatedAt" .= serviceCreatedAt
      , "UpdatedAt" .= serviceUpdatedAt
      , "Spec" .= serviceSpec
      , "Endpoint" .= serviceEndpoint
      , "UpdateStatus" .= serviceUpdateStatus
      ]


-- | Construct a value of type 'Service' (by applying it's required fields, if any)
mkService
  :: Service
mkService =
  Service
  { serviceId = Nothing
  , serviceVersion = Nothing
  , serviceCreatedAt = Nothing
  , serviceUpdatedAt = Nothing
  , serviceSpec = Nothing
  , serviceEndpoint = Nothing
  , serviceUpdateStatus = Nothing
  }

-- ** ServiceCreateRequest
-- | ServiceCreateRequest
data ServiceCreateRequest = ServiceCreateRequest
  { serviceCreateRequestName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceCreateRequestTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceCreateRequestMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceCreateRequestUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceCreateRequestRollbackConfig :: !(Maybe ServiceSpecRollbackConfig) -- ^ "RollbackConfig"
  , serviceCreateRequestNetworks :: !(Maybe [TaskSpecNetworksInner]) -- ^ "Networks" - Array of network names or IDs to attach the service to.
  , serviceCreateRequestEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceCreateRequest
instance A.FromJSON ServiceCreateRequest where
  parseJSON = A.withObject "ServiceCreateRequest" $ \o ->
    ServiceCreateRequest
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "RollbackConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceCreateRequest
instance A.ToJSON ServiceCreateRequest where
  toJSON ServiceCreateRequest {..} =
   _omitNulls
      [ "Name" .= serviceCreateRequestName
      , "Labels" .= serviceCreateRequestLabels
      , "TaskTemplate" .= serviceCreateRequestTaskTemplate
      , "Mode" .= serviceCreateRequestMode
      , "UpdateConfig" .= serviceCreateRequestUpdateConfig
      , "RollbackConfig" .= serviceCreateRequestRollbackConfig
      , "Networks" .= serviceCreateRequestNetworks
      , "EndpointSpec" .= serviceCreateRequestEndpointSpec
      ]


-- | Construct a value of type 'ServiceCreateRequest' (by applying it's required fields, if any)
mkServiceCreateRequest
  :: ServiceCreateRequest
mkServiceCreateRequest =
  ServiceCreateRequest
  { serviceCreateRequestName = Nothing
  , serviceCreateRequestLabels = Nothing
  , serviceCreateRequestTaskTemplate = Nothing
  , serviceCreateRequestMode = Nothing
  , serviceCreateRequestUpdateConfig = Nothing
  , serviceCreateRequestRollbackConfig = Nothing
  , serviceCreateRequestNetworks = Nothing
  , serviceCreateRequestEndpointSpec = Nothing
  }

-- ** ServiceCreateResponse
-- | ServiceCreateResponse
-- ServiceCreateResponse
-- 
data ServiceCreateResponse = ServiceCreateResponse
  { serviceCreateResponseId :: !(Maybe Text) -- ^ "ID" - The ID of the created service.
  , serviceCreateResponseWarning :: !(Maybe Text) -- ^ "Warning" - Optional warning message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceCreateResponse
instance A.FromJSON ServiceCreateResponse where
  parseJSON = A.withObject "ServiceCreateResponse" $ \o ->
    ServiceCreateResponse
      <$> (o .:? "ID")
      <*> (o .:? "Warning")

-- | ToJSON ServiceCreateResponse
instance A.ToJSON ServiceCreateResponse where
  toJSON ServiceCreateResponse {..} =
   _omitNulls
      [ "ID" .= serviceCreateResponseId
      , "Warning" .= serviceCreateResponseWarning
      ]


-- | Construct a value of type 'ServiceCreateResponse' (by applying it's required fields, if any)
mkServiceCreateResponse
  :: ServiceCreateResponse
mkServiceCreateResponse =
  ServiceCreateResponse
  { serviceCreateResponseId = Nothing
  , serviceCreateResponseWarning = Nothing
  }

-- ** ServiceEndpoint
-- | ServiceEndpoint
data ServiceEndpoint = ServiceEndpoint
  { serviceEndpointSpec :: !(Maybe EndpointSpec) -- ^ "Spec"
  , serviceEndpointPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports"
  , serviceEndpointVirtualIps :: !(Maybe [ServiceEndpointVirtualIPsInner]) -- ^ "VirtualIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpoint
instance A.FromJSON ServiceEndpoint where
  parseJSON = A.withObject "ServiceEndpoint" $ \o ->
    ServiceEndpoint
      <$> (o .:? "Spec")
      <*> (o .:? "Ports")
      <*> (o .:? "VirtualIPs")

-- | ToJSON ServiceEndpoint
instance A.ToJSON ServiceEndpoint where
  toJSON ServiceEndpoint {..} =
   _omitNulls
      [ "Spec" .= serviceEndpointSpec
      , "Ports" .= serviceEndpointPorts
      , "VirtualIPs" .= serviceEndpointVirtualIps
      ]


-- | Construct a value of type 'ServiceEndpoint' (by applying it's required fields, if any)
mkServiceEndpoint
  :: ServiceEndpoint
mkServiceEndpoint =
  ServiceEndpoint
  { serviceEndpointSpec = Nothing
  , serviceEndpointPorts = Nothing
  , serviceEndpointVirtualIps = Nothing
  }

-- ** ServiceEndpointVirtualIPsInner
-- | ServiceEndpointVirtualIPsInner
data ServiceEndpointVirtualIPsInner = ServiceEndpointVirtualIPsInner
  { serviceEndpointVirtualIPsInnerNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , serviceEndpointVirtualIPsInnerAddr :: !(Maybe Text) -- ^ "Addr"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpointVirtualIPsInner
instance A.FromJSON ServiceEndpointVirtualIPsInner where
  parseJSON = A.withObject "ServiceEndpointVirtualIPsInner" $ \o ->
    ServiceEndpointVirtualIPsInner
      <$> (o .:? "NetworkID")
      <*> (o .:? "Addr")

-- | ToJSON ServiceEndpointVirtualIPsInner
instance A.ToJSON ServiceEndpointVirtualIPsInner where
  toJSON ServiceEndpointVirtualIPsInner {..} =
   _omitNulls
      [ "NetworkID" .= serviceEndpointVirtualIPsInnerNetworkId
      , "Addr" .= serviceEndpointVirtualIPsInnerAddr
      ]


-- | Construct a value of type 'ServiceEndpointVirtualIPsInner' (by applying it's required fields, if any)
mkServiceEndpointVirtualIPsInner
  :: ServiceEndpointVirtualIPsInner
mkServiceEndpointVirtualIPsInner =
  ServiceEndpointVirtualIPsInner
  { serviceEndpointVirtualIPsInnerNetworkId = Nothing
  , serviceEndpointVirtualIPsInnerAddr = Nothing
  }

-- ** ServiceSpec
-- | ServiceSpec
-- User modifiable configuration for a service.
data ServiceSpec = ServiceSpec
  { serviceSpecName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceSpecTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceSpecMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceSpecUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceSpecRollbackConfig :: !(Maybe ServiceSpecRollbackConfig) -- ^ "RollbackConfig"
  , serviceSpecNetworks :: !(Maybe [TaskSpecNetworksInner]) -- ^ "Networks" - Array of network names or IDs to attach the service to.
  , serviceSpecEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpec
instance A.FromJSON ServiceSpec where
  parseJSON = A.withObject "ServiceSpec" $ \o ->
    ServiceSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "RollbackConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceSpec
instance A.ToJSON ServiceSpec where
  toJSON ServiceSpec {..} =
   _omitNulls
      [ "Name" .= serviceSpecName
      , "Labels" .= serviceSpecLabels
      , "TaskTemplate" .= serviceSpecTaskTemplate
      , "Mode" .= serviceSpecMode
      , "UpdateConfig" .= serviceSpecUpdateConfig
      , "RollbackConfig" .= serviceSpecRollbackConfig
      , "Networks" .= serviceSpecNetworks
      , "EndpointSpec" .= serviceSpecEndpointSpec
      ]


-- | Construct a value of type 'ServiceSpec' (by applying it's required fields, if any)
mkServiceSpec
  :: ServiceSpec
mkServiceSpec =
  ServiceSpec
  { serviceSpecName = Nothing
  , serviceSpecLabels = Nothing
  , serviceSpecTaskTemplate = Nothing
  , serviceSpecMode = Nothing
  , serviceSpecUpdateConfig = Nothing
  , serviceSpecRollbackConfig = Nothing
  , serviceSpecNetworks = Nothing
  , serviceSpecEndpointSpec = Nothing
  }

-- ** ServiceSpecMode
-- | ServiceSpecMode
-- Scheduling mode for the service.
data ServiceSpecMode = ServiceSpecMode
  { serviceSpecModeReplicated :: !(Maybe ServiceSpecModeReplicated) -- ^ "Replicated"
  , serviceSpecModeGlobal :: !(Maybe A.Value) -- ^ "Global"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecMode
instance A.FromJSON ServiceSpecMode where
  parseJSON = A.withObject "ServiceSpecMode" $ \o ->
    ServiceSpecMode
      <$> (o .:? "Replicated")
      <*> (o .:? "Global")

-- | ToJSON ServiceSpecMode
instance A.ToJSON ServiceSpecMode where
  toJSON ServiceSpecMode {..} =
   _omitNulls
      [ "Replicated" .= serviceSpecModeReplicated
      , "Global" .= serviceSpecModeGlobal
      ]


-- | Construct a value of type 'ServiceSpecMode' (by applying it's required fields, if any)
mkServiceSpecMode
  :: ServiceSpecMode
mkServiceSpecMode =
  ServiceSpecMode
  { serviceSpecModeReplicated = Nothing
  , serviceSpecModeGlobal = Nothing
  }

-- ** ServiceSpecModeReplicated
-- | ServiceSpecModeReplicated
data ServiceSpecModeReplicated = ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas :: !(Maybe Integer) -- ^ "Replicas"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecModeReplicated
instance A.FromJSON ServiceSpecModeReplicated where
  parseJSON = A.withObject "ServiceSpecModeReplicated" $ \o ->
    ServiceSpecModeReplicated
      <$> (o .:? "Replicas")

-- | ToJSON ServiceSpecModeReplicated
instance A.ToJSON ServiceSpecModeReplicated where
  toJSON ServiceSpecModeReplicated {..} =
   _omitNulls
      [ "Replicas" .= serviceSpecModeReplicatedReplicas
      ]


-- | Construct a value of type 'ServiceSpecModeReplicated' (by applying it's required fields, if any)
mkServiceSpecModeReplicated
  :: ServiceSpecModeReplicated
mkServiceSpecModeReplicated =
  ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas = Nothing
  }

-- ** ServiceSpecRollbackConfig
-- | ServiceSpecRollbackConfig
-- Specification for the rollback strategy of the service.
data ServiceSpecRollbackConfig = ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be rolled back in one iteration (0 means unlimited parallelism).
  , serviceSpecRollbackConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between rollback iterations, in nanoseconds.
  , serviceSpecRollbackConfigFailureAction :: !(Maybe E'FailureAction2) -- ^ "FailureAction" - Action to take if an rolled back task fails to run, or stops running during the rollback.
  , serviceSpecRollbackConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each rolled back task for failures, in nanoseconds.
  , serviceSpecRollbackConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during a rollback before the failure action is invoked, specified as a floating point number between 0 and 1.
  , serviceSpecRollbackConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecRollbackConfig
instance A.FromJSON ServiceSpecRollbackConfig where
  parseJSON = A.withObject "ServiceSpecRollbackConfig" $ \o ->
    ServiceSpecRollbackConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecRollbackConfig
instance A.ToJSON ServiceSpecRollbackConfig where
  toJSON ServiceSpecRollbackConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecRollbackConfigParallelism
      , "Delay" .= serviceSpecRollbackConfigDelay
      , "FailureAction" .= serviceSpecRollbackConfigFailureAction
      , "Monitor" .= serviceSpecRollbackConfigMonitor
      , "MaxFailureRatio" .= serviceSpecRollbackConfigMaxFailureRatio
      , "Order" .= serviceSpecRollbackConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecRollbackConfig' (by applying it's required fields, if any)
mkServiceSpecRollbackConfig
  :: ServiceSpecRollbackConfig
mkServiceSpecRollbackConfig =
  ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism = Nothing
  , serviceSpecRollbackConfigDelay = Nothing
  , serviceSpecRollbackConfigFailureAction = Nothing
  , serviceSpecRollbackConfigMonitor = Nothing
  , serviceSpecRollbackConfigMaxFailureRatio = Nothing
  , serviceSpecRollbackConfigOrder = Nothing
  }

-- ** ServiceSpecUpdateConfig
-- | ServiceSpecUpdateConfig
-- Specification for the update strategy of the service.
data ServiceSpecUpdateConfig = ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism).
  , serviceSpecUpdateConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between updates, in nanoseconds.
  , serviceSpecUpdateConfigFailureAction :: !(Maybe E'FailureAction) -- ^ "FailureAction" - Action to take if an updated task fails to run, or stops running during the update.
  , serviceSpecUpdateConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each updated task for failures, in nanoseconds.
  , serviceSpecUpdateConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1.
  , serviceSpecUpdateConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecUpdateConfig
instance A.FromJSON ServiceSpecUpdateConfig where
  parseJSON = A.withObject "ServiceSpecUpdateConfig" $ \o ->
    ServiceSpecUpdateConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecUpdateConfig
instance A.ToJSON ServiceSpecUpdateConfig where
  toJSON ServiceSpecUpdateConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecUpdateConfigParallelism
      , "Delay" .= serviceSpecUpdateConfigDelay
      , "FailureAction" .= serviceSpecUpdateConfigFailureAction
      , "Monitor" .= serviceSpecUpdateConfigMonitor
      , "MaxFailureRatio" .= serviceSpecUpdateConfigMaxFailureRatio
      , "Order" .= serviceSpecUpdateConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecUpdateConfig' (by applying it's required fields, if any)
mkServiceSpecUpdateConfig
  :: ServiceSpecUpdateConfig
mkServiceSpecUpdateConfig =
  ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism = Nothing
  , serviceSpecUpdateConfigDelay = Nothing
  , serviceSpecUpdateConfigFailureAction = Nothing
  , serviceSpecUpdateConfigMonitor = Nothing
  , serviceSpecUpdateConfigMaxFailureRatio = Nothing
  , serviceSpecUpdateConfigOrder = Nothing
  }

-- ** ServiceUpdateRequest
-- | ServiceUpdateRequest
data ServiceUpdateRequest = ServiceUpdateRequest
  { serviceUpdateRequestName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceUpdateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceUpdateRequestTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceUpdateRequestMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceUpdateRequestUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceUpdateRequestRollbackConfig :: !(Maybe ServiceSpecRollbackConfig) -- ^ "RollbackConfig"
  , serviceUpdateRequestNetworks :: !(Maybe [TaskSpecNetworksInner]) -- ^ "Networks" - Array of network names or IDs to attach the service to.
  , serviceUpdateRequestEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateRequest
instance A.FromJSON ServiceUpdateRequest where
  parseJSON = A.withObject "ServiceUpdateRequest" $ \o ->
    ServiceUpdateRequest
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "RollbackConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceUpdateRequest
instance A.ToJSON ServiceUpdateRequest where
  toJSON ServiceUpdateRequest {..} =
   _omitNulls
      [ "Name" .= serviceUpdateRequestName
      , "Labels" .= serviceUpdateRequestLabels
      , "TaskTemplate" .= serviceUpdateRequestTaskTemplate
      , "Mode" .= serviceUpdateRequestMode
      , "UpdateConfig" .= serviceUpdateRequestUpdateConfig
      , "RollbackConfig" .= serviceUpdateRequestRollbackConfig
      , "Networks" .= serviceUpdateRequestNetworks
      , "EndpointSpec" .= serviceUpdateRequestEndpointSpec
      ]


-- | Construct a value of type 'ServiceUpdateRequest' (by applying it's required fields, if any)
mkServiceUpdateRequest
  :: ServiceUpdateRequest
mkServiceUpdateRequest =
  ServiceUpdateRequest
  { serviceUpdateRequestName = Nothing
  , serviceUpdateRequestLabels = Nothing
  , serviceUpdateRequestTaskTemplate = Nothing
  , serviceUpdateRequestMode = Nothing
  , serviceUpdateRequestUpdateConfig = Nothing
  , serviceUpdateRequestRollbackConfig = Nothing
  , serviceUpdateRequestNetworks = Nothing
  , serviceUpdateRequestEndpointSpec = Nothing
  }

-- ** ServiceUpdateResponse
-- | ServiceUpdateResponse
data ServiceUpdateResponse = ServiceUpdateResponse
  { serviceUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings" - Optional warning messages
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateResponse
instance A.FromJSON ServiceUpdateResponse where
  parseJSON = A.withObject "ServiceUpdateResponse" $ \o ->
    ServiceUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ServiceUpdateResponse
instance A.ToJSON ServiceUpdateResponse where
  toJSON ServiceUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= serviceUpdateResponseWarnings
      ]


-- | Construct a value of type 'ServiceUpdateResponse' (by applying it's required fields, if any)
mkServiceUpdateResponse
  :: ServiceUpdateResponse
mkServiceUpdateResponse =
  ServiceUpdateResponse
  { serviceUpdateResponseWarnings = Nothing
  }

-- ** ServiceUpdateStatus
-- | ServiceUpdateStatus
-- The status of a service update.
data ServiceUpdateStatus = ServiceUpdateStatus
  { serviceUpdateStatusState :: !(Maybe E'State) -- ^ "State"
  , serviceUpdateStatusStartedAt :: !(Maybe Text) -- ^ "StartedAt"
  , serviceUpdateStatusCompletedAt :: !(Maybe Text) -- ^ "CompletedAt"
  , serviceUpdateStatusMessage :: !(Maybe Text) -- ^ "Message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateStatus
instance A.FromJSON ServiceUpdateStatus where
  parseJSON = A.withObject "ServiceUpdateStatus" $ \o ->
    ServiceUpdateStatus
      <$> (o .:? "State")
      <*> (o .:? "StartedAt")
      <*> (o .:? "CompletedAt")
      <*> (o .:? "Message")

-- | ToJSON ServiceUpdateStatus
instance A.ToJSON ServiceUpdateStatus where
  toJSON ServiceUpdateStatus {..} =
   _omitNulls
      [ "State" .= serviceUpdateStatusState
      , "StartedAt" .= serviceUpdateStatusStartedAt
      , "CompletedAt" .= serviceUpdateStatusCompletedAt
      , "Message" .= serviceUpdateStatusMessage
      ]


-- | Construct a value of type 'ServiceUpdateStatus' (by applying it's required fields, if any)
mkServiceUpdateStatus
  :: ServiceUpdateStatus
mkServiceUpdateStatus =
  ServiceUpdateStatus
  { serviceUpdateStatusState = Nothing
  , serviceUpdateStatusStartedAt = Nothing
  , serviceUpdateStatusCompletedAt = Nothing
  , serviceUpdateStatusMessage = Nothing
  }

-- ** Swarm
-- | Swarm
data Swarm = Swarm
  { swarmId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , swarmVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , swarmCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the swarm was initialised in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , swarmUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the swarm was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , swarmSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  , swarmTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  , swarmRootRotationInProgress :: !(Maybe Bool) -- ^ "RootRotationInProgress" - Whether there is currently a root CA rotation in progress for the swarm
  , swarmJoinTokens :: !(Maybe JoinTokens) -- ^ "JoinTokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Swarm
instance A.FromJSON Swarm where
  parseJSON = A.withObject "Swarm" $ \o ->
    Swarm
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "TLSInfo")
      <*> (o .:? "RootRotationInProgress")
      <*> (o .:? "JoinTokens")

-- | ToJSON Swarm
instance A.ToJSON Swarm where
  toJSON Swarm {..} =
   _omitNulls
      [ "ID" .= swarmId
      , "Version" .= swarmVersion
      , "CreatedAt" .= swarmCreatedAt
      , "UpdatedAt" .= swarmUpdatedAt
      , "Spec" .= swarmSpec
      , "TLSInfo" .= swarmTlsInfo
      , "RootRotationInProgress" .= swarmRootRotationInProgress
      , "JoinTokens" .= swarmJoinTokens
      ]


-- | Construct a value of type 'Swarm' (by applying it's required fields, if any)
mkSwarm
  :: Swarm
mkSwarm =
  Swarm
  { swarmId = Nothing
  , swarmVersion = Nothing
  , swarmCreatedAt = Nothing
  , swarmUpdatedAt = Nothing
  , swarmSpec = Nothing
  , swarmTlsInfo = Nothing
  , swarmRootRotationInProgress = Nothing
  , swarmJoinTokens = Nothing
  }

-- ** SwarmInfo
-- | SwarmInfo
-- Represents generic information about swarm. 
data SwarmInfo = SwarmInfo
  { swarmInfoNodeId :: !(Maybe Text) -- ^ "NodeID" - Unique identifier of for this node in the swarm.
  , swarmInfoNodeAddr :: !(Maybe Text) -- ^ "NodeAddr" - IP address at which this node can be reached by other nodes in the swarm. 
  , swarmInfoLocalNodeState :: !(Maybe LocalNodeState) -- ^ "LocalNodeState"
  , swarmInfoControlAvailable :: !(Maybe Bool) -- ^ "ControlAvailable"
  , swarmInfoError :: !(Maybe Text) -- ^ "Error"
  , swarmInfoRemoteManagers :: !(Maybe [PeerNode]) -- ^ "RemoteManagers" - List of ID&#39;s and addresses of other managers in the swarm. 
  , swarmInfoNodes :: !(Maybe Int) -- ^ "Nodes" - Total number of nodes in the swarm.
  , swarmInfoManagers :: !(Maybe Int) -- ^ "Managers" - Total number of managers in the swarm.
  , swarmInfoCluster :: !(Maybe ClusterInfo) -- ^ "Cluster"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmInfo
instance A.FromJSON SwarmInfo where
  parseJSON = A.withObject "SwarmInfo" $ \o ->
    SwarmInfo
      <$> (o .:? "NodeID")
      <*> (o .:? "NodeAddr")
      <*> (o .:? "LocalNodeState")
      <*> (o .:? "ControlAvailable")
      <*> (o .:? "Error")
      <*> (o .:? "RemoteManagers")
      <*> (o .:? "Nodes")
      <*> (o .:? "Managers")
      <*> (o .:? "Cluster")

-- | ToJSON SwarmInfo
instance A.ToJSON SwarmInfo where
  toJSON SwarmInfo {..} =
   _omitNulls
      [ "NodeID" .= swarmInfoNodeId
      , "NodeAddr" .= swarmInfoNodeAddr
      , "LocalNodeState" .= swarmInfoLocalNodeState
      , "ControlAvailable" .= swarmInfoControlAvailable
      , "Error" .= swarmInfoError
      , "RemoteManagers" .= swarmInfoRemoteManagers
      , "Nodes" .= swarmInfoNodes
      , "Managers" .= swarmInfoManagers
      , "Cluster" .= swarmInfoCluster
      ]


-- | Construct a value of type 'SwarmInfo' (by applying it's required fields, if any)
mkSwarmInfo
  :: SwarmInfo
mkSwarmInfo =
  SwarmInfo
  { swarmInfoNodeId = Nothing
  , swarmInfoNodeAddr = Nothing
  , swarmInfoLocalNodeState = Nothing
  , swarmInfoControlAvailable = Nothing
  , swarmInfoError = Nothing
  , swarmInfoRemoteManagers = Nothing
  , swarmInfoNodes = Nothing
  , swarmInfoManagers = Nothing
  , swarmInfoCluster = Nothing
  }

-- ** SwarmInitRequest
-- | SwarmInitRequest
data SwarmInitRequest = SwarmInitRequest
  { swarmInitRequestListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the default swarm listening port is used.
  , swarmInitRequestAdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , swarmInitRequestDataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same address as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , swarmInitRequestForceNewCluster :: !(Maybe Bool) -- ^ "ForceNewCluster" - Force creation of a new swarm.
  , swarmInitRequestSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmInitRequest
instance A.FromJSON SwarmInitRequest where
  parseJSON = A.withObject "SwarmInitRequest" $ \o ->
    SwarmInitRequest
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "ForceNewCluster")
      <*> (o .:? "Spec")

-- | ToJSON SwarmInitRequest
instance A.ToJSON SwarmInitRequest where
  toJSON SwarmInitRequest {..} =
   _omitNulls
      [ "ListenAddr" .= swarmInitRequestListenAddr
      , "AdvertiseAddr" .= swarmInitRequestAdvertiseAddr
      , "DataPathAddr" .= swarmInitRequestDataPathAddr
      , "ForceNewCluster" .= swarmInitRequestForceNewCluster
      , "Spec" .= swarmInitRequestSpec
      ]


-- | Construct a value of type 'SwarmInitRequest' (by applying it's required fields, if any)
mkSwarmInitRequest
  :: SwarmInitRequest
mkSwarmInitRequest =
  SwarmInitRequest
  { swarmInitRequestListenAddr = Nothing
  , swarmInitRequestAdvertiseAddr = Nothing
  , swarmInitRequestDataPathAddr = Nothing
  , swarmInitRequestForceNewCluster = Nothing
  , swarmInitRequestSpec = Nothing
  }

-- ** SwarmJoinRequest
-- | SwarmJoinRequest
data SwarmJoinRequest = SwarmJoinRequest
  { swarmJoinRequestListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
  , swarmJoinRequestAdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible.
  , swarmJoinRequestDataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same address as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , swarmJoinRequestRemoteAddrs :: !(Maybe Text) -- ^ "RemoteAddrs" - Addresses of manager nodes already participating in the swarm.
  , swarmJoinRequestJoinToken :: !(Maybe Text) -- ^ "JoinToken" - Secret token for joining this swarm.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmJoinRequest
instance A.FromJSON SwarmJoinRequest where
  parseJSON = A.withObject "SwarmJoinRequest" $ \o ->
    SwarmJoinRequest
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "RemoteAddrs")
      <*> (o .:? "JoinToken")

-- | ToJSON SwarmJoinRequest
instance A.ToJSON SwarmJoinRequest where
  toJSON SwarmJoinRequest {..} =
   _omitNulls
      [ "ListenAddr" .= swarmJoinRequestListenAddr
      , "AdvertiseAddr" .= swarmJoinRequestAdvertiseAddr
      , "DataPathAddr" .= swarmJoinRequestDataPathAddr
      , "RemoteAddrs" .= swarmJoinRequestRemoteAddrs
      , "JoinToken" .= swarmJoinRequestJoinToken
      ]


-- | Construct a value of type 'SwarmJoinRequest' (by applying it's required fields, if any)
mkSwarmJoinRequest
  :: SwarmJoinRequest
mkSwarmJoinRequest =
  SwarmJoinRequest
  { swarmJoinRequestListenAddr = Nothing
  , swarmJoinRequestAdvertiseAddr = Nothing
  , swarmJoinRequestDataPathAddr = Nothing
  , swarmJoinRequestRemoteAddrs = Nothing
  , swarmJoinRequestJoinToken = Nothing
  }

-- ** SwarmSpec
-- | SwarmSpec
-- User modifiable swarm configuration.
data SwarmSpec = SwarmSpec
  { swarmSpecName :: !(Maybe Text) -- ^ "Name" - Name of the swarm.
  , swarmSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , swarmSpecOrchestration :: !(Maybe SwarmSpecOrchestration) -- ^ "Orchestration"
  , swarmSpecRaft :: !(Maybe SwarmSpecRaft) -- ^ "Raft"
  , swarmSpecDispatcher :: !(Maybe SwarmSpecDispatcher) -- ^ "Dispatcher"
  , swarmSpecCaConfig :: !(Maybe SwarmSpecCAConfig) -- ^ "CAConfig"
  , swarmSpecEncryptionConfig :: !(Maybe SwarmSpecEncryptionConfig) -- ^ "EncryptionConfig"
  , swarmSpecTaskDefaults :: !(Maybe SwarmSpecTaskDefaults) -- ^ "TaskDefaults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpec
instance A.FromJSON SwarmSpec where
  parseJSON = A.withObject "SwarmSpec" $ \o ->
    SwarmSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Orchestration")
      <*> (o .:? "Raft")
      <*> (o .:? "Dispatcher")
      <*> (o .:? "CAConfig")
      <*> (o .:? "EncryptionConfig")
      <*> (o .:? "TaskDefaults")

-- | ToJSON SwarmSpec
instance A.ToJSON SwarmSpec where
  toJSON SwarmSpec {..} =
   _omitNulls
      [ "Name" .= swarmSpecName
      , "Labels" .= swarmSpecLabels
      , "Orchestration" .= swarmSpecOrchestration
      , "Raft" .= swarmSpecRaft
      , "Dispatcher" .= swarmSpecDispatcher
      , "CAConfig" .= swarmSpecCaConfig
      , "EncryptionConfig" .= swarmSpecEncryptionConfig
      , "TaskDefaults" .= swarmSpecTaskDefaults
      ]


-- | Construct a value of type 'SwarmSpec' (by applying it's required fields, if any)
mkSwarmSpec
  :: SwarmSpec
mkSwarmSpec =
  SwarmSpec
  { swarmSpecName = Nothing
  , swarmSpecLabels = Nothing
  , swarmSpecOrchestration = Nothing
  , swarmSpecRaft = Nothing
  , swarmSpecDispatcher = Nothing
  , swarmSpecCaConfig = Nothing
  , swarmSpecEncryptionConfig = Nothing
  , swarmSpecTaskDefaults = Nothing
  }

-- ** SwarmSpecCAConfig
-- | SwarmSpecCAConfig
-- CA configuration.
data SwarmSpecCAConfig = SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry :: !(Maybe Integer) -- ^ "NodeCertExpiry" - The duration node certificates are issued for.
  , swarmSpecCAConfigExternalCas :: !(Maybe [SwarmSpecCAConfigExternalCAsInner]) -- ^ "ExternalCAs" - Configuration for forwarding signing requests to an external certificate authority.
  , swarmSpecCAConfigSigningCaCert :: !(Maybe Text) -- ^ "SigningCACert" - The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.
  , swarmSpecCAConfigSigningCaKey :: !(Maybe Text) -- ^ "SigningCAKey" - The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.
  , swarmSpecCAConfigForceRotate :: !(Maybe Int) -- ^ "ForceRotate" - An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in &#x60;SigningCACert&#x60; and &#x60;SigningCAKey&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfig
instance A.FromJSON SwarmSpecCAConfig where
  parseJSON = A.withObject "SwarmSpecCAConfig" $ \o ->
    SwarmSpecCAConfig
      <$> (o .:? "NodeCertExpiry")
      <*> (o .:? "ExternalCAs")
      <*> (o .:? "SigningCACert")
      <*> (o .:? "SigningCAKey")
      <*> (o .:? "ForceRotate")

-- | ToJSON SwarmSpecCAConfig
instance A.ToJSON SwarmSpecCAConfig where
  toJSON SwarmSpecCAConfig {..} =
   _omitNulls
      [ "NodeCertExpiry" .= swarmSpecCAConfigNodeCertExpiry
      , "ExternalCAs" .= swarmSpecCAConfigExternalCas
      , "SigningCACert" .= swarmSpecCAConfigSigningCaCert
      , "SigningCAKey" .= swarmSpecCAConfigSigningCaKey
      , "ForceRotate" .= swarmSpecCAConfigForceRotate
      ]


-- | Construct a value of type 'SwarmSpecCAConfig' (by applying it's required fields, if any)
mkSwarmSpecCAConfig
  :: SwarmSpecCAConfig
mkSwarmSpecCAConfig =
  SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry = Nothing
  , swarmSpecCAConfigExternalCas = Nothing
  , swarmSpecCAConfigSigningCaCert = Nothing
  , swarmSpecCAConfigSigningCaKey = Nothing
  , swarmSpecCAConfigForceRotate = Nothing
  }

-- ** SwarmSpecCAConfigExternalCAsInner
-- | SwarmSpecCAConfigExternalCAsInner
data SwarmSpecCAConfigExternalCAsInner = SwarmSpecCAConfigExternalCAsInner
  { swarmSpecCAConfigExternalCAsInnerProtocol :: !(Maybe E'Protocol) -- ^ "Protocol" - Protocol for communication with the external CA (currently only &#x60;cfssl&#x60; is supported).
  , swarmSpecCAConfigExternalCAsInnerUrl :: !(Maybe Text) -- ^ "URL" - URL where certificate signing requests should be sent.
  , swarmSpecCAConfigExternalCAsInnerOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.
  , swarmSpecCAConfigExternalCAsInnerCaCert :: !(Maybe Text) -- ^ "CACert" - The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfigExternalCAsInner
instance A.FromJSON SwarmSpecCAConfigExternalCAsInner where
  parseJSON = A.withObject "SwarmSpecCAConfigExternalCAsInner" $ \o ->
    SwarmSpecCAConfigExternalCAsInner
      <$> (o .:? "Protocol")
      <*> (o .:? "URL")
      <*> (o .:? "Options")
      <*> (o .:? "CACert")

-- | ToJSON SwarmSpecCAConfigExternalCAsInner
instance A.ToJSON SwarmSpecCAConfigExternalCAsInner where
  toJSON SwarmSpecCAConfigExternalCAsInner {..} =
   _omitNulls
      [ "Protocol" .= swarmSpecCAConfigExternalCAsInnerProtocol
      , "URL" .= swarmSpecCAConfigExternalCAsInnerUrl
      , "Options" .= swarmSpecCAConfigExternalCAsInnerOptions
      , "CACert" .= swarmSpecCAConfigExternalCAsInnerCaCert
      ]


-- | Construct a value of type 'SwarmSpecCAConfigExternalCAsInner' (by applying it's required fields, if any)
mkSwarmSpecCAConfigExternalCAsInner
  :: SwarmSpecCAConfigExternalCAsInner
mkSwarmSpecCAConfigExternalCAsInner =
  SwarmSpecCAConfigExternalCAsInner
  { swarmSpecCAConfigExternalCAsInnerProtocol = Nothing
  , swarmSpecCAConfigExternalCAsInnerUrl = Nothing
  , swarmSpecCAConfigExternalCAsInnerOptions = Nothing
  , swarmSpecCAConfigExternalCAsInnerCaCert = Nothing
  }

-- ** SwarmSpecDispatcher
-- | SwarmSpecDispatcher
-- Dispatcher configuration.
data SwarmSpecDispatcher = SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod :: !(Maybe Integer) -- ^ "HeartbeatPeriod" - The delay for an agent to send a heartbeat to the dispatcher.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecDispatcher
instance A.FromJSON SwarmSpecDispatcher where
  parseJSON = A.withObject "SwarmSpecDispatcher" $ \o ->
    SwarmSpecDispatcher
      <$> (o .:? "HeartbeatPeriod")

-- | ToJSON SwarmSpecDispatcher
instance A.ToJSON SwarmSpecDispatcher where
  toJSON SwarmSpecDispatcher {..} =
   _omitNulls
      [ "HeartbeatPeriod" .= swarmSpecDispatcherHeartbeatPeriod
      ]


-- | Construct a value of type 'SwarmSpecDispatcher' (by applying it's required fields, if any)
mkSwarmSpecDispatcher
  :: SwarmSpecDispatcher
mkSwarmSpecDispatcher =
  SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod = Nothing
  }

-- ** SwarmSpecEncryptionConfig
-- | SwarmSpecEncryptionConfig
-- Parameters related to encryption-at-rest.
data SwarmSpecEncryptionConfig = SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers :: !(Maybe Bool) -- ^ "AutoLockManagers" - If set, generate a key and use it to lock data stored on the managers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecEncryptionConfig
instance A.FromJSON SwarmSpecEncryptionConfig where
  parseJSON = A.withObject "SwarmSpecEncryptionConfig" $ \o ->
    SwarmSpecEncryptionConfig
      <$> (o .:? "AutoLockManagers")

-- | ToJSON SwarmSpecEncryptionConfig
instance A.ToJSON SwarmSpecEncryptionConfig where
  toJSON SwarmSpecEncryptionConfig {..} =
   _omitNulls
      [ "AutoLockManagers" .= swarmSpecEncryptionConfigAutoLockManagers
      ]


-- | Construct a value of type 'SwarmSpecEncryptionConfig' (by applying it's required fields, if any)
mkSwarmSpecEncryptionConfig
  :: SwarmSpecEncryptionConfig
mkSwarmSpecEncryptionConfig =
  SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers = Nothing
  }

-- ** SwarmSpecOrchestration
-- | SwarmSpecOrchestration
-- Orchestration configuration.
data SwarmSpecOrchestration = SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit :: !(Maybe Integer) -- ^ "TaskHistoryRetentionLimit" - The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecOrchestration
instance A.FromJSON SwarmSpecOrchestration where
  parseJSON = A.withObject "SwarmSpecOrchestration" $ \o ->
    SwarmSpecOrchestration
      <$> (o .:? "TaskHistoryRetentionLimit")

-- | ToJSON SwarmSpecOrchestration
instance A.ToJSON SwarmSpecOrchestration where
  toJSON SwarmSpecOrchestration {..} =
   _omitNulls
      [ "TaskHistoryRetentionLimit" .= swarmSpecOrchestrationTaskHistoryRetentionLimit
      ]


-- | Construct a value of type 'SwarmSpecOrchestration' (by applying it's required fields, if any)
mkSwarmSpecOrchestration
  :: SwarmSpecOrchestration
mkSwarmSpecOrchestration =
  SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit = Nothing
  }

-- ** SwarmSpecRaft
-- | SwarmSpecRaft
-- Raft configuration.
data SwarmSpecRaft = SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval :: !(Maybe Int) -- ^ "SnapshotInterval" - The number of log entries between snapshots.
  , swarmSpecRaftKeepOldSnapshots :: !(Maybe Int) -- ^ "KeepOldSnapshots" - The number of snapshots to keep beyond the current snapshot.
  , swarmSpecRaftLogEntriesForSlowFollowers :: !(Maybe Int) -- ^ "LogEntriesForSlowFollowers" - The number of log entries to keep around to sync up slow followers after a snapshot is created.
  , swarmSpecRaftElectionTick :: !(Maybe Int) -- ^ "ElectionTick" - The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. &#x60;ElectionTick&#x60; must be greater than &#x60;HeartbeatTick&#x60;.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  , swarmSpecRaftHeartbeatTick :: !(Maybe Int) -- ^ "HeartbeatTick" - The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecRaft
instance A.FromJSON SwarmSpecRaft where
  parseJSON = A.withObject "SwarmSpecRaft" $ \o ->
    SwarmSpecRaft
      <$> (o .:? "SnapshotInterval")
      <*> (o .:? "KeepOldSnapshots")
      <*> (o .:? "LogEntriesForSlowFollowers")
      <*> (o .:? "ElectionTick")
      <*> (o .:? "HeartbeatTick")

-- | ToJSON SwarmSpecRaft
instance A.ToJSON SwarmSpecRaft where
  toJSON SwarmSpecRaft {..} =
   _omitNulls
      [ "SnapshotInterval" .= swarmSpecRaftSnapshotInterval
      , "KeepOldSnapshots" .= swarmSpecRaftKeepOldSnapshots
      , "LogEntriesForSlowFollowers" .= swarmSpecRaftLogEntriesForSlowFollowers
      , "ElectionTick" .= swarmSpecRaftElectionTick
      , "HeartbeatTick" .= swarmSpecRaftHeartbeatTick
      ]


-- | Construct a value of type 'SwarmSpecRaft' (by applying it's required fields, if any)
mkSwarmSpecRaft
  :: SwarmSpecRaft
mkSwarmSpecRaft =
  SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval = Nothing
  , swarmSpecRaftKeepOldSnapshots = Nothing
  , swarmSpecRaftLogEntriesForSlowFollowers = Nothing
  , swarmSpecRaftElectionTick = Nothing
  , swarmSpecRaftHeartbeatTick = Nothing
  }

-- ** SwarmSpecTaskDefaults
-- | SwarmSpecTaskDefaults
-- Defaults for creating tasks in this cluster.
data SwarmSpecTaskDefaults = SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver :: !(Maybe SwarmSpecTaskDefaultsLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaults
instance A.FromJSON SwarmSpecTaskDefaults where
  parseJSON = A.withObject "SwarmSpecTaskDefaults" $ \o ->
    SwarmSpecTaskDefaults
      <$> (o .:? "LogDriver")

-- | ToJSON SwarmSpecTaskDefaults
instance A.ToJSON SwarmSpecTaskDefaults where
  toJSON SwarmSpecTaskDefaults {..} =
   _omitNulls
      [ "LogDriver" .= swarmSpecTaskDefaultsLogDriver
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaults' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaults
  :: SwarmSpecTaskDefaults
mkSwarmSpecTaskDefaults =
  SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver = Nothing
  }

-- ** SwarmSpecTaskDefaultsLogDriver
-- | SwarmSpecTaskDefaultsLogDriver
-- The log driver to use for tasks created in the orchestrator if unspecified by a service.  Updating this value only affects new tasks. Existing tasks continue to use their previously configured log driver until recreated. 
data SwarmSpecTaskDefaultsLogDriver = SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName :: !(Maybe Text) -- ^ "Name" - The log driver to use as a default for new tasks. 
  , swarmSpecTaskDefaultsLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Driver-specific options for the selectd log driver, specified as key/value pairs. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaultsLogDriver
instance A.FromJSON SwarmSpecTaskDefaultsLogDriver where
  parseJSON = A.withObject "SwarmSpecTaskDefaultsLogDriver" $ \o ->
    SwarmSpecTaskDefaultsLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON SwarmSpecTaskDefaultsLogDriver
instance A.ToJSON SwarmSpecTaskDefaultsLogDriver where
  toJSON SwarmSpecTaskDefaultsLogDriver {..} =
   _omitNulls
      [ "Name" .= swarmSpecTaskDefaultsLogDriverName
      , "Options" .= swarmSpecTaskDefaultsLogDriverOptions
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaultsLogDriver' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaultsLogDriver
  :: SwarmSpecTaskDefaultsLogDriver
mkSwarmSpecTaskDefaultsLogDriver =
  SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName = Nothing
  , swarmSpecTaskDefaultsLogDriverOptions = Nothing
  }

-- ** SwarmUnlockRequest
-- | SwarmUnlockRequest
data SwarmUnlockRequest = SwarmUnlockRequest
  { swarmUnlockRequestUnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmUnlockRequest
instance A.FromJSON SwarmUnlockRequest where
  parseJSON = A.withObject "SwarmUnlockRequest" $ \o ->
    SwarmUnlockRequest
      <$> (o .:? "UnlockKey")

-- | ToJSON SwarmUnlockRequest
instance A.ToJSON SwarmUnlockRequest where
  toJSON SwarmUnlockRequest {..} =
   _omitNulls
      [ "UnlockKey" .= swarmUnlockRequestUnlockKey
      ]


-- | Construct a value of type 'SwarmUnlockRequest' (by applying it's required fields, if any)
mkSwarmUnlockRequest
  :: SwarmUnlockRequest
mkSwarmUnlockRequest =
  SwarmUnlockRequest
  { swarmUnlockRequestUnlockKey = Nothing
  }

-- ** SystemAuthResponse
-- | SystemAuthResponse
-- SystemAuthResponse
-- 
data SystemAuthResponse = SystemAuthResponse
  { systemAuthResponseStatus :: !(Text) -- ^ /Required/ "Status" - The status of the authentication
  , systemAuthResponseIdentityToken :: !(Maybe Text) -- ^ "IdentityToken" - An opaque token used to authenticate a user after a successful login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemAuthResponse
instance A.FromJSON SystemAuthResponse where
  parseJSON = A.withObject "SystemAuthResponse" $ \o ->
    SystemAuthResponse
      <$> (o .:  "Status")
      <*> (o .:? "IdentityToken")

-- | ToJSON SystemAuthResponse
instance A.ToJSON SystemAuthResponse where
  toJSON SystemAuthResponse {..} =
   _omitNulls
      [ "Status" .= systemAuthResponseStatus
      , "IdentityToken" .= systemAuthResponseIdentityToken
      ]


-- | Construct a value of type 'SystemAuthResponse' (by applying it's required fields, if any)
mkSystemAuthResponse
  :: Text -- ^ 'systemAuthResponseStatus': The status of the authentication
  -> SystemAuthResponse
mkSystemAuthResponse systemAuthResponseStatus =
  SystemAuthResponse
  { systemAuthResponseStatus
  , systemAuthResponseIdentityToken = Nothing
  }

-- ** SystemDataUsageResponse
-- | SystemDataUsageResponse
-- SystemDataUsageResponse
-- 
data SystemDataUsageResponse = SystemDataUsageResponse
  { systemDataUsageResponseLayersSize :: !(Maybe Integer) -- ^ "LayersSize"
  , systemDataUsageResponseImages :: !(Maybe [ImageSummary]) -- ^ "Images"
  , systemDataUsageResponseContainers :: !(Maybe [ContainerSummary]) -- ^ "Containers"
  , systemDataUsageResponseVolumes :: !(Maybe [Volume]) -- ^ "Volumes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemDataUsageResponse
instance A.FromJSON SystemDataUsageResponse where
  parseJSON = A.withObject "SystemDataUsageResponse" $ \o ->
    SystemDataUsageResponse
      <$> (o .:? "LayersSize")
      <*> (o .:? "Images")
      <*> (o .:? "Containers")
      <*> (o .:? "Volumes")

-- | ToJSON SystemDataUsageResponse
instance A.ToJSON SystemDataUsageResponse where
  toJSON SystemDataUsageResponse {..} =
   _omitNulls
      [ "LayersSize" .= systemDataUsageResponseLayersSize
      , "Images" .= systemDataUsageResponseImages
      , "Containers" .= systemDataUsageResponseContainers
      , "Volumes" .= systemDataUsageResponseVolumes
      ]


-- | Construct a value of type 'SystemDataUsageResponse' (by applying it's required fields, if any)
mkSystemDataUsageResponse
  :: SystemDataUsageResponse
mkSystemDataUsageResponse =
  SystemDataUsageResponse
  { systemDataUsageResponseLayersSize = Nothing
  , systemDataUsageResponseImages = Nothing
  , systemDataUsageResponseContainers = Nothing
  , systemDataUsageResponseVolumes = Nothing
  }

-- ** SystemEventsResponse
-- | SystemEventsResponse
-- SystemEventsResponse
-- 
data SystemEventsResponse = SystemEventsResponse
  { systemEventsResponseType :: !(Maybe Text) -- ^ "Type" - The type of object emitting the event
  , systemEventsResponseAction :: !(Maybe Text) -- ^ "Action" - The type of event
  , systemEventsResponseActor :: !(Maybe SystemEventsResponseActor) -- ^ "Actor"
  , systemEventsResponseTime :: !(Maybe Int) -- ^ "time" - Timestamp of event
  , systemEventsResponseTimeNano :: !(Maybe Integer) -- ^ "timeNano" - Timestamp of event, with nanosecond accuracy
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemEventsResponse
instance A.FromJSON SystemEventsResponse where
  parseJSON = A.withObject "SystemEventsResponse" $ \o ->
    SystemEventsResponse
      <$> (o .:? "Type")
      <*> (o .:? "Action")
      <*> (o .:? "Actor")
      <*> (o .:? "time")
      <*> (o .:? "timeNano")

-- | ToJSON SystemEventsResponse
instance A.ToJSON SystemEventsResponse where
  toJSON SystemEventsResponse {..} =
   _omitNulls
      [ "Type" .= systemEventsResponseType
      , "Action" .= systemEventsResponseAction
      , "Actor" .= systemEventsResponseActor
      , "time" .= systemEventsResponseTime
      , "timeNano" .= systemEventsResponseTimeNano
      ]


-- | Construct a value of type 'SystemEventsResponse' (by applying it's required fields, if any)
mkSystemEventsResponse
  :: SystemEventsResponse
mkSystemEventsResponse =
  SystemEventsResponse
  { systemEventsResponseType = Nothing
  , systemEventsResponseAction = Nothing
  , systemEventsResponseActor = Nothing
  , systemEventsResponseTime = Nothing
  , systemEventsResponseTimeNano = Nothing
  }

-- ** SystemEventsResponseActor
-- | SystemEventsResponseActor
data SystemEventsResponseActor = SystemEventsResponseActor
  { systemEventsResponseActorId :: !(Maybe Text) -- ^ "ID" - The ID of the object emitting the event
  , systemEventsResponseActorAttributes :: !(Maybe (Map.Map String Text)) -- ^ "Attributes" - Various key/value attributes of the object, depending on its type
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemEventsResponseActor
instance A.FromJSON SystemEventsResponseActor where
  parseJSON = A.withObject "SystemEventsResponseActor" $ \o ->
    SystemEventsResponseActor
      <$> (o .:? "ID")
      <*> (o .:? "Attributes")

-- | ToJSON SystemEventsResponseActor
instance A.ToJSON SystemEventsResponseActor where
  toJSON SystemEventsResponseActor {..} =
   _omitNulls
      [ "ID" .= systemEventsResponseActorId
      , "Attributes" .= systemEventsResponseActorAttributes
      ]


-- | Construct a value of type 'SystemEventsResponseActor' (by applying it's required fields, if any)
mkSystemEventsResponseActor
  :: SystemEventsResponseActor
mkSystemEventsResponseActor =
  SystemEventsResponseActor
  { systemEventsResponseActorId = Nothing
  , systemEventsResponseActorAttributes = Nothing
  }

-- ** SystemInfo
-- | SystemInfo
data SystemInfo = SystemInfo
  { systemInfoId :: !(Maybe Text) -- ^ "ID" - Unique identifier of the daemon.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The format of the ID itself is not part of the API, and &gt; should not be considered stable. 
  , systemInfoContainers :: !(Maybe Int) -- ^ "Containers" - Total number of containers on the host.
  , systemInfoContainersRunning :: !(Maybe Int) -- ^ "ContainersRunning" - Number of containers with status &#x60;\&quot;running\&quot;&#x60;. 
  , systemInfoContainersPaused :: !(Maybe Int) -- ^ "ContainersPaused" - Number of containers with status &#x60;\&quot;paused\&quot;&#x60;. 
  , systemInfoContainersStopped :: !(Maybe Int) -- ^ "ContainersStopped" - Number of containers with status &#x60;\&quot;stopped\&quot;&#x60;. 
  , systemInfoImages :: !(Maybe Int) -- ^ "Images" - Total number of images on the host.  Both _tagged_ and _untagged_ (dangling) images are counted. 
  , systemInfoDriver :: !(Maybe Text) -- ^ "Driver" - Name of the storage driver in use.
  , systemInfoDriverStatus :: !(Maybe [[Text]]) -- ^ "DriverStatus" - Information specific to the storage driver, provided as \&quot;label\&quot; / \&quot;value\&quot; pairs.  This information is provided by the storage driver, and formatted in a way consistent with the output of &#x60;docker info&#x60; on the command line.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The information returned in this field, including the &gt; formatting of values and labels, should not be considered stable, &gt; and may change without notice. 
  , systemInfoDockerRootDir :: !(Maybe Text) -- ^ "DockerRootDir" - Root directory of persistent Docker state.  Defaults to &#x60;/var/lib/docker&#x60; on Linux, and &#x60;C:\\ProgramData\\docker&#x60; on Windows. 
  , systemInfoSystemStatus :: !(Maybe [[Text]]) -- ^ "SystemStatus" - Status information about this node (standalone Swarm API).  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The information returned in this field is only propagated &gt; by the Swarm standalone API, and is empty (&#x60;null&#x60;) when using &gt; built-in swarm mode. 
  , systemInfoPlugins :: !(Maybe PluginsInfo) -- ^ "Plugins"
  , systemInfoMemoryLimit :: !(Maybe Bool) -- ^ "MemoryLimit" - Indicates if the host has memory limit support enabled.
  , systemInfoSwapLimit :: !(Maybe Bool) -- ^ "SwapLimit" - Indicates if the host has memory swap limit support enabled.
  , systemInfoKernelMemory :: !(Maybe Bool) -- ^ "KernelMemory" - Indicates if the host has kernel memory limit support enabled.
  , systemInfoCpuCfsPeriod :: !(Maybe Bool) -- ^ "CpuCfsPeriod" - Indicates if CPU CFS(Completely Fair Scheduler) period is supported by the host.
  , systemInfoCpuCfsQuota :: !(Maybe Bool) -- ^ "CpuCfsQuota" - Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by the host.
  , systemInfoCpuShares :: !(Maybe Bool) -- ^ "CPUShares" - Indicates if CPU Shares limiting is supported by the host.
  , systemInfoCpuSet :: !(Maybe Bool) -- ^ "CPUSet" - Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.  See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt) 
  , systemInfoOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Indicates if OOM killer disable is supported on the host.
  , systemInfoIpv4Forwarding :: !(Maybe Bool) -- ^ "IPv4Forwarding" - Indicates IPv4 forwarding is enabled.
  , systemInfoBridgeNfIptables :: !(Maybe Bool) -- ^ "BridgeNfIptables" - Indicates if &#x60;bridge-nf-call-iptables&#x60; is available on the host.
  , systemInfoBridgeNfIp6tables :: !(Maybe Bool) -- ^ "BridgeNfIp6tables" - Indicates if &#x60;bridge-nf-call-ip6tables&#x60; is available on the host.
  , systemInfoDebug :: !(Maybe Bool) -- ^ "Debug" - Indicates if the daemon is running in debug-mode / with debug-level logging enabled.
  , systemInfoNfd :: !(Maybe Int) -- ^ "NFd" - The total number of file Descriptors in use by the daemon process.  This information is only returned if debug-mode is enabled. 
  , systemInfoNGoroutines :: !(Maybe Int) -- ^ "NGoroutines" - The  number of goroutines that currently exist.  This information is only returned if debug-mode is enabled. 
  , systemInfoSystemTime :: !(Maybe Text) -- ^ "SystemTime" - Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , systemInfoLoggingDriver :: !(Maybe Text) -- ^ "LoggingDriver" - The logging driver to use as a default for new containers. 
  , systemInfoCgroupDriver :: !(Maybe E'CgroupDriver) -- ^ "CgroupDriver" - The driver to use for managing cgroups. 
  , systemInfoNEventsListener :: !(Maybe Int) -- ^ "NEventsListener" - Number of event listeners subscribed.
  , systemInfoKernelVersion :: !(Maybe Text) -- ^ "KernelVersion" - Kernel version of the host.  On Linux, this information obtained from &#x60;uname&#x60;. On Windows this information is queried from the &lt;kbd&gt;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\&lt;/kbd&gt; registry value, for example _\&quot;10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)\&quot;_. 
  , systemInfoOperatingSystem :: !(Maybe Text) -- ^ "OperatingSystem" - Name of the host&#39;s operating system, for example: \&quot;Ubuntu 16.04.2 LTS\&quot; or \&quot;Windows Server 2016 Datacenter\&quot; 
  , systemInfoOsType :: !(Maybe Text) -- ^ "OSType" - Generic type of the operating system of the host, as returned by the Go runtime (&#x60;GOOS&#x60;).  Currently returned values are \&quot;linux\&quot; and \&quot;windows\&quot;. A full list of possible values can be found in the [Go documentation](https://go.dev/doc/install/source#environment). 
  , systemInfoArchitecture :: !(Maybe Text) -- ^ "Architecture" - Hardware architecture of the host, as returned by the Go runtime (&#x60;GOARCH&#x60;).  A full list of possible values can be found in the [Go documentation](https://go.dev/doc/install/source#environment). 
  , systemInfoNcpu :: !(Maybe Int) -- ^ "NCPU" - The number of logical CPUs usable by the daemon.  The number of available CPUs is checked by querying the operating system when the daemon starts. Changes to operating system CPU allocation after the daemon is started are not reflected. 
  , systemInfoMemTotal :: !(Maybe Integer) -- ^ "MemTotal" - Total amount of physical memory available on the host, in bytes. 
  , systemInfoIndexServerAddress :: !(Maybe Text) -- ^ "IndexServerAddress" - Address / URL of the index server that is used for image search, and as a default for user authentication for Docker Hub and Docker Cloud. 
  , systemInfoRegistryConfig :: !(Maybe RegistryServiceConfig) -- ^ "RegistryConfig"
  , systemInfoGenericResources :: !(Maybe [GenericResourcesInner]) -- ^ "GenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;)
  , systemInfoHttpProxy :: !(Maybe Text) -- ^ "HttpProxy" - HTTP-proxy configured for the daemon. This value is obtained from the [&#x60;HTTP_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.  Containers do not automatically inherit this configuration. 
  , systemInfoHttpsProxy :: !(Maybe Text) -- ^ "HttpsProxy" - HTTPS-proxy configured for the daemon. This value is obtained from the [&#x60;HTTPS_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.  Containers do not automatically inherit this configuration. 
  , systemInfoNoProxy :: !(Maybe Text) -- ^ "NoProxy" - Comma-separated list of domain extensions for which no proxy should be used. This value is obtained from the [&#x60;NO_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.  Containers do not automatically inherit this configuration. 
  , systemInfoName :: !(Maybe Text) -- ^ "Name" - Hostname of the host.
  , systemInfoLabels :: !(Maybe [Text]) -- ^ "Labels" - User-defined labels (key/value metadata) as set on the daemon.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: When part of a Swarm, nodes can both have _daemon_ labels, &gt; set through the daemon configuration, and _node_ labels, set from a &gt; manager node in the Swarm. Node labels are not included in this &gt; field. Node labels can be retrieved using the &#x60;/nodes/(id)&#x60; endpoint &gt; on a manager node in the Swarm. 
  , systemInfoExperimentalBuild :: !(Maybe Bool) -- ^ "ExperimentalBuild" - Indicates if experimental features are enabled on the daemon. 
  , systemInfoServerVersion :: !(Maybe Text) -- ^ "ServerVersion" - Version string of the daemon. 
  , systemInfoClusterStore :: !(Maybe Text) -- ^ "ClusterStore" - URL of the distributed storage backend.   The storage backend is used for multihost networking (to store network and endpoint information) and by the node discovery mechanism.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: This field is only propagated when using standalone Swarm &gt; mode, and overlay networking using an external k/v store. Overlay &gt; networks with Swarm mode enabled use the built-in raft store, and &gt; this field will be empty. 
  , systemInfoClusterAdvertise :: !(Maybe Text) -- ^ "ClusterAdvertise" - The network endpoint that the Engine advertises for the purpose of node discovery. ClusterAdvertise is a &#x60;host:port&#x60; combination on which the daemon is reachable by other hosts.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: This field is only propagated when using standalone Swarm &gt; mode, and overlay networking using an external k/v store. Overlay &gt; networks with Swarm mode enabled use the built-in raft store, and &gt; this field will be empty. 
  , systemInfoRuntimes :: !(Maybe (Map.Map String Runtime)) -- ^ "Runtimes" - List of [OCI compliant](https://github.com/opencontainers/runtime-spec) runtimes configured on the daemon. Keys hold the \&quot;name\&quot; used to reference the runtime.  The Docker daemon relies on an OCI compliant runtime (invoked via the &#x60;containerd&#x60; daemon) as its interface to the Linux kernel namespaces, cgroups, and SELinux.  The default runtime is &#x60;runc&#x60;, and automatically configured. Additional runtimes can be configured by the user and will be listed here. 
  , systemInfoDefaultRuntime :: !(Maybe Text) -- ^ "DefaultRuntime" - Name of the default OCI runtime that is used when starting containers.  The default can be overridden per-container at create time. 
  , systemInfoSwarm :: !(Maybe SwarmInfo) -- ^ "Swarm"
  , systemInfoLiveRestoreEnabled :: !(Maybe Bool) -- ^ "LiveRestoreEnabled" - Indicates if live restore is enabled.  If enabled, containers are kept running when the daemon is shutdown or upon daemon start if running containers are detected. 
  , systemInfoIsolation :: !(Maybe E'Isolation2) -- ^ "Isolation" - Represents the isolation technology to use as a default for containers. The supported values are platform-specific.  If no isolation value is specified on daemon start, on Windows client, the default is &#x60;hyperv&#x60;, and on Windows server, the default is &#x60;process&#x60;.  This option is currently not used on other platforms. 
  , systemInfoInitBinary :: !(Maybe Text) -- ^ "InitBinary" - Name and, optional, path of the &#x60;docker-init&#x60; binary.  If the path is omitted, the daemon searches the host&#39;s &#x60;$PATH&#x60; for the binary and uses the first result. 
  , systemInfoContainerdCommit :: !(Maybe Commit) -- ^ "ContainerdCommit"
  , systemInfoRuncCommit :: !(Maybe Commit) -- ^ "RuncCommit"
  , systemInfoInitCommit :: !(Maybe Commit) -- ^ "InitCommit"
  , systemInfoSecurityOptions :: !(Maybe [Text]) -- ^ "SecurityOptions" - List of security features that are enabled on the daemon, such as apparmor, seccomp, SELinux, and user-namespaces (userns).  Additional configuration options for each security feature may be present, and are included as a comma-separated list of key/value pairs. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemInfo
instance A.FromJSON SystemInfo where
  parseJSON = A.withObject "SystemInfo" $ \o ->
    SystemInfo
      <$> (o .:? "ID")
      <*> (o .:? "Containers")
      <*> (o .:? "ContainersRunning")
      <*> (o .:? "ContainersPaused")
      <*> (o .:? "ContainersStopped")
      <*> (o .:? "Images")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverStatus")
      <*> (o .:? "DockerRootDir")
      <*> (o .:? "SystemStatus")
      <*> (o .:? "Plugins")
      <*> (o .:? "MemoryLimit")
      <*> (o .:? "SwapLimit")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "CpuCfsPeriod")
      <*> (o .:? "CpuCfsQuota")
      <*> (o .:? "CPUShares")
      <*> (o .:? "CPUSet")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "IPv4Forwarding")
      <*> (o .:? "BridgeNfIptables")
      <*> (o .:? "BridgeNfIp6tables")
      <*> (o .:? "Debug")
      <*> (o .:? "NFd")
      <*> (o .:? "NGoroutines")
      <*> (o .:? "SystemTime")
      <*> (o .:? "LoggingDriver")
      <*> (o .:? "CgroupDriver")
      <*> (o .:? "NEventsListener")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "OperatingSystem")
      <*> (o .:? "OSType")
      <*> (o .:? "Architecture")
      <*> (o .:? "NCPU")
      <*> (o .:? "MemTotal")
      <*> (o .:? "IndexServerAddress")
      <*> (o .:? "RegistryConfig")
      <*> (o .:? "GenericResources")
      <*> (o .:? "HttpProxy")
      <*> (o .:? "HttpsProxy")
      <*> (o .:? "NoProxy")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "ExperimentalBuild")
      <*> (o .:? "ServerVersion")
      <*> (o .:? "ClusterStore")
      <*> (o .:? "ClusterAdvertise")
      <*> (o .:? "Runtimes")
      <*> (o .:? "DefaultRuntime")
      <*> (o .:? "Swarm")
      <*> (o .:? "LiveRestoreEnabled")
      <*> (o .:? "Isolation")
      <*> (o .:? "InitBinary")
      <*> (o .:? "ContainerdCommit")
      <*> (o .:? "RuncCommit")
      <*> (o .:? "InitCommit")
      <*> (o .:? "SecurityOptions")

-- | ToJSON SystemInfo
instance A.ToJSON SystemInfo where
  toJSON SystemInfo {..} =
   _omitNulls
      [ "ID" .= systemInfoId
      , "Containers" .= systemInfoContainers
      , "ContainersRunning" .= systemInfoContainersRunning
      , "ContainersPaused" .= systemInfoContainersPaused
      , "ContainersStopped" .= systemInfoContainersStopped
      , "Images" .= systemInfoImages
      , "Driver" .= systemInfoDriver
      , "DriverStatus" .= systemInfoDriverStatus
      , "DockerRootDir" .= systemInfoDockerRootDir
      , "SystemStatus" .= systemInfoSystemStatus
      , "Plugins" .= systemInfoPlugins
      , "MemoryLimit" .= systemInfoMemoryLimit
      , "SwapLimit" .= systemInfoSwapLimit
      , "KernelMemory" .= systemInfoKernelMemory
      , "CpuCfsPeriod" .= systemInfoCpuCfsPeriod
      , "CpuCfsQuota" .= systemInfoCpuCfsQuota
      , "CPUShares" .= systemInfoCpuShares
      , "CPUSet" .= systemInfoCpuSet
      , "OomKillDisable" .= systemInfoOomKillDisable
      , "IPv4Forwarding" .= systemInfoIpv4Forwarding
      , "BridgeNfIptables" .= systemInfoBridgeNfIptables
      , "BridgeNfIp6tables" .= systemInfoBridgeNfIp6tables
      , "Debug" .= systemInfoDebug
      , "NFd" .= systemInfoNfd
      , "NGoroutines" .= systemInfoNGoroutines
      , "SystemTime" .= systemInfoSystemTime
      , "LoggingDriver" .= systemInfoLoggingDriver
      , "CgroupDriver" .= systemInfoCgroupDriver
      , "NEventsListener" .= systemInfoNEventsListener
      , "KernelVersion" .= systemInfoKernelVersion
      , "OperatingSystem" .= systemInfoOperatingSystem
      , "OSType" .= systemInfoOsType
      , "Architecture" .= systemInfoArchitecture
      , "NCPU" .= systemInfoNcpu
      , "MemTotal" .= systemInfoMemTotal
      , "IndexServerAddress" .= systemInfoIndexServerAddress
      , "RegistryConfig" .= systemInfoRegistryConfig
      , "GenericResources" .= systemInfoGenericResources
      , "HttpProxy" .= systemInfoHttpProxy
      , "HttpsProxy" .= systemInfoHttpsProxy
      , "NoProxy" .= systemInfoNoProxy
      , "Name" .= systemInfoName
      , "Labels" .= systemInfoLabels
      , "ExperimentalBuild" .= systemInfoExperimentalBuild
      , "ServerVersion" .= systemInfoServerVersion
      , "ClusterStore" .= systemInfoClusterStore
      , "ClusterAdvertise" .= systemInfoClusterAdvertise
      , "Runtimes" .= systemInfoRuntimes
      , "DefaultRuntime" .= systemInfoDefaultRuntime
      , "Swarm" .= systemInfoSwarm
      , "LiveRestoreEnabled" .= systemInfoLiveRestoreEnabled
      , "Isolation" .= systemInfoIsolation
      , "InitBinary" .= systemInfoInitBinary
      , "ContainerdCommit" .= systemInfoContainerdCommit
      , "RuncCommit" .= systemInfoRuncCommit
      , "InitCommit" .= systemInfoInitCommit
      , "SecurityOptions" .= systemInfoSecurityOptions
      ]


-- | Construct a value of type 'SystemInfo' (by applying it's required fields, if any)
mkSystemInfo
  :: SystemInfo
mkSystemInfo =
  SystemInfo
  { systemInfoId = Nothing
  , systemInfoContainers = Nothing
  , systemInfoContainersRunning = Nothing
  , systemInfoContainersPaused = Nothing
  , systemInfoContainersStopped = Nothing
  , systemInfoImages = Nothing
  , systemInfoDriver = Nothing
  , systemInfoDriverStatus = Nothing
  , systemInfoDockerRootDir = Nothing
  , systemInfoSystemStatus = Nothing
  , systemInfoPlugins = Nothing
  , systemInfoMemoryLimit = Nothing
  , systemInfoSwapLimit = Nothing
  , systemInfoKernelMemory = Nothing
  , systemInfoCpuCfsPeriod = Nothing
  , systemInfoCpuCfsQuota = Nothing
  , systemInfoCpuShares = Nothing
  , systemInfoCpuSet = Nothing
  , systemInfoOomKillDisable = Nothing
  , systemInfoIpv4Forwarding = Nothing
  , systemInfoBridgeNfIptables = Nothing
  , systemInfoBridgeNfIp6tables = Nothing
  , systemInfoDebug = Nothing
  , systemInfoNfd = Nothing
  , systemInfoNGoroutines = Nothing
  , systemInfoSystemTime = Nothing
  , systemInfoLoggingDriver = Nothing
  , systemInfoCgroupDriver = Nothing
  , systemInfoNEventsListener = Nothing
  , systemInfoKernelVersion = Nothing
  , systemInfoOperatingSystem = Nothing
  , systemInfoOsType = Nothing
  , systemInfoArchitecture = Nothing
  , systemInfoNcpu = Nothing
  , systemInfoMemTotal = Nothing
  , systemInfoIndexServerAddress = Nothing
  , systemInfoRegistryConfig = Nothing
  , systemInfoGenericResources = Nothing
  , systemInfoHttpProxy = Nothing
  , systemInfoHttpsProxy = Nothing
  , systemInfoNoProxy = Nothing
  , systemInfoName = Nothing
  , systemInfoLabels = Nothing
  , systemInfoExperimentalBuild = Nothing
  , systemInfoServerVersion = Nothing
  , systemInfoClusterStore = Nothing
  , systemInfoClusterAdvertise = Nothing
  , systemInfoRuntimes = Nothing
  , systemInfoDefaultRuntime = Nothing
  , systemInfoSwarm = Nothing
  , systemInfoLiveRestoreEnabled = Nothing
  , systemInfoIsolation = Nothing
  , systemInfoInitBinary = Nothing
  , systemInfoContainerdCommit = Nothing
  , systemInfoRuncCommit = Nothing
  , systemInfoInitCommit = Nothing
  , systemInfoSecurityOptions = Nothing
  }

-- ** SystemVersionResponse
-- | SystemVersionResponse
-- SystemVersionResponse
-- 
data SystemVersionResponse = SystemVersionResponse
  { systemVersionResponsePlatform :: !(Maybe SystemVersionResponsePlatform) -- ^ "Platform"
  , systemVersionResponseComponents :: !(Maybe [SystemVersionResponseComponentsInner]) -- ^ "Components"
  , systemVersionResponseVersion :: !(Maybe Text) -- ^ "Version"
  , systemVersionResponseApiVersion :: !(Maybe Text) -- ^ "ApiVersion"
  , systemVersionResponseMinApiVersion :: !(Maybe Text) -- ^ "MinAPIVersion"
  , systemVersionResponseGitCommit :: !(Maybe Text) -- ^ "GitCommit"
  , systemVersionResponseGoVersion :: !(Maybe Text) -- ^ "GoVersion"
  , systemVersionResponseOs :: !(Maybe Text) -- ^ "Os"
  , systemVersionResponseArch :: !(Maybe Text) -- ^ "Arch"
  , systemVersionResponseKernelVersion :: !(Maybe Text) -- ^ "KernelVersion"
  , systemVersionResponseExperimental :: !(Maybe Bool) -- ^ "Experimental"
  , systemVersionResponseBuildTime :: !(Maybe Text) -- ^ "BuildTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersionResponse
instance A.FromJSON SystemVersionResponse where
  parseJSON = A.withObject "SystemVersionResponse" $ \o ->
    SystemVersionResponse
      <$> (o .:? "Platform")
      <*> (o .:? "Components")
      <*> (o .:? "Version")
      <*> (o .:? "ApiVersion")
      <*> (o .:? "MinAPIVersion")
      <*> (o .:? "GitCommit")
      <*> (o .:? "GoVersion")
      <*> (o .:? "Os")
      <*> (o .:? "Arch")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Experimental")
      <*> (o .:? "BuildTime")

-- | ToJSON SystemVersionResponse
instance A.ToJSON SystemVersionResponse where
  toJSON SystemVersionResponse {..} =
   _omitNulls
      [ "Platform" .= systemVersionResponsePlatform
      , "Components" .= systemVersionResponseComponents
      , "Version" .= systemVersionResponseVersion
      , "ApiVersion" .= systemVersionResponseApiVersion
      , "MinAPIVersion" .= systemVersionResponseMinApiVersion
      , "GitCommit" .= systemVersionResponseGitCommit
      , "GoVersion" .= systemVersionResponseGoVersion
      , "Os" .= systemVersionResponseOs
      , "Arch" .= systemVersionResponseArch
      , "KernelVersion" .= systemVersionResponseKernelVersion
      , "Experimental" .= systemVersionResponseExperimental
      , "BuildTime" .= systemVersionResponseBuildTime
      ]


-- | Construct a value of type 'SystemVersionResponse' (by applying it's required fields, if any)
mkSystemVersionResponse
  :: SystemVersionResponse
mkSystemVersionResponse =
  SystemVersionResponse
  { systemVersionResponsePlatform = Nothing
  , systemVersionResponseComponents = Nothing
  , systemVersionResponseVersion = Nothing
  , systemVersionResponseApiVersion = Nothing
  , systemVersionResponseMinApiVersion = Nothing
  , systemVersionResponseGitCommit = Nothing
  , systemVersionResponseGoVersion = Nothing
  , systemVersionResponseOs = Nothing
  , systemVersionResponseArch = Nothing
  , systemVersionResponseKernelVersion = Nothing
  , systemVersionResponseExperimental = Nothing
  , systemVersionResponseBuildTime = Nothing
  }

-- ** SystemVersionResponseComponentsInner
-- | SystemVersionResponseComponentsInner
data SystemVersionResponseComponentsInner = SystemVersionResponseComponentsInner
  { systemVersionResponseComponentsInnerName :: !(Text) -- ^ /Required/ "Name"
  , systemVersionResponseComponentsInnerVersion :: !(Text) -- ^ /Required/ "Version"
  , systemVersionResponseComponentsInnerDetails :: !(Maybe A.Value) -- ^ "Details"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersionResponseComponentsInner
instance A.FromJSON SystemVersionResponseComponentsInner where
  parseJSON = A.withObject "SystemVersionResponseComponentsInner" $ \o ->
    SystemVersionResponseComponentsInner
      <$> (o .:  "Name")
      <*> (o .:  "Version")
      <*> (o .:? "Details")

-- | ToJSON SystemVersionResponseComponentsInner
instance A.ToJSON SystemVersionResponseComponentsInner where
  toJSON SystemVersionResponseComponentsInner {..} =
   _omitNulls
      [ "Name" .= systemVersionResponseComponentsInnerName
      , "Version" .= systemVersionResponseComponentsInnerVersion
      , "Details" .= systemVersionResponseComponentsInnerDetails
      ]


-- | Construct a value of type 'SystemVersionResponseComponentsInner' (by applying it's required fields, if any)
mkSystemVersionResponseComponentsInner
  :: Text -- ^ 'systemVersionResponseComponentsInnerName' 
  -> Text -- ^ 'systemVersionResponseComponentsInnerVersion' 
  -> SystemVersionResponseComponentsInner
mkSystemVersionResponseComponentsInner systemVersionResponseComponentsInnerName systemVersionResponseComponentsInnerVersion =
  SystemVersionResponseComponentsInner
  { systemVersionResponseComponentsInnerName
  , systemVersionResponseComponentsInnerVersion
  , systemVersionResponseComponentsInnerDetails = Nothing
  }

-- ** SystemVersionResponsePlatform
-- | SystemVersionResponsePlatform
data SystemVersionResponsePlatform = SystemVersionResponsePlatform
  { systemVersionResponsePlatformName :: !(Text) -- ^ /Required/ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersionResponsePlatform
instance A.FromJSON SystemVersionResponsePlatform where
  parseJSON = A.withObject "SystemVersionResponsePlatform" $ \o ->
    SystemVersionResponsePlatform
      <$> (o .:  "Name")

-- | ToJSON SystemVersionResponsePlatform
instance A.ToJSON SystemVersionResponsePlatform where
  toJSON SystemVersionResponsePlatform {..} =
   _omitNulls
      [ "Name" .= systemVersionResponsePlatformName
      ]


-- | Construct a value of type 'SystemVersionResponsePlatform' (by applying it's required fields, if any)
mkSystemVersionResponsePlatform
  :: Text -- ^ 'systemVersionResponsePlatformName' 
  -> SystemVersionResponsePlatform
mkSystemVersionResponsePlatform systemVersionResponsePlatformName =
  SystemVersionResponsePlatform
  { systemVersionResponsePlatformName
  }

-- ** TLSInfo
-- | TLSInfo
-- Information about the issuer of leaf TLS certificates and the trusted root CA certificate
data TLSInfo = TLSInfo
  { tLSInfoTrustRoot :: !(Maybe Text) -- ^ "TrustRoot" - The root CA certificate(s) that are used to validate leaf TLS certificates
  , tLSInfoCertIssuerSubject :: !(Maybe Text) -- ^ "CertIssuerSubject" - The base64-url-safe-encoded raw subject bytes of the issuer
  , tLSInfoCertIssuerPublicKey :: !(Maybe Text) -- ^ "CertIssuerPublicKey" - The base64-url-safe-encoded raw public key bytes of the issuer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TLSInfo
instance A.FromJSON TLSInfo where
  parseJSON = A.withObject "TLSInfo" $ \o ->
    TLSInfo
      <$> (o .:? "TrustRoot")
      <*> (o .:? "CertIssuerSubject")
      <*> (o .:? "CertIssuerPublicKey")

-- | ToJSON TLSInfo
instance A.ToJSON TLSInfo where
  toJSON TLSInfo {..} =
   _omitNulls
      [ "TrustRoot" .= tLSInfoTrustRoot
      , "CertIssuerSubject" .= tLSInfoCertIssuerSubject
      , "CertIssuerPublicKey" .= tLSInfoCertIssuerPublicKey
      ]


-- | Construct a value of type 'TLSInfo' (by applying it's required fields, if any)
mkTLSInfo
  :: TLSInfo
mkTLSInfo =
  TLSInfo
  { tLSInfoTrustRoot = Nothing
  , tLSInfoCertIssuerSubject = Nothing
  , tLSInfoCertIssuerPublicKey = Nothing
  }

-- ** Task
-- | Task
data Task = Task
  { taskId :: !(Maybe Text) -- ^ "ID" - The ID of the task.
  , taskVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , taskCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , taskUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , taskName :: !(Maybe Text) -- ^ "Name" - Name of the task.
  , taskLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , taskSpec :: !(Maybe TaskSpec) -- ^ "Spec"
  , taskServiceId :: !(Maybe Text) -- ^ "ServiceID" - The ID of the service this task is part of.
  , taskSlot :: !(Maybe Int) -- ^ "Slot"
  , taskNodeId :: !(Maybe Text) -- ^ "NodeID" - The ID of the node that this task is on.
  , taskAssignedGenericResources :: !(Maybe [GenericResourcesInner]) -- ^ "AssignedGenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;)
  , taskStatus :: !(Maybe TaskStatus) -- ^ "Status"
  , taskDesiredState :: !(Maybe TaskState) -- ^ "DesiredState"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Task
instance A.FromJSON Task where
  parseJSON = A.withObject "Task" $ \o ->
    Task
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Spec")
      <*> (o .:? "ServiceID")
      <*> (o .:? "Slot")
      <*> (o .:? "NodeID")
      <*> (o .:? "AssignedGenericResources")
      <*> (o .:? "Status")
      <*> (o .:? "DesiredState")

-- | ToJSON Task
instance A.ToJSON Task where
  toJSON Task {..} =
   _omitNulls
      [ "ID" .= taskId
      , "Version" .= taskVersion
      , "CreatedAt" .= taskCreatedAt
      , "UpdatedAt" .= taskUpdatedAt
      , "Name" .= taskName
      , "Labels" .= taskLabels
      , "Spec" .= taskSpec
      , "ServiceID" .= taskServiceId
      , "Slot" .= taskSlot
      , "NodeID" .= taskNodeId
      , "AssignedGenericResources" .= taskAssignedGenericResources
      , "Status" .= taskStatus
      , "DesiredState" .= taskDesiredState
      ]


-- | Construct a value of type 'Task' (by applying it's required fields, if any)
mkTask
  :: Task
mkTask =
  Task
  { taskId = Nothing
  , taskVersion = Nothing
  , taskCreatedAt = Nothing
  , taskUpdatedAt = Nothing
  , taskName = Nothing
  , taskLabels = Nothing
  , taskSpec = Nothing
  , taskServiceId = Nothing
  , taskSlot = Nothing
  , taskNodeId = Nothing
  , taskAssignedGenericResources = Nothing
  , taskStatus = Nothing
  , taskDesiredState = Nothing
  }

-- ** TaskSpec
-- | TaskSpec
-- User modifiable task configuration.
data TaskSpec = TaskSpec
  { taskSpecPluginSpec :: !(Maybe TaskSpecPluginSpec) -- ^ "PluginSpec"
  , taskSpecContainerSpec :: !(Maybe TaskSpecContainerSpec) -- ^ "ContainerSpec"
  , taskSpecResources :: !(Maybe TaskSpecResources) -- ^ "Resources"
  , taskSpecRestartPolicy :: !(Maybe TaskSpecRestartPolicy) -- ^ "RestartPolicy"
  , taskSpecPlacement :: !(Maybe TaskSpecPlacement) -- ^ "Placement"
  , taskSpecForceUpdate :: !(Maybe Int) -- ^ "ForceUpdate" - A counter that triggers an update even if no relevant parameters have been changed.
  , taskSpecRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime is the type of runtime specified for the task executor.
  , taskSpecNetworks :: !(Maybe [TaskSpecNetworksInner]) -- ^ "Networks"
  , taskSpecLogDriver :: !(Maybe TaskSpecLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpec
instance A.FromJSON TaskSpec where
  parseJSON = A.withObject "TaskSpec" $ \o ->
    TaskSpec
      <$> (o .:? "PluginSpec")
      <*> (o .:? "ContainerSpec")
      <*> (o .:? "Resources")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "Placement")
      <*> (o .:? "ForceUpdate")
      <*> (o .:? "Runtime")
      <*> (o .:? "Networks")
      <*> (o .:? "LogDriver")

-- | ToJSON TaskSpec
instance A.ToJSON TaskSpec where
  toJSON TaskSpec {..} =
   _omitNulls
      [ "PluginSpec" .= taskSpecPluginSpec
      , "ContainerSpec" .= taskSpecContainerSpec
      , "Resources" .= taskSpecResources
      , "RestartPolicy" .= taskSpecRestartPolicy
      , "Placement" .= taskSpecPlacement
      , "ForceUpdate" .= taskSpecForceUpdate
      , "Runtime" .= taskSpecRuntime
      , "Networks" .= taskSpecNetworks
      , "LogDriver" .= taskSpecLogDriver
      ]


-- | Construct a value of type 'TaskSpec' (by applying it's required fields, if any)
mkTaskSpec
  :: TaskSpec
mkTaskSpec =
  TaskSpec
  { taskSpecPluginSpec = Nothing
  , taskSpecContainerSpec = Nothing
  , taskSpecResources = Nothing
  , taskSpecRestartPolicy = Nothing
  , taskSpecPlacement = Nothing
  , taskSpecForceUpdate = Nothing
  , taskSpecRuntime = Nothing
  , taskSpecNetworks = Nothing
  , taskSpecLogDriver = Nothing
  }

-- ** TaskSpecContainerSpec
-- | TaskSpecContainerSpec
-- Invalid when specified with `PluginSpec`.
data TaskSpecContainerSpec = TaskSpecContainerSpec
  { taskSpecContainerSpecImage :: !(Maybe Text) -- ^ "Image" - The image name to use for the container
  , taskSpecContainerSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value data.
  , taskSpecContainerSpecCommand :: !(Maybe [Text]) -- ^ "Command" - The command to be run in the image.
  , taskSpecContainerSpecArgs :: !(Maybe [Text]) -- ^ "Args" - Arguments to the command.
  , taskSpecContainerSpecHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname.
  , taskSpecContainerSpecEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;VAR&#x3D;value&#x60;.
  , taskSpecContainerSpecDir :: !(Maybe Text) -- ^ "Dir" - The working directory for commands to run in.
  , taskSpecContainerSpecUser :: !(Maybe Text) -- ^ "User" - The user inside the container.
  , taskSpecContainerSpecGroups :: !(Maybe [Text]) -- ^ "Groups" - A list of additional groups that the container process will run as.
  , taskSpecContainerSpecPrivileges :: !(Maybe TaskSpecContainerSpecPrivileges) -- ^ "Privileges"
  , taskSpecContainerSpecTty :: !(Maybe Bool) -- ^ "TTY" - Whether a pseudo-TTY should be allocated.
  , taskSpecContainerSpecOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , taskSpecContainerSpecReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Mount the container&#39;s root filesystem as read only.
  , taskSpecContainerSpecMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to containers created as part of the service.
  , taskSpecContainerSpecStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop the container.
  , taskSpecContainerSpecStopGracePeriod :: !(Maybe Integer) -- ^ "StopGracePeriod" - Amount of time to wait for the container to terminate before forcefully killing it.
  , taskSpecContainerSpecHealthCheck :: !(Maybe HealthConfig) -- ^ "HealthCheck"
  , taskSpecContainerSpecHosts :: !(Maybe [Text]) -- ^ "Hosts" - A list of hostname/IP mappings to add to the container&#39;s &#x60;hosts&#x60; file. The format of extra hosts is specified in the [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html) man page:      IP_address canonical_hostname [aliases...] 
  , taskSpecContainerSpecDnsConfig :: !(Maybe TaskSpecContainerSpecDNSConfig) -- ^ "DNSConfig"
  , taskSpecContainerSpecSecrets :: !(Maybe [TaskSpecContainerSpecSecretsInner]) -- ^ "Secrets" - Secrets contains references to zero or more secrets that will be exposed to the service.
  , taskSpecContainerSpecConfigs :: !(Maybe [TaskSpecContainerSpecConfigsInner]) -- ^ "Configs" - Configs contains references to zero or more configs that will be exposed to the service.
  , taskSpecContainerSpecIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the containers running the service. (Windows only)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpec
instance A.FromJSON TaskSpecContainerSpec where
  parseJSON = A.withObject "TaskSpecContainerSpec" $ \o ->
    TaskSpecContainerSpec
      <$> (o .:? "Image")
      <*> (o .:? "Labels")
      <*> (o .:? "Command")
      <*> (o .:? "Args")
      <*> (o .:? "Hostname")
      <*> (o .:? "Env")
      <*> (o .:? "Dir")
      <*> (o .:? "User")
      <*> (o .:? "Groups")
      <*> (o .:? "Privileges")
      <*> (o .:? "TTY")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Mounts")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopGracePeriod")
      <*> (o .:? "HealthCheck")
      <*> (o .:? "Hosts")
      <*> (o .:? "DNSConfig")
      <*> (o .:? "Secrets")
      <*> (o .:? "Configs")
      <*> (o .:? "Isolation")

-- | ToJSON TaskSpecContainerSpec
instance A.ToJSON TaskSpecContainerSpec where
  toJSON TaskSpecContainerSpec {..} =
   _omitNulls
      [ "Image" .= taskSpecContainerSpecImage
      , "Labels" .= taskSpecContainerSpecLabels
      , "Command" .= taskSpecContainerSpecCommand
      , "Args" .= taskSpecContainerSpecArgs
      , "Hostname" .= taskSpecContainerSpecHostname
      , "Env" .= taskSpecContainerSpecEnv
      , "Dir" .= taskSpecContainerSpecDir
      , "User" .= taskSpecContainerSpecUser
      , "Groups" .= taskSpecContainerSpecGroups
      , "Privileges" .= taskSpecContainerSpecPrivileges
      , "TTY" .= taskSpecContainerSpecTty
      , "OpenStdin" .= taskSpecContainerSpecOpenStdin
      , "ReadOnly" .= taskSpecContainerSpecReadOnly
      , "Mounts" .= taskSpecContainerSpecMounts
      , "StopSignal" .= taskSpecContainerSpecStopSignal
      , "StopGracePeriod" .= taskSpecContainerSpecStopGracePeriod
      , "HealthCheck" .= taskSpecContainerSpecHealthCheck
      , "Hosts" .= taskSpecContainerSpecHosts
      , "DNSConfig" .= taskSpecContainerSpecDnsConfig
      , "Secrets" .= taskSpecContainerSpecSecrets
      , "Configs" .= taskSpecContainerSpecConfigs
      , "Isolation" .= taskSpecContainerSpecIsolation
      ]


-- | Construct a value of type 'TaskSpecContainerSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpec
  :: TaskSpecContainerSpec
mkTaskSpecContainerSpec =
  TaskSpecContainerSpec
  { taskSpecContainerSpecImage = Nothing
  , taskSpecContainerSpecLabels = Nothing
  , taskSpecContainerSpecCommand = Nothing
  , taskSpecContainerSpecArgs = Nothing
  , taskSpecContainerSpecHostname = Nothing
  , taskSpecContainerSpecEnv = Nothing
  , taskSpecContainerSpecDir = Nothing
  , taskSpecContainerSpecUser = Nothing
  , taskSpecContainerSpecGroups = Nothing
  , taskSpecContainerSpecPrivileges = Nothing
  , taskSpecContainerSpecTty = Nothing
  , taskSpecContainerSpecOpenStdin = Nothing
  , taskSpecContainerSpecReadOnly = Nothing
  , taskSpecContainerSpecMounts = Nothing
  , taskSpecContainerSpecStopSignal = Nothing
  , taskSpecContainerSpecStopGracePeriod = Nothing
  , taskSpecContainerSpecHealthCheck = Nothing
  , taskSpecContainerSpecHosts = Nothing
  , taskSpecContainerSpecDnsConfig = Nothing
  , taskSpecContainerSpecSecrets = Nothing
  , taskSpecContainerSpecConfigs = Nothing
  , taskSpecContainerSpecIsolation = Nothing
  }

-- ** TaskSpecContainerSpecConfigsInner
-- | TaskSpecContainerSpecConfigsInner
data TaskSpecContainerSpecConfigsInner = TaskSpecContainerSpecConfigsInner
  { taskSpecContainerSpecConfigsInnerFile :: !(Maybe TaskSpecContainerSpecSecretsInnerFile) -- ^ "File"
  , taskSpecContainerSpecConfigsInnerConfigId :: !(Maybe Text) -- ^ "ConfigID" - ConfigID represents the ID of the specific config that we&#39;re referencing.
  , taskSpecContainerSpecConfigsInnerConfigName :: !(Maybe Text) -- ^ "ConfigName" - ConfigName is the name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecConfigsInner
instance A.FromJSON TaskSpecContainerSpecConfigsInner where
  parseJSON = A.withObject "TaskSpecContainerSpecConfigsInner" $ \o ->
    TaskSpecContainerSpecConfigsInner
      <$> (o .:? "File")
      <*> (o .:? "ConfigID")
      <*> (o .:? "ConfigName")

-- | ToJSON TaskSpecContainerSpecConfigsInner
instance A.ToJSON TaskSpecContainerSpecConfigsInner where
  toJSON TaskSpecContainerSpecConfigsInner {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecConfigsInnerFile
      , "ConfigID" .= taskSpecContainerSpecConfigsInnerConfigId
      , "ConfigName" .= taskSpecContainerSpecConfigsInnerConfigName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecConfigsInner' (by applying it's required fields, if any)
mkTaskSpecContainerSpecConfigsInner
  :: TaskSpecContainerSpecConfigsInner
mkTaskSpecContainerSpecConfigsInner =
  TaskSpecContainerSpecConfigsInner
  { taskSpecContainerSpecConfigsInnerFile = Nothing
  , taskSpecContainerSpecConfigsInnerConfigId = Nothing
  , taskSpecContainerSpecConfigsInnerConfigName = Nothing
  }

-- ** TaskSpecContainerSpecDNSConfig
-- | TaskSpecContainerSpecDNSConfig
-- Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
data TaskSpecContainerSpecDNSConfig = TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers :: !(Maybe [Text]) -- ^ "Nameservers" - The IP addresses of the name servers.
  , taskSpecContainerSpecDNSConfigSearch :: !(Maybe [Text]) -- ^ "Search" - A search list for host-name lookup.
  , taskSpecContainerSpecDNSConfigOptions :: !(Maybe [Text]) -- ^ "Options" - A list of internal resolver variables to be modified (e.g., &#x60;debug&#x60;, &#x60;ndots:3&#x60;, etc.).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecDNSConfig
instance A.FromJSON TaskSpecContainerSpecDNSConfig where
  parseJSON = A.withObject "TaskSpecContainerSpecDNSConfig" $ \o ->
    TaskSpecContainerSpecDNSConfig
      <$> (o .:? "Nameservers")
      <*> (o .:? "Search")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecContainerSpecDNSConfig
instance A.ToJSON TaskSpecContainerSpecDNSConfig where
  toJSON TaskSpecContainerSpecDNSConfig {..} =
   _omitNulls
      [ "Nameservers" .= taskSpecContainerSpecDNSConfigNameservers
      , "Search" .= taskSpecContainerSpecDNSConfigSearch
      , "Options" .= taskSpecContainerSpecDNSConfigOptions
      ]


-- | Construct a value of type 'TaskSpecContainerSpecDNSConfig' (by applying it's required fields, if any)
mkTaskSpecContainerSpecDNSConfig
  :: TaskSpecContainerSpecDNSConfig
mkTaskSpecContainerSpecDNSConfig =
  TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers = Nothing
  , taskSpecContainerSpecDNSConfigSearch = Nothing
  , taskSpecContainerSpecDNSConfigOptions = Nothing
  }

-- ** TaskSpecContainerSpecPrivileges
-- | TaskSpecContainerSpecPrivileges
-- Security options for the container
data TaskSpecContainerSpecPrivileges = TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec :: !(Maybe TaskSpecContainerSpecPrivilegesCredentialSpec) -- ^ "CredentialSpec"
  , taskSpecContainerSpecPrivilegesSeLinuxContext :: !(Maybe TaskSpecContainerSpecPrivilegesSELinuxContext) -- ^ "SELinuxContext"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivileges
instance A.FromJSON TaskSpecContainerSpecPrivileges where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivileges" $ \o ->
    TaskSpecContainerSpecPrivileges
      <$> (o .:? "CredentialSpec")
      <*> (o .:? "SELinuxContext")

-- | ToJSON TaskSpecContainerSpecPrivileges
instance A.ToJSON TaskSpecContainerSpecPrivileges where
  toJSON TaskSpecContainerSpecPrivileges {..} =
   _omitNulls
      [ "CredentialSpec" .= taskSpecContainerSpecPrivilegesCredentialSpec
      , "SELinuxContext" .= taskSpecContainerSpecPrivilegesSeLinuxContext
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivileges' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivileges
  :: TaskSpecContainerSpecPrivileges
mkTaskSpecContainerSpecPrivileges =
  TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec = Nothing
  , taskSpecContainerSpecPrivilegesSeLinuxContext = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesCredentialSpec
-- | TaskSpecContainerSpecPrivilegesCredentialSpec
-- CredentialSpec for managed service account (Windows only)
data TaskSpecContainerSpecPrivilegesCredentialSpec = TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecFile :: !(Maybe Text) -- ^ "File" - Load credential spec from this file. The file is read by the daemon, and must be present in the &#x60;CredentialSpecs&#x60; subdirectory in the docker data directory, which defaults to &#x60;C:\\ProgramData\\Docker\\&#x60; on Windows.  For example, specifying &#x60;spec.json&#x60; loads &#x60;C:\\ProgramData\\Docker\\CredentialSpecs\\spec.json&#x60;.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: &#x60;CredentialSpec.File&#x60; and &#x60;CredentialSpec.Registry&#x60; are mutually exclusive. 
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry :: !(Maybe Text) -- ^ "Registry" - Load credential spec from this value in the Windows registry. The specified registry value must be located in:  &#x60;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs&#x60;  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;   &gt; **Note**: &#x60;CredentialSpec.File&#x60; and &#x60;CredentialSpec.Registry&#x60; are mutually exclusive. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesCredentialSpec" $ \o ->
    TaskSpecContainerSpecPrivilegesCredentialSpec
      <$> (o .:? "File")
      <*> (o .:? "Registry")

-- | ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  toJSON TaskSpecContainerSpecPrivilegesCredentialSpec {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecPrivilegesCredentialSpecFile
      , "Registry" .= taskSpecContainerSpecPrivilegesCredentialSpecRegistry
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesCredentialSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesCredentialSpec
  :: TaskSpecContainerSpecPrivilegesCredentialSpec
mkTaskSpecContainerSpecPrivilegesCredentialSpec =
  TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecFile = Nothing
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesSELinuxContext
-- | TaskSpecContainerSpecPrivilegesSELinuxContext
-- SELinux labels of the container
data TaskSpecContainerSpecPrivilegesSELinuxContext = TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable :: !(Maybe Bool) -- ^ "Disable" - Disable SELinux
  , taskSpecContainerSpecPrivilegesSELinuxContextUser :: !(Maybe Text) -- ^ "User" - SELinux user label
  , taskSpecContainerSpecPrivilegesSELinuxContextRole :: !(Maybe Text) -- ^ "Role" - SELinux role label
  , taskSpecContainerSpecPrivilegesSELinuxContextType :: !(Maybe Text) -- ^ "Type" - SELinux type label
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel :: !(Maybe Text) -- ^ "Level" - SELinux level label
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesSELinuxContext" $ \o ->
    TaskSpecContainerSpecPrivilegesSELinuxContext
      <$> (o .:? "Disable")
      <*> (o .:? "User")
      <*> (o .:? "Role")
      <*> (o .:? "Type")
      <*> (o .:? "Level")

-- | ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  toJSON TaskSpecContainerSpecPrivilegesSELinuxContext {..} =
   _omitNulls
      [ "Disable" .= taskSpecContainerSpecPrivilegesSELinuxContextDisable
      , "User" .= taskSpecContainerSpecPrivilegesSELinuxContextUser
      , "Role" .= taskSpecContainerSpecPrivilegesSELinuxContextRole
      , "Type" .= taskSpecContainerSpecPrivilegesSELinuxContextType
      , "Level" .= taskSpecContainerSpecPrivilegesSELinuxContextLevel
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesSELinuxContext' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesSELinuxContext
  :: TaskSpecContainerSpecPrivilegesSELinuxContext
mkTaskSpecContainerSpecPrivilegesSELinuxContext =
  TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextUser = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextRole = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextType = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel = Nothing
  }

-- ** TaskSpecContainerSpecSecretsInner
-- | TaskSpecContainerSpecSecretsInner
data TaskSpecContainerSpecSecretsInner = TaskSpecContainerSpecSecretsInner
  { taskSpecContainerSpecSecretsInnerFile :: !(Maybe TaskSpecContainerSpecSecretsInnerFile) -- ^ "File"
  , taskSpecContainerSpecSecretsInnerSecretId :: !(Maybe Text) -- ^ "SecretID" - SecretID represents the ID of the specific secret that we&#39;re referencing.
  , taskSpecContainerSpecSecretsInnerSecretName :: !(Maybe Text) -- ^ "SecretName" - SecretName is the name of the secret that this references, but this is just provided for lookup/display purposes. The secret in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecSecretsInner
instance A.FromJSON TaskSpecContainerSpecSecretsInner where
  parseJSON = A.withObject "TaskSpecContainerSpecSecretsInner" $ \o ->
    TaskSpecContainerSpecSecretsInner
      <$> (o .:? "File")
      <*> (o .:? "SecretID")
      <*> (o .:? "SecretName")

-- | ToJSON TaskSpecContainerSpecSecretsInner
instance A.ToJSON TaskSpecContainerSpecSecretsInner where
  toJSON TaskSpecContainerSpecSecretsInner {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecSecretsInnerFile
      , "SecretID" .= taskSpecContainerSpecSecretsInnerSecretId
      , "SecretName" .= taskSpecContainerSpecSecretsInnerSecretName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecSecretsInner' (by applying it's required fields, if any)
mkTaskSpecContainerSpecSecretsInner
  :: TaskSpecContainerSpecSecretsInner
mkTaskSpecContainerSpecSecretsInner =
  TaskSpecContainerSpecSecretsInner
  { taskSpecContainerSpecSecretsInnerFile = Nothing
  , taskSpecContainerSpecSecretsInnerSecretId = Nothing
  , taskSpecContainerSpecSecretsInnerSecretName = Nothing
  }

-- ** TaskSpecContainerSpecSecretsInnerFile
-- | TaskSpecContainerSpecSecretsInnerFile
-- File represents a specific target that is backed by a file.
data TaskSpecContainerSpecSecretsInnerFile = TaskSpecContainerSpecSecretsInnerFile
  { taskSpecContainerSpecSecretsInnerFileName :: !(Maybe Text) -- ^ "Name" - Name represents the final filename in the filesystem.
  , taskSpecContainerSpecSecretsInnerFileUid :: !(Maybe Text) -- ^ "UID" - UID represents the file UID.
  , taskSpecContainerSpecSecretsInnerFileGid :: !(Maybe Text) -- ^ "GID" - GID represents the file GID.
  , taskSpecContainerSpecSecretsInnerFileMode :: !(Maybe Int) -- ^ "Mode" - Mode represents the FileMode of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecSecretsInnerFile
instance A.FromJSON TaskSpecContainerSpecSecretsInnerFile where
  parseJSON = A.withObject "TaskSpecContainerSpecSecretsInnerFile" $ \o ->
    TaskSpecContainerSpecSecretsInnerFile
      <$> (o .:? "Name")
      <*> (o .:? "UID")
      <*> (o .:? "GID")
      <*> (o .:? "Mode")

-- | ToJSON TaskSpecContainerSpecSecretsInnerFile
instance A.ToJSON TaskSpecContainerSpecSecretsInnerFile where
  toJSON TaskSpecContainerSpecSecretsInnerFile {..} =
   _omitNulls
      [ "Name" .= taskSpecContainerSpecSecretsInnerFileName
      , "UID" .= taskSpecContainerSpecSecretsInnerFileUid
      , "GID" .= taskSpecContainerSpecSecretsInnerFileGid
      , "Mode" .= taskSpecContainerSpecSecretsInnerFileMode
      ]


-- | Construct a value of type 'TaskSpecContainerSpecSecretsInnerFile' (by applying it's required fields, if any)
mkTaskSpecContainerSpecSecretsInnerFile
  :: TaskSpecContainerSpecSecretsInnerFile
mkTaskSpecContainerSpecSecretsInnerFile =
  TaskSpecContainerSpecSecretsInnerFile
  { taskSpecContainerSpecSecretsInnerFileName = Nothing
  , taskSpecContainerSpecSecretsInnerFileUid = Nothing
  , taskSpecContainerSpecSecretsInnerFileGid = Nothing
  , taskSpecContainerSpecSecretsInnerFileMode = Nothing
  }

-- ** TaskSpecLogDriver
-- | TaskSpecLogDriver
-- Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
data TaskSpecLogDriver = TaskSpecLogDriver
  { taskSpecLogDriverName :: !(Maybe Text) -- ^ "Name"
  , taskSpecLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecLogDriver
instance A.FromJSON TaskSpecLogDriver where
  parseJSON = A.withObject "TaskSpecLogDriver" $ \o ->
    TaskSpecLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecLogDriver
instance A.ToJSON TaskSpecLogDriver where
  toJSON TaskSpecLogDriver {..} =
   _omitNulls
      [ "Name" .= taskSpecLogDriverName
      , "Options" .= taskSpecLogDriverOptions
      ]


-- | Construct a value of type 'TaskSpecLogDriver' (by applying it's required fields, if any)
mkTaskSpecLogDriver
  :: TaskSpecLogDriver
mkTaskSpecLogDriver =
  TaskSpecLogDriver
  { taskSpecLogDriverName = Nothing
  , taskSpecLogDriverOptions = Nothing
  }

-- ** TaskSpecNetworksInner
-- | TaskSpecNetworksInner
data TaskSpecNetworksInner = TaskSpecNetworksInner
  { taskSpecNetworksInnerTarget :: !(Maybe Text) -- ^ "Target"
  , taskSpecNetworksInnerAliases :: !(Maybe [Text]) -- ^ "Aliases"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecNetworksInner
instance A.FromJSON TaskSpecNetworksInner where
  parseJSON = A.withObject "TaskSpecNetworksInner" $ \o ->
    TaskSpecNetworksInner
      <$> (o .:? "Target")
      <*> (o .:? "Aliases")

-- | ToJSON TaskSpecNetworksInner
instance A.ToJSON TaskSpecNetworksInner where
  toJSON TaskSpecNetworksInner {..} =
   _omitNulls
      [ "Target" .= taskSpecNetworksInnerTarget
      , "Aliases" .= taskSpecNetworksInnerAliases
      ]


-- | Construct a value of type 'TaskSpecNetworksInner' (by applying it's required fields, if any)
mkTaskSpecNetworksInner
  :: TaskSpecNetworksInner
mkTaskSpecNetworksInner =
  TaskSpecNetworksInner
  { taskSpecNetworksInnerTarget = Nothing
  , taskSpecNetworksInnerAliases = Nothing
  }

-- ** TaskSpecPlacement
-- | TaskSpecPlacement
data TaskSpecPlacement = TaskSpecPlacement
  { taskSpecPlacementConstraints :: !(Maybe [Text]) -- ^ "Constraints" - An array of constraints.
  , taskSpecPlacementPreferences :: !(Maybe [TaskSpecPlacementPreferencesInner]) -- ^ "Preferences" - Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.
  , taskSpecPlacementPlatforms :: !(Maybe [Platform]) -- ^ "Platforms" - Platforms stores all the platforms that the service&#39;s image can run on. This field is used in the platform filter for scheduling. If empty, then the platform filter is off, meaning there are no scheduling restrictions. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacement
instance A.FromJSON TaskSpecPlacement where
  parseJSON = A.withObject "TaskSpecPlacement" $ \o ->
    TaskSpecPlacement
      <$> (o .:? "Constraints")
      <*> (o .:? "Preferences")
      <*> (o .:? "Platforms")

-- | ToJSON TaskSpecPlacement
instance A.ToJSON TaskSpecPlacement where
  toJSON TaskSpecPlacement {..} =
   _omitNulls
      [ "Constraints" .= taskSpecPlacementConstraints
      , "Preferences" .= taskSpecPlacementPreferences
      , "Platforms" .= taskSpecPlacementPlatforms
      ]


-- | Construct a value of type 'TaskSpecPlacement' (by applying it's required fields, if any)
mkTaskSpecPlacement
  :: TaskSpecPlacement
mkTaskSpecPlacement =
  TaskSpecPlacement
  { taskSpecPlacementConstraints = Nothing
  , taskSpecPlacementPreferences = Nothing
  , taskSpecPlacementPlatforms = Nothing
  }

-- ** TaskSpecPlacementPreferencesInner
-- | TaskSpecPlacementPreferencesInner
data TaskSpecPlacementPreferencesInner = TaskSpecPlacementPreferencesInner
  { taskSpecPlacementPreferencesInnerSpread :: !(Maybe TaskSpecPlacementPreferencesInnerSpread) -- ^ "Spread"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementPreferencesInner
instance A.FromJSON TaskSpecPlacementPreferencesInner where
  parseJSON = A.withObject "TaskSpecPlacementPreferencesInner" $ \o ->
    TaskSpecPlacementPreferencesInner
      <$> (o .:? "Spread")

-- | ToJSON TaskSpecPlacementPreferencesInner
instance A.ToJSON TaskSpecPlacementPreferencesInner where
  toJSON TaskSpecPlacementPreferencesInner {..} =
   _omitNulls
      [ "Spread" .= taskSpecPlacementPreferencesInnerSpread
      ]


-- | Construct a value of type 'TaskSpecPlacementPreferencesInner' (by applying it's required fields, if any)
mkTaskSpecPlacementPreferencesInner
  :: TaskSpecPlacementPreferencesInner
mkTaskSpecPlacementPreferencesInner =
  TaskSpecPlacementPreferencesInner
  { taskSpecPlacementPreferencesInnerSpread = Nothing
  }

-- ** TaskSpecPlacementPreferencesInnerSpread
-- | TaskSpecPlacementPreferencesInnerSpread
data TaskSpecPlacementPreferencesInnerSpread = TaskSpecPlacementPreferencesInnerSpread
  { taskSpecPlacementPreferencesInnerSpreadSpreadDescriptor :: !(Maybe Text) -- ^ "SpreadDescriptor" - label descriptor, such as engine.labels.az
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementPreferencesInnerSpread
instance A.FromJSON TaskSpecPlacementPreferencesInnerSpread where
  parseJSON = A.withObject "TaskSpecPlacementPreferencesInnerSpread" $ \o ->
    TaskSpecPlacementPreferencesInnerSpread
      <$> (o .:? "SpreadDescriptor")

-- | ToJSON TaskSpecPlacementPreferencesInnerSpread
instance A.ToJSON TaskSpecPlacementPreferencesInnerSpread where
  toJSON TaskSpecPlacementPreferencesInnerSpread {..} =
   _omitNulls
      [ "SpreadDescriptor" .= taskSpecPlacementPreferencesInnerSpreadSpreadDescriptor
      ]


-- | Construct a value of type 'TaskSpecPlacementPreferencesInnerSpread' (by applying it's required fields, if any)
mkTaskSpecPlacementPreferencesInnerSpread
  :: TaskSpecPlacementPreferencesInnerSpread
mkTaskSpecPlacementPreferencesInnerSpread =
  TaskSpecPlacementPreferencesInnerSpread
  { taskSpecPlacementPreferencesInnerSpreadSpreadDescriptor = Nothing
  }

-- ** TaskSpecPluginSpec
-- | TaskSpecPluginSpec
-- Invalid when specified with `ContainerSpec`. *(Experimental release only.)*
data TaskSpecPluginSpec = TaskSpecPluginSpec
  { taskSpecPluginSpecName :: !(Maybe Text) -- ^ "Name" - The name or &#39;alias&#39; to use for the plugin.
  , taskSpecPluginSpecRemote :: !(Maybe Text) -- ^ "Remote" - The plugin image reference to use.
  , taskSpecPluginSpecDisabled :: !(Maybe Bool) -- ^ "Disabled" - Disable the plugin once scheduled.
  , taskSpecPluginSpecPluginPrivilege :: !(Maybe [PluginPullRequestInner]) -- ^ "PluginPrivilege"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPluginSpec
instance A.FromJSON TaskSpecPluginSpec where
  parseJSON = A.withObject "TaskSpecPluginSpec" $ \o ->
    TaskSpecPluginSpec
      <$> (o .:? "Name")
      <*> (o .:? "Remote")
      <*> (o .:? "Disabled")
      <*> (o .:? "PluginPrivilege")

-- | ToJSON TaskSpecPluginSpec
instance A.ToJSON TaskSpecPluginSpec where
  toJSON TaskSpecPluginSpec {..} =
   _omitNulls
      [ "Name" .= taskSpecPluginSpecName
      , "Remote" .= taskSpecPluginSpecRemote
      , "Disabled" .= taskSpecPluginSpecDisabled
      , "PluginPrivilege" .= taskSpecPluginSpecPluginPrivilege
      ]


-- | Construct a value of type 'TaskSpecPluginSpec' (by applying it's required fields, if any)
mkTaskSpecPluginSpec
  :: TaskSpecPluginSpec
mkTaskSpecPluginSpec =
  TaskSpecPluginSpec
  { taskSpecPluginSpecName = Nothing
  , taskSpecPluginSpecRemote = Nothing
  , taskSpecPluginSpecDisabled = Nothing
  , taskSpecPluginSpecPluginPrivilege = Nothing
  }

-- ** TaskSpecResources
-- | TaskSpecResources
-- Resource requirements which apply to each individual container created as part of the service.
data TaskSpecResources = TaskSpecResources
  { taskSpecResourcesLimits :: !(Maybe ResourceObject) -- ^ "Limits"
  , taskSpecResourcesReservations :: !(Maybe ResourceObject) -- ^ "Reservations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResources
instance A.FromJSON TaskSpecResources where
  parseJSON = A.withObject "TaskSpecResources" $ \o ->
    TaskSpecResources
      <$> (o .:? "Limits")
      <*> (o .:? "Reservations")

-- | ToJSON TaskSpecResources
instance A.ToJSON TaskSpecResources where
  toJSON TaskSpecResources {..} =
   _omitNulls
      [ "Limits" .= taskSpecResourcesLimits
      , "Reservations" .= taskSpecResourcesReservations
      ]


-- | Construct a value of type 'TaskSpecResources' (by applying it's required fields, if any)
mkTaskSpecResources
  :: TaskSpecResources
mkTaskSpecResources =
  TaskSpecResources
  { taskSpecResourcesLimits = Nothing
  , taskSpecResourcesReservations = Nothing
  }

-- ** TaskSpecRestartPolicy
-- | TaskSpecRestartPolicy
-- Specification for the restart policy which applies to containers created as part of this service.
data TaskSpecRestartPolicy = TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition :: !(Maybe E'Condition) -- ^ "Condition" - Condition for restart.
  , taskSpecRestartPolicyDelay :: !(Maybe Integer) -- ^ "Delay" - Delay between restart attempts.
  , taskSpecRestartPolicyMaxAttempts :: !(Maybe Integer) -- ^ "MaxAttempts" - Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
  , taskSpecRestartPolicyWindow :: !(Maybe Integer) -- ^ "Window" - Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecRestartPolicy
instance A.FromJSON TaskSpecRestartPolicy where
  parseJSON = A.withObject "TaskSpecRestartPolicy" $ \o ->
    TaskSpecRestartPolicy
      <$> (o .:? "Condition")
      <*> (o .:? "Delay")
      <*> (o .:? "MaxAttempts")
      <*> (o .:? "Window")

-- | ToJSON TaskSpecRestartPolicy
instance A.ToJSON TaskSpecRestartPolicy where
  toJSON TaskSpecRestartPolicy {..} =
   _omitNulls
      [ "Condition" .= taskSpecRestartPolicyCondition
      , "Delay" .= taskSpecRestartPolicyDelay
      , "MaxAttempts" .= taskSpecRestartPolicyMaxAttempts
      , "Window" .= taskSpecRestartPolicyWindow
      ]


-- | Construct a value of type 'TaskSpecRestartPolicy' (by applying it's required fields, if any)
mkTaskSpecRestartPolicy
  :: TaskSpecRestartPolicy
mkTaskSpecRestartPolicy =
  TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition = Nothing
  , taskSpecRestartPolicyDelay = Nothing
  , taskSpecRestartPolicyMaxAttempts = Nothing
  , taskSpecRestartPolicyWindow = Nothing
  }

-- ** TaskStatus
-- | TaskStatus
data TaskStatus = TaskStatus
  { taskStatusTimestamp :: !(Maybe Text) -- ^ "Timestamp"
  , taskStatusState :: !(Maybe TaskState) -- ^ "State"
  , taskStatusMessage :: !(Maybe Text) -- ^ "Message"
  , taskStatusErr :: !(Maybe Text) -- ^ "Err"
  , taskStatusContainerStatus :: !(Maybe TaskStatusContainerStatus) -- ^ "ContainerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatus
instance A.FromJSON TaskStatus where
  parseJSON = A.withObject "TaskStatus" $ \o ->
    TaskStatus
      <$> (o .:? "Timestamp")
      <*> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Err")
      <*> (o .:? "ContainerStatus")

-- | ToJSON TaskStatus
instance A.ToJSON TaskStatus where
  toJSON TaskStatus {..} =
   _omitNulls
      [ "Timestamp" .= taskStatusTimestamp
      , "State" .= taskStatusState
      , "Message" .= taskStatusMessage
      , "Err" .= taskStatusErr
      , "ContainerStatus" .= taskStatusContainerStatus
      ]


-- | Construct a value of type 'TaskStatus' (by applying it's required fields, if any)
mkTaskStatus
  :: TaskStatus
mkTaskStatus =
  TaskStatus
  { taskStatusTimestamp = Nothing
  , taskStatusState = Nothing
  , taskStatusMessage = Nothing
  , taskStatusErr = Nothing
  , taskStatusContainerStatus = Nothing
  }

-- ** TaskStatusContainerStatus
-- | TaskStatusContainerStatus
data TaskStatusContainerStatus = TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , taskStatusContainerStatusPid :: !(Maybe Int) -- ^ "PID"
  , taskStatusContainerStatusExitCode :: !(Maybe Int) -- ^ "ExitCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatusContainerStatus
instance A.FromJSON TaskStatusContainerStatus where
  parseJSON = A.withObject "TaskStatusContainerStatus" $ \o ->
    TaskStatusContainerStatus
      <$> (o .:? "ContainerID")
      <*> (o .:? "PID")
      <*> (o .:? "ExitCode")

-- | ToJSON TaskStatusContainerStatus
instance A.ToJSON TaskStatusContainerStatus where
  toJSON TaskStatusContainerStatus {..} =
   _omitNulls
      [ "ContainerID" .= taskStatusContainerStatusContainerId
      , "PID" .= taskStatusContainerStatusPid
      , "ExitCode" .= taskStatusContainerStatusExitCode
      ]


-- | Construct a value of type 'TaskStatusContainerStatus' (by applying it's required fields, if any)
mkTaskStatusContainerStatus
  :: TaskStatusContainerStatus
mkTaskStatusContainerStatus =
  TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId = Nothing
  , taskStatusContainerStatusPid = Nothing
  , taskStatusContainerStatusExitCode = Nothing
  }

-- ** ThrottleDevice
-- | ThrottleDevice
data ThrottleDevice = ThrottleDevice
  { throttleDevicePath :: !(Maybe Text) -- ^ "Path" - Device path
  , throttleDeviceRate :: !(Maybe Integer) -- ^ "Rate" - Rate
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThrottleDevice
instance A.FromJSON ThrottleDevice where
  parseJSON = A.withObject "ThrottleDevice" $ \o ->
    ThrottleDevice
      <$> (o .:? "Path")
      <*> (o .:? "Rate")

-- | ToJSON ThrottleDevice
instance A.ToJSON ThrottleDevice where
  toJSON ThrottleDevice {..} =
   _omitNulls
      [ "Path" .= throttleDevicePath
      , "Rate" .= throttleDeviceRate
      ]


-- | Construct a value of type 'ThrottleDevice' (by applying it's required fields, if any)
mkThrottleDevice
  :: ThrottleDevice
mkThrottleDevice =
  ThrottleDevice
  { throttleDevicePath = Nothing
  , throttleDeviceRate = Nothing
  }

-- ** UnlockKeyResponse
-- | UnlockKeyResponse
-- UnlockKeyResponse
-- 
data UnlockKeyResponse = UnlockKeyResponse
  { unlockKeyResponseUnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnlockKeyResponse
instance A.FromJSON UnlockKeyResponse where
  parseJSON = A.withObject "UnlockKeyResponse" $ \o ->
    UnlockKeyResponse
      <$> (o .:? "UnlockKey")

-- | ToJSON UnlockKeyResponse
instance A.ToJSON UnlockKeyResponse where
  toJSON UnlockKeyResponse {..} =
   _omitNulls
      [ "UnlockKey" .= unlockKeyResponseUnlockKey
      ]


-- | Construct a value of type 'UnlockKeyResponse' (by applying it's required fields, if any)
mkUnlockKeyResponse
  :: UnlockKeyResponse
mkUnlockKeyResponse =
  UnlockKeyResponse
  { unlockKeyResponseUnlockKey = Nothing
  }

-- ** Volume
-- | Volume
data Volume = Volume
  { volumeName :: !(Text) -- ^ /Required/ "Name" - Name of the volume.
  , volumeDriver :: !(Text) -- ^ /Required/ "Driver" - Name of the volume driver used by the volume.
  , volumeMountpoint :: !(Text) -- ^ /Required/ "Mountpoint" - Mount path of the volume on the host.
  , volumeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date/Time the volume was created.
  , volumeStatus :: !(Maybe (Map.Map String A.Value)) -- ^ "Status" - Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: &#x60;{\&quot;key\&quot;:\&quot;value\&quot;,\&quot;key2\&quot;:\&quot;value2\&quot;}&#x60;.  The &#x60;Status&#x60; field is optional, and is omitted if the volume driver does not support this feature. 
  , volumeLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels" - User-defined key/value metadata.
  , volumeScope :: !(E'Scope) -- ^ /Required/ "Scope" - The level at which the volume exists. Either &#x60;global&#x60; for cluster-wide, or &#x60;local&#x60; for machine level.
  , volumeOptions :: !((Map.Map String Text)) -- ^ /Required/ "Options" - The driver specific options used when creating the volume.
  , volumeUsageData :: !(Maybe VolumeUsageData) -- ^ "UsageData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Volume
instance A.FromJSON Volume where
  parseJSON = A.withObject "Volume" $ \o ->
    Volume
      <$> (o .:  "Name")
      <*> (o .:  "Driver")
      <*> (o .:  "Mountpoint")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "Status")
      <*> (o .:  "Labels")
      <*> (o .:  "Scope")
      <*> (o .:  "Options")
      <*> (o .:? "UsageData")

-- | ToJSON Volume
instance A.ToJSON Volume where
  toJSON Volume {..} =
   _omitNulls
      [ "Name" .= volumeName
      , "Driver" .= volumeDriver
      , "Mountpoint" .= volumeMountpoint
      , "CreatedAt" .= volumeCreatedAt
      , "Status" .= volumeStatus
      , "Labels" .= volumeLabels
      , "Scope" .= volumeScope
      , "Options" .= volumeOptions
      , "UsageData" .= volumeUsageData
      ]


-- | Construct a value of type 'Volume' (by applying it's required fields, if any)
mkVolume
  :: Text -- ^ 'volumeName': Name of the volume.
  -> Text -- ^ 'volumeDriver': Name of the volume driver used by the volume.
  -> Text -- ^ 'volumeMountpoint': Mount path of the volume on the host.
  -> (Map.Map String Text) -- ^ 'volumeLabels': User-defined key/value metadata.
  -> E'Scope -- ^ 'volumeScope': The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
  -> (Map.Map String Text) -- ^ 'volumeOptions': The driver specific options used when creating the volume.
  -> Volume
mkVolume volumeName volumeDriver volumeMountpoint volumeLabels volumeScope volumeOptions =
  Volume
  { volumeName
  , volumeDriver
  , volumeMountpoint
  , volumeCreatedAt = Nothing
  , volumeStatus = Nothing
  , volumeLabels
  , volumeScope
  , volumeOptions
  , volumeUsageData = Nothing
  }

-- ** VolumeCreateRequest
-- | VolumeCreateRequest
data VolumeCreateRequest = VolumeCreateRequest
  { volumeCreateRequestName :: !(Maybe Text) -- ^ "Name" - The new volume&#39;s name. If not specified, Docker generates a name.
  , volumeCreateRequestDriver :: !(Maybe Text) -- ^ "Driver" - Name of the volume driver to use.
  , volumeCreateRequestDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
  , volumeCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeCreateRequest
instance A.FromJSON VolumeCreateRequest where
  parseJSON = A.withObject "VolumeCreateRequest" $ \o ->
    VolumeCreateRequest
      <$> (o .:? "Name")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverOpts")
      <*> (o .:? "Labels")

-- | ToJSON VolumeCreateRequest
instance A.ToJSON VolumeCreateRequest where
  toJSON VolumeCreateRequest {..} =
   _omitNulls
      [ "Name" .= volumeCreateRequestName
      , "Driver" .= volumeCreateRequestDriver
      , "DriverOpts" .= volumeCreateRequestDriverOpts
      , "Labels" .= volumeCreateRequestLabels
      ]


-- | Construct a value of type 'VolumeCreateRequest' (by applying it's required fields, if any)
mkVolumeCreateRequest
  :: VolumeCreateRequest
mkVolumeCreateRequest =
  VolumeCreateRequest
  { volumeCreateRequestName = Nothing
  , volumeCreateRequestDriver = Nothing
  , volumeCreateRequestDriverOpts = Nothing
  , volumeCreateRequestLabels = Nothing
  }

-- ** VolumeListResponse
-- | VolumeListResponse
-- VolumeListResponse
-- 
data VolumeListResponse = VolumeListResponse
  { volumeListResponseVolumes :: !([Volume]) -- ^ /Required/ "Volumes" - List of volumes
  , volumeListResponseWarnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings that occurred when fetching the list of volumes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeListResponse
instance A.FromJSON VolumeListResponse where
  parseJSON = A.withObject "VolumeListResponse" $ \o ->
    VolumeListResponse
      <$> (o .:  "Volumes")
      <*> (o .:  "Warnings")

-- | ToJSON VolumeListResponse
instance A.ToJSON VolumeListResponse where
  toJSON VolumeListResponse {..} =
   _omitNulls
      [ "Volumes" .= volumeListResponseVolumes
      , "Warnings" .= volumeListResponseWarnings
      ]


-- | Construct a value of type 'VolumeListResponse' (by applying it's required fields, if any)
mkVolumeListResponse
  :: [Volume] -- ^ 'volumeListResponseVolumes': List of volumes
  -> [Text] -- ^ 'volumeListResponseWarnings': Warnings that occurred when fetching the list of volumes
  -> VolumeListResponse
mkVolumeListResponse volumeListResponseVolumes volumeListResponseWarnings =
  VolumeListResponse
  { volumeListResponseVolumes
  , volumeListResponseWarnings
  }

-- ** VolumePruneResponse
-- | VolumePruneResponse
-- VolumePruneResponse
-- 
data VolumePruneResponse = VolumePruneResponse
  { volumePruneResponseVolumesDeleted :: !(Maybe [Text]) -- ^ "VolumesDeleted" - Volumes that were deleted
  , volumePruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumePruneResponse
instance A.FromJSON VolumePruneResponse where
  parseJSON = A.withObject "VolumePruneResponse" $ \o ->
    VolumePruneResponse
      <$> (o .:? "VolumesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON VolumePruneResponse
instance A.ToJSON VolumePruneResponse where
  toJSON VolumePruneResponse {..} =
   _omitNulls
      [ "VolumesDeleted" .= volumePruneResponseVolumesDeleted
      , "SpaceReclaimed" .= volumePruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'VolumePruneResponse' (by applying it's required fields, if any)
mkVolumePruneResponse
  :: VolumePruneResponse
mkVolumePruneResponse =
  VolumePruneResponse
  { volumePruneResponseVolumesDeleted = Nothing
  , volumePruneResponseSpaceReclaimed = Nothing
  }

-- ** VolumeUsageData
-- | VolumeUsageData
-- Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints. 
data VolumeUsageData = VolumeUsageData
  { volumeUsageDataSize :: !(Int) -- ^ /Required/ "Size" - Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the &#x60;\&quot;local\&quot;&#x60; volume driver. For volumes created with other volume drivers, this field is set to &#x60;-1&#x60; (\&quot;not available\&quot;) 
  , volumeUsageDataRefCount :: !(Int) -- ^ /Required/ "RefCount" - The number of containers referencing this volume. This field is set to &#x60;-1&#x60; if the reference-count is not available. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeUsageData
instance A.FromJSON VolumeUsageData where
  parseJSON = A.withObject "VolumeUsageData" $ \o ->
    VolumeUsageData
      <$> (o .:  "Size")
      <*> (o .:  "RefCount")

-- | ToJSON VolumeUsageData
instance A.ToJSON VolumeUsageData where
  toJSON VolumeUsageData {..} =
   _omitNulls
      [ "Size" .= volumeUsageDataSize
      , "RefCount" .= volumeUsageDataRefCount
      ]


-- | Construct a value of type 'VolumeUsageData' (by applying it's required fields, if any)
mkVolumeUsageData
  :: Int -- ^ 'volumeUsageDataSize': Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\") 
  -> Int -- ^ 'volumeUsageDataRefCount': The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available. 
  -> VolumeUsageData
mkVolumeUsageData volumeUsageDataSize volumeUsageDataRefCount =
  VolumeUsageData
  { volumeUsageDataSize
  , volumeUsageDataRefCount
  }


-- * Enums


-- ** E'Availability

-- | Enum of 'Text' .
-- Availability of the node.
data E'Availability
  = E'Availability'Active -- ^ @"active"@
  | E'Availability'Pause -- ^ @"pause"@
  | E'Availability'Drain -- ^ @"drain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Availability where toJSON = A.toJSON . fromE'Availability
instance A.FromJSON E'Availability where parseJSON o = P.either P.fail (pure . P.id) . toE'Availability =<< A.parseJSON o
instance WH.ToHttpApiData E'Availability where toQueryParam = WH.toQueryParam . fromE'Availability
instance WH.FromHttpApiData E'Availability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Availability
instance MimeRender MimeMultipartFormData E'Availability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Availability' enum
fromE'Availability :: E'Availability -> Text
fromE'Availability = \case
  E'Availability'Active -> "active"
  E'Availability'Pause -> "pause"
  E'Availability'Drain -> "drain"

-- | parse 'E'Availability' enum
toE'Availability :: Text -> P.Either String E'Availability
toE'Availability = \case
  "active" -> P.Right E'Availability'Active
  "pause" -> P.Right E'Availability'Pause
  "drain" -> P.Right E'Availability'Drain
  s -> P.Left $ "toE'Availability: enum parse failure: " P.++ P.show s


-- ** E'CgroupDriver

-- | Enum of 'Text' .
-- The driver to use for managing cgroups. 
data E'CgroupDriver
  = E'CgroupDriver'Cgroupfs -- ^ @"cgroupfs"@
  | E'CgroupDriver'Systemd -- ^ @"systemd"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CgroupDriver where toJSON = A.toJSON . fromE'CgroupDriver
instance A.FromJSON E'CgroupDriver where parseJSON o = P.either P.fail (pure . P.id) . toE'CgroupDriver =<< A.parseJSON o
instance WH.ToHttpApiData E'CgroupDriver where toQueryParam = WH.toQueryParam . fromE'CgroupDriver
instance WH.FromHttpApiData E'CgroupDriver where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CgroupDriver
instance MimeRender MimeMultipartFormData E'CgroupDriver where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CgroupDriver' enum
fromE'CgroupDriver :: E'CgroupDriver -> Text
fromE'CgroupDriver = \case
  E'CgroupDriver'Cgroupfs -> "cgroupfs"
  E'CgroupDriver'Systemd -> "systemd"

-- | parse 'E'CgroupDriver' enum
toE'CgroupDriver :: Text -> P.Either String E'CgroupDriver
toE'CgroupDriver = \case
  "cgroupfs" -> P.Right E'CgroupDriver'Cgroupfs
  "systemd" -> P.Right E'CgroupDriver'Systemd
  s -> P.Left $ "toE'CgroupDriver: enum parse failure: " P.++ P.show s


-- ** E'Condition

-- | Enum of 'Text' .
-- Condition for restart.
data E'Condition
  = E'Condition'None -- ^ @"none"@
  | E'Condition'On_failure -- ^ @"on-failure"@
  | E'Condition'Any -- ^ @"any"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition where toJSON = A.toJSON . fromE'Condition
instance A.FromJSON E'Condition where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition where toQueryParam = WH.toQueryParam . fromE'Condition
instance WH.FromHttpApiData E'Condition where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition
instance MimeRender MimeMultipartFormData E'Condition where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition' enum
fromE'Condition :: E'Condition -> Text
fromE'Condition = \case
  E'Condition'None -> "none"
  E'Condition'On_failure -> "on-failure"
  E'Condition'Any -> "any"

-- | parse 'E'Condition' enum
toE'Condition :: Text -> P.Either String E'Condition
toE'Condition = \case
  "none" -> P.Right E'Condition'None
  "on-failure" -> P.Right E'Condition'On_failure
  "any" -> P.Right E'Condition'Any
  s -> P.Left $ "toE'Condition: enum parse failure: " P.++ P.show s


-- ** E'Condition2

-- | Enum of 'Text'
data E'Condition2
  = E'Condition2'Not_running -- ^ @"not-running"@
  | E'Condition2'Next_exit -- ^ @"next-exit"@
  | E'Condition2'Removed -- ^ @"removed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition2 where toJSON = A.toJSON . fromE'Condition2
instance A.FromJSON E'Condition2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition2 where toQueryParam = WH.toQueryParam . fromE'Condition2
instance WH.FromHttpApiData E'Condition2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition2
instance MimeRender MimeMultipartFormData E'Condition2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition2' enum
fromE'Condition2 :: E'Condition2 -> Text
fromE'Condition2 = \case
  E'Condition2'Not_running -> "not-running"
  E'Condition2'Next_exit -> "next-exit"
  E'Condition2'Removed -> "removed"

-- | parse 'E'Condition2' enum
toE'Condition2 :: Text -> P.Either String E'Condition2
toE'Condition2 = \case
  "not-running" -> P.Right E'Condition2'Not_running
  "next-exit" -> P.Right E'Condition2'Next_exit
  "removed" -> P.Right E'Condition2'Removed
  s -> P.Left $ "toE'Condition2: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Application_x_tar -- ^ @"application/x-tar"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Application_x_tar -> "application/x-tar"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/x-tar" -> P.Right E'ContentType'Application_x_tar
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'FailureAction

-- | Enum of 'Text' .
-- Action to take if an updated task fails to run, or stops running during the update.
data E'FailureAction
  = E'FailureAction'Continue -- ^ @"continue"@
  | E'FailureAction'Pause -- ^ @"pause"@
  | E'FailureAction'Rollback -- ^ @"rollback"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction where toJSON = A.toJSON . fromE'FailureAction
instance A.FromJSON E'FailureAction where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction where toQueryParam = WH.toQueryParam . fromE'FailureAction
instance WH.FromHttpApiData E'FailureAction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction
instance MimeRender MimeMultipartFormData E'FailureAction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction' enum
fromE'FailureAction :: E'FailureAction -> Text
fromE'FailureAction = \case
  E'FailureAction'Continue -> "continue"
  E'FailureAction'Pause -> "pause"
  E'FailureAction'Rollback -> "rollback"

-- | parse 'E'FailureAction' enum
toE'FailureAction :: Text -> P.Either String E'FailureAction
toE'FailureAction = \case
  "continue" -> P.Right E'FailureAction'Continue
  "pause" -> P.Right E'FailureAction'Pause
  "rollback" -> P.Right E'FailureAction'Rollback
  s -> P.Left $ "toE'FailureAction: enum parse failure: " P.++ P.show s


-- ** E'FailureAction2

-- | Enum of 'Text' .
-- Action to take if an rolled back task fails to run, or stops running during the rollback.
data E'FailureAction2
  = E'FailureAction2'Continue -- ^ @"continue"@
  | E'FailureAction2'Pause -- ^ @"pause"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction2 where toJSON = A.toJSON . fromE'FailureAction2
instance A.FromJSON E'FailureAction2 where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction2 =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction2 where toQueryParam = WH.toQueryParam . fromE'FailureAction2
instance WH.FromHttpApiData E'FailureAction2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction2
instance MimeRender MimeMultipartFormData E'FailureAction2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction2' enum
fromE'FailureAction2 :: E'FailureAction2 -> Text
fromE'FailureAction2 = \case
  E'FailureAction2'Continue -> "continue"
  E'FailureAction2'Pause -> "pause"

-- | parse 'E'FailureAction2' enum
toE'FailureAction2 :: Text -> P.Either String E'FailureAction2
toE'FailureAction2 = \case
  "continue" -> P.Right E'FailureAction2'Continue
  "pause" -> P.Right E'FailureAction2'Pause
  s -> P.Left $ "toE'FailureAction2: enum parse failure: " P.++ P.show s


-- ** E'Isolation

-- | Enum of 'Text' .
-- Isolation technology of the container. (Windows only)
data E'Isolation
  = E'Isolation'Default -- ^ @"default"@
  | E'Isolation'Process -- ^ @"process"@
  | E'Isolation'Hyperv -- ^ @"hyperv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation where toJSON = A.toJSON . fromE'Isolation
instance A.FromJSON E'Isolation where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation where toQueryParam = WH.toQueryParam . fromE'Isolation
instance WH.FromHttpApiData E'Isolation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation
instance MimeRender MimeMultipartFormData E'Isolation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation' enum
fromE'Isolation :: E'Isolation -> Text
fromE'Isolation = \case
  E'Isolation'Default -> "default"
  E'Isolation'Process -> "process"
  E'Isolation'Hyperv -> "hyperv"

-- | parse 'E'Isolation' enum
toE'Isolation :: Text -> P.Either String E'Isolation
toE'Isolation = \case
  "default" -> P.Right E'Isolation'Default
  "process" -> P.Right E'Isolation'Process
  "hyperv" -> P.Right E'Isolation'Hyperv
  s -> P.Left $ "toE'Isolation: enum parse failure: " P.++ P.show s


-- ** E'Isolation2

-- | Enum of 'Text' .
-- Represents the isolation technology to use as a default for containers. The supported values are platform-specific.  If no isolation value is specified on daemon start, on Windows client, the default is `hyperv`, and on Windows server, the default is `process`.  This option is currently not used on other platforms. 
data E'Isolation2
  = E'Isolation2'Default -- ^ @"default"@
  | E'Isolation2'Hyperv -- ^ @"hyperv"@
  | E'Isolation2'Process -- ^ @"process"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation2 where toJSON = A.toJSON . fromE'Isolation2
instance A.FromJSON E'Isolation2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation2 where toQueryParam = WH.toQueryParam . fromE'Isolation2
instance WH.FromHttpApiData E'Isolation2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation2
instance MimeRender MimeMultipartFormData E'Isolation2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation2' enum
fromE'Isolation2 :: E'Isolation2 -> Text
fromE'Isolation2 = \case
  E'Isolation2'Default -> "default"
  E'Isolation2'Hyperv -> "hyperv"
  E'Isolation2'Process -> "process"

-- | parse 'E'Isolation2' enum
toE'Isolation2 :: Text -> P.Either String E'Isolation2
toE'Isolation2 = \case
  "default" -> P.Right E'Isolation2'Default
  "hyperv" -> P.Right E'Isolation2'Hyperv
  "process" -> P.Right E'Isolation2'Process
  s -> P.Left $ "toE'Isolation2: enum parse failure: " P.++ P.show s


-- ** E'Mode

-- | Enum of 'Text' .
-- The mode of resolution to use for internal load balancing between tasks.
data E'Mode
  = E'Mode'Vip -- ^ @"vip"@
  | E'Mode'Dnsrr -- ^ @"dnsrr"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode where toJSON = A.toJSON . fromE'Mode
instance A.FromJSON E'Mode where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode where toQueryParam = WH.toQueryParam . fromE'Mode
instance WH.FromHttpApiData E'Mode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode
instance MimeRender MimeMultipartFormData E'Mode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode' enum
fromE'Mode :: E'Mode -> Text
fromE'Mode = \case
  E'Mode'Vip -> "vip"
  E'Mode'Dnsrr -> "dnsrr"

-- | parse 'E'Mode' enum
toE'Mode :: Text -> P.Either String E'Mode
toE'Mode = \case
  "vip" -> P.Right E'Mode'Vip
  "dnsrr" -> P.Right E'Mode'Dnsrr
  s -> P.Left $ "toE'Mode: enum parse failure: " P.++ P.show s


-- ** E'Name

-- | Enum of 'Text' .
-- - Empty string means not to restart - `always` Always restart - `unless-stopped` Restart always except when the user has manually stopped the container - `on-failure` Restart only when the container exit code is non-zero 
data E'Name
  = E'Name'Empty -- ^ @""@
  | E'Name'Always -- ^ @"always"@
  | E'Name'Unless_stopped -- ^ @"unless-stopped"@
  | E'Name'On_failure -- ^ @"on-failure"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Name where toJSON = A.toJSON . fromE'Name
instance A.FromJSON E'Name where parseJSON o = P.either P.fail (pure . P.id) . toE'Name =<< A.parseJSON o
instance WH.ToHttpApiData E'Name where toQueryParam = WH.toQueryParam . fromE'Name
instance WH.FromHttpApiData E'Name where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Name
instance MimeRender MimeMultipartFormData E'Name where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Name' enum
fromE'Name :: E'Name -> Text
fromE'Name = \case
  E'Name'Empty -> ""
  E'Name'Always -> "always"
  E'Name'Unless_stopped -> "unless-stopped"
  E'Name'On_failure -> "on-failure"

-- | parse 'E'Name' enum
toE'Name :: Text -> P.Either String E'Name
toE'Name = \case
  "" -> P.Right E'Name'Empty
  "always" -> P.Right E'Name'Always
  "unless-stopped" -> P.Right E'Name'Unless_stopped
  "on-failure" -> P.Right E'Name'On_failure
  s -> P.Left $ "toE'Name: enum parse failure: " P.++ P.show s


-- ** E'Order

-- | Enum of 'Text' .
-- The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
data E'Order
  = E'Order'Stop_first -- ^ @"stop-first"@
  | E'Order'Start_first -- ^ @"start-first"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Order where toJSON = A.toJSON . fromE'Order
instance A.FromJSON E'Order where parseJSON o = P.either P.fail (pure . P.id) . toE'Order =<< A.parseJSON o
instance WH.ToHttpApiData E'Order where toQueryParam = WH.toQueryParam . fromE'Order
instance WH.FromHttpApiData E'Order where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Order
instance MimeRender MimeMultipartFormData E'Order where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Order' enum
fromE'Order :: E'Order -> Text
fromE'Order = \case
  E'Order'Stop_first -> "stop-first"
  E'Order'Start_first -> "start-first"

-- | parse 'E'Order' enum
toE'Order :: Text -> P.Either String E'Order
toE'Order = \case
  "stop-first" -> P.Right E'Order'Stop_first
  "start-first" -> P.Right E'Order'Start_first
  s -> P.Left $ "toE'Order: enum parse failure: " P.++ P.show s


-- ** E'Propagation

-- | Enum of 'Text' .
-- A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
data E'Propagation
  = E'Propagation'Private -- ^ @"private"@
  | E'Propagation'Rprivate -- ^ @"rprivate"@
  | E'Propagation'Shared -- ^ @"shared"@
  | E'Propagation'Rshared -- ^ @"rshared"@
  | E'Propagation'Slave -- ^ @"slave"@
  | E'Propagation'Rslave -- ^ @"rslave"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Propagation where toJSON = A.toJSON . fromE'Propagation
instance A.FromJSON E'Propagation where parseJSON o = P.either P.fail (pure . P.id) . toE'Propagation =<< A.parseJSON o
instance WH.ToHttpApiData E'Propagation where toQueryParam = WH.toQueryParam . fromE'Propagation
instance WH.FromHttpApiData E'Propagation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Propagation
instance MimeRender MimeMultipartFormData E'Propagation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Propagation' enum
fromE'Propagation :: E'Propagation -> Text
fromE'Propagation = \case
  E'Propagation'Private -> "private"
  E'Propagation'Rprivate -> "rprivate"
  E'Propagation'Shared -> "shared"
  E'Propagation'Rshared -> "rshared"
  E'Propagation'Slave -> "slave"
  E'Propagation'Rslave -> "rslave"

-- | parse 'E'Propagation' enum
toE'Propagation :: Text -> P.Either String E'Propagation
toE'Propagation = \case
  "private" -> P.Right E'Propagation'Private
  "rprivate" -> P.Right E'Propagation'Rprivate
  "shared" -> P.Right E'Propagation'Shared
  "rshared" -> P.Right E'Propagation'Rshared
  "slave" -> P.Right E'Propagation'Slave
  "rslave" -> P.Right E'Propagation'Rslave
  s -> P.Left $ "toE'Propagation: enum parse failure: " P.++ P.show s


-- ** E'Protocol

-- | Enum of 'Text' .
-- Protocol for communication with the external CA (currently only `cfssl` is supported).
data E'Protocol
  = E'Protocol'Cfssl -- ^ @"cfssl"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Protocol where toJSON = A.toJSON . fromE'Protocol
instance A.FromJSON E'Protocol where parseJSON o = P.either P.fail (pure . P.id) . toE'Protocol =<< A.parseJSON o
instance WH.ToHttpApiData E'Protocol where toQueryParam = WH.toQueryParam . fromE'Protocol
instance WH.FromHttpApiData E'Protocol where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Protocol
instance MimeRender MimeMultipartFormData E'Protocol where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Protocol' enum
fromE'Protocol :: E'Protocol -> Text
fromE'Protocol = \case
  E'Protocol'Cfssl -> "cfssl"

-- | parse 'E'Protocol' enum
toE'Protocol :: Text -> P.Either String E'Protocol
toE'Protocol = \case
  "cfssl" -> P.Right E'Protocol'Cfssl
  s -> P.Left $ "toE'Protocol: enum parse failure: " P.++ P.show s


-- ** E'PublishMode

-- | Enum of 'Text' .
-- The mode in which port is published.  <p><br /></p>  - \"ingress\" makes the target port accessible on on every node,   regardless of whether there is a task for the service running on   that node or not. - \"host\" bypasses the routing mesh and publish the port directly on   the swarm node where that service is running. 
data E'PublishMode
  = E'PublishMode'Ingress -- ^ @"ingress"@
  | E'PublishMode'Host -- ^ @"host"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PublishMode where toJSON = A.toJSON . fromE'PublishMode
instance A.FromJSON E'PublishMode where parseJSON o = P.either P.fail (pure . P.id) . toE'PublishMode =<< A.parseJSON o
instance WH.ToHttpApiData E'PublishMode where toQueryParam = WH.toQueryParam . fromE'PublishMode
instance WH.FromHttpApiData E'PublishMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PublishMode
instance MimeRender MimeMultipartFormData E'PublishMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PublishMode' enum
fromE'PublishMode :: E'PublishMode -> Text
fromE'PublishMode = \case
  E'PublishMode'Ingress -> "ingress"
  E'PublishMode'Host -> "host"

-- | parse 'E'PublishMode' enum
toE'PublishMode :: Text -> P.Either String E'PublishMode
toE'PublishMode = \case
  "ingress" -> P.Right E'PublishMode'Ingress
  "host" -> P.Right E'PublishMode'Host
  s -> P.Left $ "toE'PublishMode: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' .
-- Role of the node.
data E'Role
  = E'Role'Worker -- ^ @"worker"@
  | E'Role'Manager -- ^ @"manager"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'Worker -> "worker"
  E'Role'Manager -> "manager"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "worker" -> P.Right E'Role'Worker
  "manager" -> P.Right E'Role'Manager
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Scope

-- | Enum of 'Text' .
-- The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
data E'Scope
  = E'Scope'Local -- ^ @"local"@
  | E'Scope'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope where toJSON = A.toJSON . fromE'Scope
instance A.FromJSON E'Scope where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope where toQueryParam = WH.toQueryParam . fromE'Scope
instance WH.FromHttpApiData E'Scope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope
instance MimeRender MimeMultipartFormData E'Scope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope' enum
fromE'Scope :: E'Scope -> Text
fromE'Scope = \case
  E'Scope'Local -> "local"
  E'Scope'Global -> "global"

-- | parse 'E'Scope' enum
toE'Scope :: Text -> P.Either String E'Scope
toE'Scope = \case
  "local" -> P.Right E'Scope'Local
  "global" -> P.Right E'Scope'Global
  s -> P.Left $ "toE'Scope: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Updating -- ^ @"updating"@
  | E'State'Paused -- ^ @"paused"@
  | E'State'Completed -- ^ @"completed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Updating -> "updating"
  E'State'Paused -> "paused"
  E'State'Completed -> "completed"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "updating" -> P.Right E'State'Updating
  "paused" -> P.Right E'State'Paused
  "completed" -> P.Right E'State'Completed
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- The status of the container. For example, `\"running\"` or `\"exited\"`. 
data E'Status
  = E'Status'Created -- ^ @"created"@
  | E'Status'Running -- ^ @"running"@
  | E'Status'Paused -- ^ @"paused"@
  | E'Status'Restarting -- ^ @"restarting"@
  | E'Status'Removing -- ^ @"removing"@
  | E'Status'Exited -- ^ @"exited"@
  | E'Status'Dead -- ^ @"dead"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Created -> "created"
  E'Status'Running -> "running"
  E'Status'Paused -> "paused"
  E'Status'Restarting -> "restarting"
  E'Status'Removing -> "removing"
  E'Status'Exited -> "exited"
  E'Status'Dead -> "dead"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "created" -> P.Right E'Status'Created
  "running" -> P.Right E'Status'Running
  "paused" -> P.Right E'Status'Paused
  "restarting" -> P.Right E'Status'Restarting
  "removing" -> P.Right E'Status'Removing
  "exited" -> P.Right E'Status'Exited
  "dead" -> P.Right E'Status'Dead
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Tcp -- ^ @"tcp"@
  | E'Type'Udp -- ^ @"udp"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Tcp -> "tcp"
  E'Type'Udp -> "udp"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "tcp" -> P.Right E'Type'Tcp
  "udp" -> P.Right E'Type'Udp
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' .
-- The mount type:  - `bind` a mount of a file or directory from the host into the container. - `volume` a docker volume with the given `Name`. - `tmpfs` a `tmpfs`. - `npipe` a named pipe from the host into the container. 
data E'Type2
  = E'Type2'Bind -- ^ @"bind"@
  | E'Type2'Volume -- ^ @"volume"@
  | E'Type2'Tmpfs -- ^ @"tmpfs"@
  | E'Type2'Npipe -- ^ @"npipe"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Bind -> "bind"
  E'Type2'Volume -> "volume"
  E'Type2'Tmpfs -> "tmpfs"
  E'Type2'Npipe -> "npipe"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "bind" -> P.Right E'Type2'Bind
  "volume" -> P.Right E'Type2'Volume
  "tmpfs" -> P.Right E'Type2'Tmpfs
  "npipe" -> P.Right E'Type2'Npipe
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' .
-- The mount type. Available types:  - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container. - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. 
data E'Type3
  = E'Type3'Bind -- ^ @"bind"@
  | E'Type3'Volume -- ^ @"volume"@
  | E'Type3'Tmpfs -- ^ @"tmpfs"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Bind -> "bind"
  E'Type3'Volume -> "volume"
  E'Type3'Tmpfs -> "tmpfs"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "bind" -> P.Right E'Type3'Bind
  "volume" -> P.Right E'Type3'Volume
  "tmpfs" -> P.Right E'Type3'Tmpfs
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text'
data E'Type4
  = E'Type4'Json_file -- ^ @"json-file"@
  | E'Type4'Syslog -- ^ @"syslog"@
  | E'Type4'Journald -- ^ @"journald"@
  | E'Type4'Gelf -- ^ @"gelf"@
  | E'Type4'Fluentd -- ^ @"fluentd"@
  | E'Type4'Awslogs -- ^ @"awslogs"@
  | E'Type4'Splunk -- ^ @"splunk"@
  | E'Type4'Etwlogs -- ^ @"etwlogs"@
  | E'Type4'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Json_file -> "json-file"
  E'Type4'Syslog -> "syslog"
  E'Type4'Journald -> "journald"
  E'Type4'Gelf -> "gelf"
  E'Type4'Fluentd -> "fluentd"
  E'Type4'Awslogs -> "awslogs"
  E'Type4'Splunk -> "splunk"
  E'Type4'Etwlogs -> "etwlogs"
  E'Type4'None -> "none"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "json-file" -> P.Right E'Type4'Json_file
  "syslog" -> P.Right E'Type4'Syslog
  "journald" -> P.Right E'Type4'Journald
  "gelf" -> P.Right E'Type4'Gelf
  "fluentd" -> P.Right E'Type4'Fluentd
  "awslogs" -> P.Right E'Type4'Awslogs
  "splunk" -> P.Right E'Type4'Splunk
  "etwlogs" -> P.Right E'Type4'Etwlogs
  "none" -> P.Right E'Type4'None
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** LocalNodeState

-- | Enum of 'Text' .
-- Current local status of this node.
data LocalNodeState
  = LocalNodeState'Empty -- ^ @""@
  | LocalNodeState'Inactive -- ^ @"inactive"@
  | LocalNodeState'Pending -- ^ @"pending"@
  | LocalNodeState'Active -- ^ @"active"@
  | LocalNodeState'Error -- ^ @"error"@
  | LocalNodeState'Locked -- ^ @"locked"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LocalNodeState where toJSON = A.toJSON . fromLocalNodeState
instance A.FromJSON LocalNodeState where parseJSON o = P.either P.fail (pure . P.id) . toLocalNodeState =<< A.parseJSON o
instance WH.ToHttpApiData LocalNodeState where toQueryParam = WH.toQueryParam . fromLocalNodeState
instance WH.FromHttpApiData LocalNodeState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLocalNodeState
instance MimeRender MimeMultipartFormData LocalNodeState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LocalNodeState' enum
fromLocalNodeState :: LocalNodeState -> Text
fromLocalNodeState = \case
  LocalNodeState'Empty -> ""
  LocalNodeState'Inactive -> "inactive"
  LocalNodeState'Pending -> "pending"
  LocalNodeState'Active -> "active"
  LocalNodeState'Error -> "error"
  LocalNodeState'Locked -> "locked"

-- | parse 'LocalNodeState' enum
toLocalNodeState :: Text -> P.Either String LocalNodeState
toLocalNodeState = \case
  "" -> P.Right LocalNodeState'Empty
  "inactive" -> P.Right LocalNodeState'Inactive
  "pending" -> P.Right LocalNodeState'Pending
  "active" -> P.Right LocalNodeState'Active
  "error" -> P.Right LocalNodeState'Error
  "locked" -> P.Right LocalNodeState'Locked
  s -> P.Left $ "toLocalNodeState: enum parse failure: " P.++ P.show s


-- ** NodeState

-- | Enum of 'Text' .
-- NodeState represents the state of a node.
data NodeState
  = NodeState'Unknown -- ^ @"unknown"@
  | NodeState'Down -- ^ @"down"@
  | NodeState'Ready -- ^ @"ready"@
  | NodeState'Disconnected -- ^ @"disconnected"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NodeState where toJSON = A.toJSON . fromNodeState
instance A.FromJSON NodeState where parseJSON o = P.either P.fail (pure . P.id) . toNodeState =<< A.parseJSON o
instance WH.ToHttpApiData NodeState where toQueryParam = WH.toQueryParam . fromNodeState
instance WH.FromHttpApiData NodeState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNodeState
instance MimeRender MimeMultipartFormData NodeState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NodeState' enum
fromNodeState :: NodeState -> Text
fromNodeState = \case
  NodeState'Unknown -> "unknown"
  NodeState'Down -> "down"
  NodeState'Ready -> "ready"
  NodeState'Disconnected -> "disconnected"

-- | parse 'NodeState' enum
toNodeState :: Text -> P.Either String NodeState
toNodeState = \case
  "unknown" -> P.Right NodeState'Unknown
  "down" -> P.Right NodeState'Down
  "ready" -> P.Right NodeState'Ready
  "disconnected" -> P.Right NodeState'Disconnected
  s -> P.Left $ "toNodeState: enum parse failure: " P.++ P.show s


-- ** Reachability

-- | Enum of 'Text' .
-- Reachability represents the reachability of a node.
data Reachability
  = Reachability'Unknown -- ^ @"unknown"@
  | Reachability'Unreachable -- ^ @"unreachable"@
  | Reachability'Reachable -- ^ @"reachable"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Reachability where toJSON = A.toJSON . fromReachability
instance A.FromJSON Reachability where parseJSON o = P.either P.fail (pure . P.id) . toReachability =<< A.parseJSON o
instance WH.ToHttpApiData Reachability where toQueryParam = WH.toQueryParam . fromReachability
instance WH.FromHttpApiData Reachability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReachability
instance MimeRender MimeMultipartFormData Reachability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Reachability' enum
fromReachability :: Reachability -> Text
fromReachability = \case
  Reachability'Unknown -> "unknown"
  Reachability'Unreachable -> "unreachable"
  Reachability'Reachable -> "reachable"

-- | parse 'Reachability' enum
toReachability :: Text -> P.Either String Reachability
toReachability = \case
  "unknown" -> P.Right Reachability'Unknown
  "unreachable" -> P.Right Reachability'Unreachable
  "reachable" -> P.Right Reachability'Reachable
  s -> P.Left $ "toReachability: enum parse failure: " P.++ P.show s


-- ** TaskState

-- | Enum of 'Text'
data TaskState
  = TaskState'New -- ^ @"new"@
  | TaskState'Allocated -- ^ @"allocated"@
  | TaskState'Pending -- ^ @"pending"@
  | TaskState'Assigned -- ^ @"assigned"@
  | TaskState'Accepted -- ^ @"accepted"@
  | TaskState'Preparing -- ^ @"preparing"@
  | TaskState'Ready -- ^ @"ready"@
  | TaskState'Starting -- ^ @"starting"@
  | TaskState'Running -- ^ @"running"@
  | TaskState'Complete -- ^ @"complete"@
  | TaskState'Shutdown -- ^ @"shutdown"@
  | TaskState'Failed -- ^ @"failed"@
  | TaskState'Rejected -- ^ @"rejected"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TaskState where toJSON = A.toJSON . fromTaskState
instance A.FromJSON TaskState where parseJSON o = P.either P.fail (pure . P.id) . toTaskState =<< A.parseJSON o
instance WH.ToHttpApiData TaskState where toQueryParam = WH.toQueryParam . fromTaskState
instance WH.FromHttpApiData TaskState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTaskState
instance MimeRender MimeMultipartFormData TaskState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TaskState' enum
fromTaskState :: TaskState -> Text
fromTaskState = \case
  TaskState'New -> "new"
  TaskState'Allocated -> "allocated"
  TaskState'Pending -> "pending"
  TaskState'Assigned -> "assigned"
  TaskState'Accepted -> "accepted"
  TaskState'Preparing -> "preparing"
  TaskState'Ready -> "ready"
  TaskState'Starting -> "starting"
  TaskState'Running -> "running"
  TaskState'Complete -> "complete"
  TaskState'Shutdown -> "shutdown"
  TaskState'Failed -> "failed"
  TaskState'Rejected -> "rejected"

-- | parse 'TaskState' enum
toTaskState :: Text -> P.Either String TaskState
toTaskState = \case
  "new" -> P.Right TaskState'New
  "allocated" -> P.Right TaskState'Allocated
  "pending" -> P.Right TaskState'Pending
  "assigned" -> P.Right TaskState'Assigned
  "accepted" -> P.Right TaskState'Accepted
  "preparing" -> P.Right TaskState'Preparing
  "ready" -> P.Right TaskState'Ready
  "starting" -> P.Right TaskState'Starting
  "running" -> P.Right TaskState'Running
  "complete" -> P.Right TaskState'Complete
  "shutdown" -> P.Right TaskState'Shutdown
  "failed" -> P.Right TaskState'Failed
  "rejected" -> P.Right TaskState'Rejected
  s -> P.Left $ "toTaskState: enum parse failure: " P.++ P.show s



type Map = A.Object
